{"ast":null,"code":"import { Serializable } from \"../load/serializable.js\";\nfunction mergeContent(firstContent, secondContent) {\n  // If first content is a string\n  if (typeof firstContent === \"string\") {\n    if (typeof secondContent === \"string\") {\n      return firstContent + secondContent;\n    } else {\n      return [{\n        type: \"text\",\n        text: firstContent\n      }, ...secondContent];\n    }\n    // If both are arrays\n  } else if (Array.isArray(secondContent)) {\n    return [...firstContent, ...secondContent];\n    // If the first content is a list and second is a string\n  } else {\n    // Otherwise, add the second content as a new element of the list\n    return [...firstContent, {\n      type: \"text\",\n      text: secondContent\n    }];\n  }\n}\n/**\n * Base class for all types of messages in a conversation. It includes\n * properties like `content`, `name`, and `additional_kwargs`. It also\n * includes methods like `toDict()` and `_getType()`.\n */\nexport class BaseMessage extends Serializable {\n  get lc_aliases() {\n    // exclude snake case conversion to pascal case\n    return {\n      additional_kwargs: \"additional_kwargs\",\n      response_metadata: \"response_metadata\"\n    };\n  }\n  /**\n   * @deprecated\n   * Use {@link BaseMessage.content} instead.\n   */\n  get text() {\n    return typeof this.content === \"string\" ? this.content : \"\";\n  }\n  constructor(fields, /** @deprecated */\n  kwargs) {\n    if (typeof fields === \"string\") {\n      // eslint-disable-next-line no-param-reassign\n      fields = {\n        content: fields,\n        additional_kwargs: kwargs,\n        response_metadata: {}\n      };\n    }\n    // Make sure the default value for additional_kwargs is passed into super() for serialization\n    if (!fields.additional_kwargs) {\n      // eslint-disable-next-line no-param-reassign\n      fields.additional_kwargs = {};\n    }\n    if (!fields.response_metadata) {\n      // eslint-disable-next-line no-param-reassign\n      fields.response_metadata = {};\n    }\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"messages\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    /** The content of the message. */\n    Object.defineProperty(this, \"content\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /** The name of the message sender in a multi-user chat. */\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /** Additional keyword arguments */\n    Object.defineProperty(this, \"additional_kwargs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /** Response metadata. For example: response headers, logprobs, token counts. */\n    Object.defineProperty(this, \"response_metadata\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.name = fields.name;\n    this.content = fields.content;\n    this.additional_kwargs = fields.additional_kwargs;\n    this.response_metadata = fields.response_metadata;\n  }\n  toDict() {\n    return {\n      type: this._getType(),\n      data: this.toJSON().kwargs\n    };\n  }\n  toChunk() {\n    const type = this._getType();\n    if (type === \"human\") {\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      return new HumanMessageChunk({\n        ...this\n      });\n    } else if (type === \"ai\") {\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      return new AIMessageChunk({\n        ...this\n      });\n    } else if (type === \"system\") {\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      return new SystemMessageChunk({\n        ...this\n      });\n    } else if (type === \"function\") {\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      return new FunctionMessageChunk({\n        ...this\n      });\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    } else if (ChatMessage.isInstance(this)) {\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      return new ChatMessageChunk({\n        ...this\n      });\n    } else {\n      throw new Error(\"Unknown message type.\");\n    }\n  }\n}\nfunction isOpenAIToolCallArray(value) {\n  return Array.isArray(value) && value.every(v => typeof v.index === \"number\");\n}\nfunction _mergeDicts(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nleft,\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nright\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) {\n  const merged = {\n    ...left\n  };\n  for (const [key, value] of Object.entries(right)) {\n    if (merged[key] == null) {\n      merged[key] = value;\n    } else if (value == null) {\n      continue;\n    } else if (typeof merged[key] !== typeof value || Array.isArray(merged[key]) !== Array.isArray(value)) {\n      throw new Error(`field[${key}] already exists in the message chunk, but with a different type.`);\n    } else if (typeof merged[key] === \"string\") {\n      merged[key] = merged[key] + value;\n    } else if (!Array.isArray(merged[key]) && typeof merged[key] === \"object\") {\n      merged[key] = _mergeDicts(merged[key], value);\n    } else if (key === \"tool_calls\" && isOpenAIToolCallArray(merged[key]) && isOpenAIToolCallArray(value)) {\n      for (const toolCall of value) {\n        if (merged[key]?.[toolCall.index] !== undefined) {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          merged[key] = merged[key]?.map((value, i) => {\n            if (i !== toolCall.index) {\n              return value;\n            }\n            return {\n              ...value,\n              ...toolCall,\n              function: {\n                name: toolCall.function.name ?? value.function.name,\n                arguments: (value.function.arguments ?? \"\") + (toolCall.function.arguments ?? \"\")\n              }\n            };\n          });\n        } else {\n          merged[key][toolCall.index] = toolCall;\n        }\n      }\n    } else if (Array.isArray(merged[key])) {\n      merged[key] = merged[key].concat(value);\n    } else if (merged[key] === value) {\n      continue;\n    } else {\n      console.warn(`field[${key}] already exists in this message chunk and value has unsupported type.`);\n    }\n  }\n  return merged;\n}\n/**\n * Represents a chunk of a message, which can be concatenated with other\n * message chunks. It includes a method `_merge_kwargs_dict()` for merging\n * additional keyword arguments from another `BaseMessageChunk` into this\n * one. It also overrides the `__add__()` method to support concatenation\n * of `BaseMessageChunk` instances.\n */\nexport class BaseMessageChunk extends BaseMessage {}\n/**\n * Represents a human message in a conversation.\n */\nexport class HumanMessage extends BaseMessage {\n  static lc_name() {\n    return \"HumanMessage\";\n  }\n  _getType() {\n    return \"human\";\n  }\n}\n/**\n * Represents a chunk of a human message, which can be concatenated with\n * other human message chunks.\n */\nexport class HumanMessageChunk extends BaseMessageChunk {\n  static lc_name() {\n    return \"HumanMessageChunk\";\n  }\n  _getType() {\n    return \"human\";\n  }\n  concat(chunk) {\n    return new HumanMessageChunk({\n      content: mergeContent(this.content, chunk.content),\n      additional_kwargs: _mergeDicts(this.additional_kwargs, chunk.additional_kwargs),\n      response_metadata: _mergeDicts(this.response_metadata, chunk.response_metadata)\n    });\n  }\n}\n/**\n * Represents an AI message in a conversation.\n */\nexport class AIMessage extends BaseMessage {\n  static lc_name() {\n    return \"AIMessage\";\n  }\n  _getType() {\n    return \"ai\";\n  }\n}\n/**\n * Represents a chunk of an AI message, which can be concatenated with\n * other AI message chunks.\n */\nexport class AIMessageChunk extends BaseMessageChunk {\n  static lc_name() {\n    return \"AIMessageChunk\";\n  }\n  _getType() {\n    return \"ai\";\n  }\n  concat(chunk) {\n    return new AIMessageChunk({\n      content: mergeContent(this.content, chunk.content),\n      additional_kwargs: _mergeDicts(this.additional_kwargs, chunk.additional_kwargs),\n      response_metadata: _mergeDicts(this.response_metadata, chunk.response_metadata)\n    });\n  }\n}\n/**\n * Represents a system message in a conversation.\n */\nexport class SystemMessage extends BaseMessage {\n  static lc_name() {\n    return \"SystemMessage\";\n  }\n  _getType() {\n    return \"system\";\n  }\n}\n/**\n * Represents a chunk of a system message, which can be concatenated with\n * other system message chunks.\n */\nexport class SystemMessageChunk extends BaseMessageChunk {\n  static lc_name() {\n    return \"SystemMessageChunk\";\n  }\n  _getType() {\n    return \"system\";\n  }\n  concat(chunk) {\n    return new SystemMessageChunk({\n      content: mergeContent(this.content, chunk.content),\n      additional_kwargs: _mergeDicts(this.additional_kwargs, chunk.additional_kwargs),\n      response_metadata: _mergeDicts(this.response_metadata, chunk.response_metadata)\n    });\n  }\n}\n/**\n * Represents a function message in a conversation.\n */\nexport class FunctionMessage extends BaseMessage {\n  static lc_name() {\n    return \"FunctionMessage\";\n  }\n  constructor(fields, /** @deprecated */\n  name) {\n    if (typeof fields === \"string\") {\n      // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n      fields = {\n        content: fields,\n        name: name\n      };\n    }\n    super(fields);\n  }\n  _getType() {\n    return \"function\";\n  }\n}\n/**\n * Represents a chunk of a function message, which can be concatenated\n * with other function message chunks.\n */\nexport class FunctionMessageChunk extends BaseMessageChunk {\n  static lc_name() {\n    return \"FunctionMessageChunk\";\n  }\n  _getType() {\n    return \"function\";\n  }\n  concat(chunk) {\n    return new FunctionMessageChunk({\n      content: mergeContent(this.content, chunk.content),\n      additional_kwargs: _mergeDicts(this.additional_kwargs, chunk.additional_kwargs),\n      response_metadata: _mergeDicts(this.response_metadata, chunk.response_metadata),\n      name: this.name ?? \"\"\n    });\n  }\n}\n/**\n * Represents a tool message in a conversation.\n */\nexport class ToolMessage extends BaseMessage {\n  static lc_name() {\n    return \"ToolMessage\";\n  }\n  get lc_aliases() {\n    // exclude snake case conversion to pascal case\n    return {\n      tool_call_id: \"tool_call_id\"\n    };\n  }\n  constructor(fields, tool_call_id, name) {\n    if (typeof fields === \"string\") {\n      // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n      fields = {\n        content: fields,\n        name,\n        tool_call_id: tool_call_id\n      };\n    }\n    super(fields);\n    Object.defineProperty(this, \"tool_call_id\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.tool_call_id = fields.tool_call_id;\n  }\n  _getType() {\n    return \"tool\";\n  }\n  static isInstance(message) {\n    return message._getType() === \"tool\";\n  }\n}\n/**\n * Represents a chunk of a tool message, which can be concatenated\n * with other tool message chunks.\n */\nexport class ToolMessageChunk extends BaseMessageChunk {\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"tool_call_id\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.tool_call_id = fields.tool_call_id;\n  }\n  static lc_name() {\n    return \"ToolMessageChunk\";\n  }\n  _getType() {\n    return \"tool\";\n  }\n  concat(chunk) {\n    return new ToolMessageChunk({\n      content: mergeContent(this.content, chunk.content),\n      additional_kwargs: _mergeDicts(this.additional_kwargs, chunk.additional_kwargs),\n      response_metadata: _mergeDicts(this.response_metadata, chunk.response_metadata),\n      tool_call_id: this.tool_call_id\n    });\n  }\n}\n/**\n * Represents a chat message in a conversation.\n */\nexport class ChatMessage extends BaseMessage {\n  static lc_name() {\n    return \"ChatMessage\";\n  }\n  static _chatMessageClass() {\n    return ChatMessage;\n  }\n  constructor(fields, role) {\n    if (typeof fields === \"string\") {\n      // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n      fields = {\n        content: fields,\n        role: role\n      };\n    }\n    super(fields);\n    Object.defineProperty(this, \"role\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.role = fields.role;\n  }\n  _getType() {\n    return \"generic\";\n  }\n  static isInstance(message) {\n    return message._getType() === \"generic\";\n  }\n}\nexport function isBaseMessage(messageLike) {\n  return typeof messageLike?._getType === \"function\";\n}\nexport function isBaseMessageChunk(messageLike) {\n  return isBaseMessage(messageLike) && typeof messageLike.concat === \"function\";\n}\nexport function coerceMessageLikeToMessage(messageLike) {\n  if (typeof messageLike === \"string\") {\n    return new HumanMessage(messageLike);\n  } else if (isBaseMessage(messageLike)) {\n    return messageLike;\n  }\n  const [type, content] = messageLike;\n  if (type === \"human\" || type === \"user\") {\n    return new HumanMessage({\n      content\n    });\n  } else if (type === \"ai\" || type === \"assistant\") {\n    return new AIMessage({\n      content\n    });\n  } else if (type === \"system\") {\n    return new SystemMessage({\n      content\n    });\n  } else {\n    throw new Error(`Unable to coerce message from array: only human, AI, or system message coercion is currently supported.`);\n  }\n}\n/**\n * Represents a chunk of a chat message, which can be concatenated with\n * other chat message chunks.\n */\nexport class ChatMessageChunk extends BaseMessageChunk {\n  static lc_name() {\n    return \"ChatMessageChunk\";\n  }\n  constructor(fields, role) {\n    if (typeof fields === \"string\") {\n      // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n      fields = {\n        content: fields,\n        role: role\n      };\n    }\n    super(fields);\n    Object.defineProperty(this, \"role\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.role = fields.role;\n  }\n  _getType() {\n    return \"generic\";\n  }\n  concat(chunk) {\n    return new ChatMessageChunk({\n      content: mergeContent(this.content, chunk.content),\n      additional_kwargs: _mergeDicts(this.additional_kwargs, chunk.additional_kwargs),\n      response_metadata: _mergeDicts(this.response_metadata, chunk.response_metadata),\n      role: this.role\n    });\n  }\n}\n/**\n * This function is used by memory classes to get a string representation\n * of the chat message history, based on the message content and role.\n */\nexport function getBufferString(messages, humanPrefix = \"Human\", aiPrefix = \"AI\") {\n  const string_messages = [];\n  for (const m of messages) {\n    let role;\n    if (m._getType() === \"human\") {\n      role = humanPrefix;\n    } else if (m._getType() === \"ai\") {\n      role = aiPrefix;\n    } else if (m._getType() === \"system\") {\n      role = \"System\";\n    } else if (m._getType() === \"function\") {\n      role = \"Function\";\n    } else if (m._getType() === \"tool\") {\n      role = \"Tool\";\n    } else if (m._getType() === \"generic\") {\n      role = m.role;\n    } else {\n      throw new Error(`Got unsupported message type: ${m._getType()}`);\n    }\n    const nameStr = m.name ? `${m.name}, ` : \"\";\n    string_messages.push(`${role}: ${nameStr}${m.content}`);\n  }\n  return string_messages.join(\"\\n\");\n}\n/**\n * Maps messages from an older format (V1) to the current `StoredMessage`\n * format. If the message is already in the `StoredMessage` format, it is\n * returned as is. Otherwise, it transforms the V1 message into a\n * `StoredMessage`. This function is important for maintaining\n * compatibility with older message formats.\n */\nfunction mapV1MessageToStoredMessage(message) {\n  // TODO: Remove this mapper when we deprecate the old message format.\n  if (message.data !== undefined) {\n    return message;\n  } else {\n    const v1Message = message;\n    return {\n      type: v1Message.type,\n      data: {\n        content: v1Message.text,\n        role: v1Message.role,\n        name: undefined,\n        tool_call_id: undefined\n      }\n    };\n  }\n}\nexport function mapStoredMessageToChatMessage(message) {\n  const storedMessage = mapV1MessageToStoredMessage(message);\n  switch (storedMessage.type) {\n    case \"human\":\n      return new HumanMessage(storedMessage.data);\n    case \"ai\":\n      return new AIMessage(storedMessage.data);\n    case \"system\":\n      return new SystemMessage(storedMessage.data);\n    case \"function\":\n      if (storedMessage.data.name === undefined) {\n        throw new Error(\"Name must be defined for function messages\");\n      }\n      return new FunctionMessage(storedMessage.data);\n    case \"tool\":\n      if (storedMessage.data.tool_call_id === undefined) {\n        throw new Error(\"Tool call ID must be defined for tool messages\");\n      }\n      return new ToolMessage(storedMessage.data);\n    case \"chat\":\n      {\n        if (storedMessage.data.role === undefined) {\n          throw new Error(\"Role must be defined for chat messages\");\n        }\n        return new ChatMessage(storedMessage.data);\n      }\n    default:\n      throw new Error(`Got unexpected type: ${storedMessage.type}`);\n  }\n}\n/**\n * Transforms an array of `StoredMessage` instances into an array of\n * `BaseMessage` instances. It uses the `mapV1MessageToStoredMessage`\n * function to ensure all messages are in the `StoredMessage` format, then\n * creates new instances of the appropriate `BaseMessage` subclass based\n * on the type of each message. This function is used to prepare stored\n * messages for use in a chat context.\n */\nexport function mapStoredMessagesToChatMessages(messages) {\n  return messages.map(mapStoredMessageToChatMessage);\n}\n/**\n * Transforms an array of `BaseMessage` instances into an array of\n * `StoredMessage` instances. It does this by calling the `toDict` method\n * on each `BaseMessage`, which returns a `StoredMessage`. This function\n * is used to prepare chat messages for storage.\n */\nexport function mapChatMessagesToStoredMessages(messages) {\n  return messages.map(message => message.toDict());\n}","map":{"version":3,"names":["Serializable","mergeContent","firstContent","secondContent","type","text","Array","isArray","BaseMessage","lc_aliases","additional_kwargs","response_metadata","content","constructor","fields","kwargs","Object","defineProperty","enumerable","configurable","writable","value","name","toDict","_getType","data","toJSON","toChunk","HumanMessageChunk","AIMessageChunk","SystemMessageChunk","FunctionMessageChunk","ChatMessage","isInstance","ChatMessageChunk","Error","isOpenAIToolCallArray","every","v","index","_mergeDicts","left","right","merged","key","entries","toolCall","undefined","map","i","function","arguments","concat","console","warn","BaseMessageChunk","HumanMessage","lc_name","chunk","AIMessage","SystemMessage","FunctionMessage","ToolMessage","tool_call_id","message","ToolMessageChunk","_chatMessageClass","role","isBaseMessage","messageLike","isBaseMessageChunk","coerceMessageLikeToMessage","getBufferString","messages","humanPrefix","aiPrefix","string_messages","m","nameStr","push","join","mapV1MessageToStoredMessage","v1Message","mapStoredMessageToChatMessage","storedMessage","mapStoredMessagesToChatMessages","mapChatMessagesToStoredMessages"],"sources":["/home/nikhil/legalbot/legalbot/node_modules/@langchain/core/dist/messages/index.js"],"sourcesContent":["import { Serializable } from \"../load/serializable.js\";\nfunction mergeContent(firstContent, secondContent) {\n    // If first content is a string\n    if (typeof firstContent === \"string\") {\n        if (typeof secondContent === \"string\") {\n            return firstContent + secondContent;\n        }\n        else {\n            return [{ type: \"text\", text: firstContent }, ...secondContent];\n        }\n        // If both are arrays\n    }\n    else if (Array.isArray(secondContent)) {\n        return [...firstContent, ...secondContent];\n        // If the first content is a list and second is a string\n    }\n    else {\n        // Otherwise, add the second content as a new element of the list\n        return [...firstContent, { type: \"text\", text: secondContent }];\n    }\n}\n/**\n * Base class for all types of messages in a conversation. It includes\n * properties like `content`, `name`, and `additional_kwargs`. It also\n * includes methods like `toDict()` and `_getType()`.\n */\nexport class BaseMessage extends Serializable {\n    get lc_aliases() {\n        // exclude snake case conversion to pascal case\n        return {\n            additional_kwargs: \"additional_kwargs\",\n            response_metadata: \"response_metadata\",\n        };\n    }\n    /**\n     * @deprecated\n     * Use {@link BaseMessage.content} instead.\n     */\n    get text() {\n        return typeof this.content === \"string\" ? this.content : \"\";\n    }\n    constructor(fields, \n    /** @deprecated */\n    kwargs) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign\n            fields = {\n                content: fields,\n                additional_kwargs: kwargs,\n                response_metadata: {},\n            };\n        }\n        // Make sure the default value for additional_kwargs is passed into super() for serialization\n        if (!fields.additional_kwargs) {\n            // eslint-disable-next-line no-param-reassign\n            fields.additional_kwargs = {};\n        }\n        if (!fields.response_metadata) {\n            // eslint-disable-next-line no-param-reassign\n            fields.response_metadata = {};\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"messages\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        /** The content of the message. */\n        Object.defineProperty(this, \"content\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** The name of the message sender in a multi-user chat. */\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** Additional keyword arguments */\n        Object.defineProperty(this, \"additional_kwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** Response metadata. For example: response headers, logprobs, token counts. */\n        Object.defineProperty(this, \"response_metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = fields.name;\n        this.content = fields.content;\n        this.additional_kwargs = fields.additional_kwargs;\n        this.response_metadata = fields.response_metadata;\n    }\n    toDict() {\n        return {\n            type: this._getType(),\n            data: this.toJSON()\n                .kwargs,\n        };\n    }\n    toChunk() {\n        const type = this._getType();\n        if (type === \"human\") {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            return new HumanMessageChunk({ ...this });\n        }\n        else if (type === \"ai\") {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            return new AIMessageChunk({ ...this });\n        }\n        else if (type === \"system\") {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            return new SystemMessageChunk({ ...this });\n        }\n        else if (type === \"function\") {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            return new FunctionMessageChunk({ ...this });\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        }\n        else if (ChatMessage.isInstance(this)) {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            return new ChatMessageChunk({ ...this });\n        }\n        else {\n            throw new Error(\"Unknown message type.\");\n        }\n    }\n}\nfunction isOpenAIToolCallArray(value) {\n    return (Array.isArray(value) &&\n        value.every((v) => typeof v.index === \"number\"));\n}\nfunction _mergeDicts(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nleft, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nright\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) {\n    const merged = { ...left };\n    for (const [key, value] of Object.entries(right)) {\n        if (merged[key] == null) {\n            merged[key] = value;\n        }\n        else if (value == null) {\n            continue;\n        }\n        else if (typeof merged[key] !== typeof value ||\n            Array.isArray(merged[key]) !== Array.isArray(value)) {\n            throw new Error(`field[${key}] already exists in the message chunk, but with a different type.`);\n        }\n        else if (typeof merged[key] === \"string\") {\n            merged[key] = merged[key] + value;\n        }\n        else if (!Array.isArray(merged[key]) && typeof merged[key] === \"object\") {\n            merged[key] = _mergeDicts(merged[key], value);\n        }\n        else if (key === \"tool_calls\" &&\n            isOpenAIToolCallArray(merged[key]) &&\n            isOpenAIToolCallArray(value)) {\n            for (const toolCall of value) {\n                if (merged[key]?.[toolCall.index] !== undefined) {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    merged[key] = merged[key]?.map((value, i) => {\n                        if (i !== toolCall.index) {\n                            return value;\n                        }\n                        return {\n                            ...value,\n                            ...toolCall,\n                            function: {\n                                name: toolCall.function.name ?? value.function.name,\n                                arguments: (value.function.arguments ?? \"\") +\n                                    (toolCall.function.arguments ?? \"\"),\n                            },\n                        };\n                    });\n                }\n                else {\n                    merged[key][toolCall.index] = toolCall;\n                }\n            }\n        }\n        else if (Array.isArray(merged[key])) {\n            merged[key] = merged[key].concat(value);\n        }\n        else if (merged[key] === value) {\n            continue;\n        }\n        else {\n            console.warn(`field[${key}] already exists in this message chunk and value has unsupported type.`);\n        }\n    }\n    return merged;\n}\n/**\n * Represents a chunk of a message, which can be concatenated with other\n * message chunks. It includes a method `_merge_kwargs_dict()` for merging\n * additional keyword arguments from another `BaseMessageChunk` into this\n * one. It also overrides the `__add__()` method to support concatenation\n * of `BaseMessageChunk` instances.\n */\nexport class BaseMessageChunk extends BaseMessage {\n}\n/**\n * Represents a human message in a conversation.\n */\nexport class HumanMessage extends BaseMessage {\n    static lc_name() {\n        return \"HumanMessage\";\n    }\n    _getType() {\n        return \"human\";\n    }\n}\n/**\n * Represents a chunk of a human message, which can be concatenated with\n * other human message chunks.\n */\nexport class HumanMessageChunk extends BaseMessageChunk {\n    static lc_name() {\n        return \"HumanMessageChunk\";\n    }\n    _getType() {\n        return \"human\";\n    }\n    concat(chunk) {\n        return new HumanMessageChunk({\n            content: mergeContent(this.content, chunk.content),\n            additional_kwargs: _mergeDicts(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: _mergeDicts(this.response_metadata, chunk.response_metadata),\n        });\n    }\n}\n/**\n * Represents an AI message in a conversation.\n */\nexport class AIMessage extends BaseMessage {\n    static lc_name() {\n        return \"AIMessage\";\n    }\n    _getType() {\n        return \"ai\";\n    }\n}\n/**\n * Represents a chunk of an AI message, which can be concatenated with\n * other AI message chunks.\n */\nexport class AIMessageChunk extends BaseMessageChunk {\n    static lc_name() {\n        return \"AIMessageChunk\";\n    }\n    _getType() {\n        return \"ai\";\n    }\n    concat(chunk) {\n        return new AIMessageChunk({\n            content: mergeContent(this.content, chunk.content),\n            additional_kwargs: _mergeDicts(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: _mergeDicts(this.response_metadata, chunk.response_metadata),\n        });\n    }\n}\n/**\n * Represents a system message in a conversation.\n */\nexport class SystemMessage extends BaseMessage {\n    static lc_name() {\n        return \"SystemMessage\";\n    }\n    _getType() {\n        return \"system\";\n    }\n}\n/**\n * Represents a chunk of a system message, which can be concatenated with\n * other system message chunks.\n */\nexport class SystemMessageChunk extends BaseMessageChunk {\n    static lc_name() {\n        return \"SystemMessageChunk\";\n    }\n    _getType() {\n        return \"system\";\n    }\n    concat(chunk) {\n        return new SystemMessageChunk({\n            content: mergeContent(this.content, chunk.content),\n            additional_kwargs: _mergeDicts(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: _mergeDicts(this.response_metadata, chunk.response_metadata),\n        });\n    }\n}\n/**\n * Represents a function message in a conversation.\n */\nexport class FunctionMessage extends BaseMessage {\n    static lc_name() {\n        return \"FunctionMessage\";\n    }\n    constructor(fields, \n    /** @deprecated */\n    name) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n            fields = { content: fields, name: name };\n        }\n        super(fields);\n    }\n    _getType() {\n        return \"function\";\n    }\n}\n/**\n * Represents a chunk of a function message, which can be concatenated\n * with other function message chunks.\n */\nexport class FunctionMessageChunk extends BaseMessageChunk {\n    static lc_name() {\n        return \"FunctionMessageChunk\";\n    }\n    _getType() {\n        return \"function\";\n    }\n    concat(chunk) {\n        return new FunctionMessageChunk({\n            content: mergeContent(this.content, chunk.content),\n            additional_kwargs: _mergeDicts(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: _mergeDicts(this.response_metadata, chunk.response_metadata),\n            name: this.name ?? \"\",\n        });\n    }\n}\n/**\n * Represents a tool message in a conversation.\n */\nexport class ToolMessage extends BaseMessage {\n    static lc_name() {\n        return \"ToolMessage\";\n    }\n    get lc_aliases() {\n        // exclude snake case conversion to pascal case\n        return { tool_call_id: \"tool_call_id\" };\n    }\n    constructor(fields, tool_call_id, name) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n            fields = { content: fields, name, tool_call_id: tool_call_id };\n        }\n        super(fields);\n        Object.defineProperty(this, \"tool_call_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.tool_call_id = fields.tool_call_id;\n    }\n    _getType() {\n        return \"tool\";\n    }\n    static isInstance(message) {\n        return message._getType() === \"tool\";\n    }\n}\n/**\n * Represents a chunk of a tool message, which can be concatenated\n * with other tool message chunks.\n */\nexport class ToolMessageChunk extends BaseMessageChunk {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"tool_call_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.tool_call_id = fields.tool_call_id;\n    }\n    static lc_name() {\n        return \"ToolMessageChunk\";\n    }\n    _getType() {\n        return \"tool\";\n    }\n    concat(chunk) {\n        return new ToolMessageChunk({\n            content: mergeContent(this.content, chunk.content),\n            additional_kwargs: _mergeDicts(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: _mergeDicts(this.response_metadata, chunk.response_metadata),\n            tool_call_id: this.tool_call_id,\n        });\n    }\n}\n/**\n * Represents a chat message in a conversation.\n */\nexport class ChatMessage extends BaseMessage {\n    static lc_name() {\n        return \"ChatMessage\";\n    }\n    static _chatMessageClass() {\n        return ChatMessage;\n    }\n    constructor(fields, role) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n            fields = { content: fields, role: role };\n        }\n        super(fields);\n        Object.defineProperty(this, \"role\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.role = fields.role;\n    }\n    _getType() {\n        return \"generic\";\n    }\n    static isInstance(message) {\n        return message._getType() === \"generic\";\n    }\n}\nexport function isBaseMessage(messageLike) {\n    return typeof messageLike?._getType === \"function\";\n}\nexport function isBaseMessageChunk(messageLike) {\n    return (isBaseMessage(messageLike) &&\n        typeof messageLike.concat === \"function\");\n}\nexport function coerceMessageLikeToMessage(messageLike) {\n    if (typeof messageLike === \"string\") {\n        return new HumanMessage(messageLike);\n    }\n    else if (isBaseMessage(messageLike)) {\n        return messageLike;\n    }\n    const [type, content] = messageLike;\n    if (type === \"human\" || type === \"user\") {\n        return new HumanMessage({ content });\n    }\n    else if (type === \"ai\" || type === \"assistant\") {\n        return new AIMessage({ content });\n    }\n    else if (type === \"system\") {\n        return new SystemMessage({ content });\n    }\n    else {\n        throw new Error(`Unable to coerce message from array: only human, AI, or system message coercion is currently supported.`);\n    }\n}\n/**\n * Represents a chunk of a chat message, which can be concatenated with\n * other chat message chunks.\n */\nexport class ChatMessageChunk extends BaseMessageChunk {\n    static lc_name() {\n        return \"ChatMessageChunk\";\n    }\n    constructor(fields, role) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n            fields = { content: fields, role: role };\n        }\n        super(fields);\n        Object.defineProperty(this, \"role\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.role = fields.role;\n    }\n    _getType() {\n        return \"generic\";\n    }\n    concat(chunk) {\n        return new ChatMessageChunk({\n            content: mergeContent(this.content, chunk.content),\n            additional_kwargs: _mergeDicts(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: _mergeDicts(this.response_metadata, chunk.response_metadata),\n            role: this.role,\n        });\n    }\n}\n/**\n * This function is used by memory classes to get a string representation\n * of the chat message history, based on the message content and role.\n */\nexport function getBufferString(messages, humanPrefix = \"Human\", aiPrefix = \"AI\") {\n    const string_messages = [];\n    for (const m of messages) {\n        let role;\n        if (m._getType() === \"human\") {\n            role = humanPrefix;\n        }\n        else if (m._getType() === \"ai\") {\n            role = aiPrefix;\n        }\n        else if (m._getType() === \"system\") {\n            role = \"System\";\n        }\n        else if (m._getType() === \"function\") {\n            role = \"Function\";\n        }\n        else if (m._getType() === \"tool\") {\n            role = \"Tool\";\n        }\n        else if (m._getType() === \"generic\") {\n            role = m.role;\n        }\n        else {\n            throw new Error(`Got unsupported message type: ${m._getType()}`);\n        }\n        const nameStr = m.name ? `${m.name}, ` : \"\";\n        string_messages.push(`${role}: ${nameStr}${m.content}`);\n    }\n    return string_messages.join(\"\\n\");\n}\n/**\n * Maps messages from an older format (V1) to the current `StoredMessage`\n * format. If the message is already in the `StoredMessage` format, it is\n * returned as is. Otherwise, it transforms the V1 message into a\n * `StoredMessage`. This function is important for maintaining\n * compatibility with older message formats.\n */\nfunction mapV1MessageToStoredMessage(message) {\n    // TODO: Remove this mapper when we deprecate the old message format.\n    if (message.data !== undefined) {\n        return message;\n    }\n    else {\n        const v1Message = message;\n        return {\n            type: v1Message.type,\n            data: {\n                content: v1Message.text,\n                role: v1Message.role,\n                name: undefined,\n                tool_call_id: undefined,\n            },\n        };\n    }\n}\nexport function mapStoredMessageToChatMessage(message) {\n    const storedMessage = mapV1MessageToStoredMessage(message);\n    switch (storedMessage.type) {\n        case \"human\":\n            return new HumanMessage(storedMessage.data);\n        case \"ai\":\n            return new AIMessage(storedMessage.data);\n        case \"system\":\n            return new SystemMessage(storedMessage.data);\n        case \"function\":\n            if (storedMessage.data.name === undefined) {\n                throw new Error(\"Name must be defined for function messages\");\n            }\n            return new FunctionMessage(storedMessage.data);\n        case \"tool\":\n            if (storedMessage.data.tool_call_id === undefined) {\n                throw new Error(\"Tool call ID must be defined for tool messages\");\n            }\n            return new ToolMessage(storedMessage.data);\n        case \"chat\": {\n            if (storedMessage.data.role === undefined) {\n                throw new Error(\"Role must be defined for chat messages\");\n            }\n            return new ChatMessage(storedMessage.data);\n        }\n        default:\n            throw new Error(`Got unexpected type: ${storedMessage.type}`);\n    }\n}\n/**\n * Transforms an array of `StoredMessage` instances into an array of\n * `BaseMessage` instances. It uses the `mapV1MessageToStoredMessage`\n * function to ensure all messages are in the `StoredMessage` format, then\n * creates new instances of the appropriate `BaseMessage` subclass based\n * on the type of each message. This function is used to prepare stored\n * messages for use in a chat context.\n */\nexport function mapStoredMessagesToChatMessages(messages) {\n    return messages.map(mapStoredMessageToChatMessage);\n}\n/**\n * Transforms an array of `BaseMessage` instances into an array of\n * `StoredMessage` instances. It does this by calling the `toDict` method\n * on each `BaseMessage`, which returns a `StoredMessage`. This function\n * is used to prepare chat messages for storage.\n */\nexport function mapChatMessagesToStoredMessages(messages) {\n    return messages.map((message) => message.toDict());\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}