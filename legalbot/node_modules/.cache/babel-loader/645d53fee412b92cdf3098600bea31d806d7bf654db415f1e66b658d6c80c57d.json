{"ast":null,"code":"import * as uuid from \"uuid\";\nimport { AsyncCaller } from \"./utils/async_caller.js\";\nimport { convertLangChainMessageToExample, isLangChainMessage } from \"./utils/messages.js\";\nimport { getEnvironmentVariable, getLangChainEnvVarsMetadata, getRuntimeEnvironment } from \"./utils/env.js\";\nimport { __version__ } from \"./index.js\";\nasync function mergeRuntimeEnvIntoRunCreates(runs) {\n  const runtimeEnv = await getRuntimeEnvironment();\n  const envVars = getLangChainEnvVarsMetadata();\n  return runs.map(run => {\n    const extra = run.extra ?? {};\n    const metadata = extra.metadata;\n    run.extra = {\n      ...extra,\n      runtime: {\n        ...runtimeEnv,\n        ...extra?.runtime\n      },\n      metadata: {\n        ...envVars,\n        ...(envVars.revision_id || run.revision_id ? {\n          revision_id: run.revision_id ?? envVars.revision_id\n        } : {}),\n        ...metadata\n      }\n    };\n    return run;\n  });\n}\nconst getTracingSamplingRate = () => {\n  const samplingRateStr = getEnvironmentVariable(\"LANGCHAIN_TRACING_SAMPLING_RATE\");\n  if (samplingRateStr === undefined) {\n    return undefined;\n  }\n  const samplingRate = parseFloat(samplingRateStr);\n  if (samplingRate < 0 || samplingRate > 1) {\n    throw new Error(`LANGCHAIN_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${samplingRate}`);\n  }\n  return samplingRate;\n};\n// utility functions\nconst isLocalhost = url => {\n  const strippedUrl = url.replace(\"http://\", \"\").replace(\"https://\", \"\");\n  const hostname = strippedUrl.split(\"/\")[0].split(\":\")[0];\n  return hostname === \"localhost\" || hostname === \"127.0.0.1\" || hostname === \"::1\";\n};\nconst raiseForStatus = async (response, operation) => {\n  // consume the response body to release the connection\n  // https://undici.nodejs.org/#/?id=garbage-collection\n  const body = await response.text();\n  if (!response.ok) {\n    throw new Error(`Failed to ${operation}: ${response.status} ${response.statusText} ${body}`);\n  }\n};\nasync function toArray(iterable) {\n  const result = [];\n  for await (const item of iterable) {\n    result.push(item);\n  }\n  return result;\n}\nfunction trimQuotes(str) {\n  if (str === undefined) {\n    return undefined;\n  }\n  return str.trim().replace(/^\"(.*)\"$/, \"$1\").replace(/^'(.*)'$/, \"$1\");\n}\nfunction assertUuid(str) {\n  if (!uuid.validate(str)) {\n    throw new Error(`Invalid UUID: ${str}`);\n  }\n}\nconst handle429 = async response => {\n  if (response?.status === 429) {\n    const retryAfter = parseInt(response.headers.get(\"retry-after\") ?? \"30\", 10) * 1000;\n    if (retryAfter > 0) {\n      await new Promise(resolve => setTimeout(resolve, retryAfter));\n      // Return directly after calling this check\n      return true;\n    }\n  }\n  // Fall back to existing status checks\n  return false;\n};\nexport class Queue {\n  constructor() {\n    Object.defineProperty(this, \"items\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n  }\n  get size() {\n    return this.items.length;\n  }\n  push(item) {\n    // this.items.push is synchronous with promise creation:\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise\n    return new Promise(resolve => {\n      this.items.push([item, resolve]);\n    });\n  }\n  pop(upToN) {\n    if (upToN < 1) {\n      throw new Error(\"Number of items to pop off may not be less than 1.\");\n    }\n    const popped = [];\n    while (popped.length < upToN && this.items.length) {\n      const item = this.items.shift();\n      if (item) {\n        popped.push(item);\n      } else {\n        break;\n      }\n    }\n    return [popped.map(it => it[0]), () => popped.forEach(it => it[1]())];\n  }\n}\n// 20 MB\nexport const DEFAULT_BATCH_SIZE_LIMIT_BYTES = 20971520;\nexport class Client {\n  constructor(config = {}) {\n    Object.defineProperty(this, \"apiKey\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"apiUrl\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"webUrl\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"caller\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"batchIngestCaller\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"timeout_ms\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_tenantId\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, \"hideInputs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"hideOutputs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"tracingSampleRate\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"sampledPostUuids\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new Set()\n    });\n    Object.defineProperty(this, \"autoBatchTracing\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"batchEndpointSupported\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"autoBatchQueue\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new Queue()\n    });\n    Object.defineProperty(this, \"pendingAutoBatchedRunLimit\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 100\n    });\n    Object.defineProperty(this, \"autoBatchTimeout\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"autoBatchInitialDelayMs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 250\n    });\n    Object.defineProperty(this, \"autoBatchAggregationDelayMs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 50\n    });\n    Object.defineProperty(this, \"serverInfo\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    const defaultConfig = Client.getDefaultClientConfig();\n    this.tracingSampleRate = getTracingSamplingRate();\n    this.apiUrl = trimQuotes(config.apiUrl ?? defaultConfig.apiUrl) ?? \"\";\n    this.apiKey = trimQuotes(config.apiKey ?? defaultConfig.apiKey);\n    this.webUrl = trimQuotes(config.webUrl ?? defaultConfig.webUrl);\n    this.timeout_ms = config.timeout_ms ?? 12000;\n    this.caller = new AsyncCaller(config.callerOptions ?? {});\n    this.batchIngestCaller = new AsyncCaller({\n      ...(config.callerOptions ?? {}),\n      onFailedResponseHook: handle429\n    });\n    this.hideInputs = config.hideInputs ?? defaultConfig.hideInputs;\n    this.hideOutputs = config.hideOutputs ?? defaultConfig.hideOutputs;\n    this.autoBatchTracing = config.autoBatchTracing ?? this.autoBatchTracing;\n    this.pendingAutoBatchedRunLimit = config.pendingAutoBatchedRunLimit ?? this.pendingAutoBatchedRunLimit;\n  }\n  static getDefaultClientConfig() {\n    const apiKey = getEnvironmentVariable(\"LANGCHAIN_API_KEY\");\n    const apiUrl = getEnvironmentVariable(\"LANGCHAIN_ENDPOINT\") ?? \"https://api.smith.langchain.com\";\n    const hideInputs = getEnvironmentVariable(\"LANGCHAIN_HIDE_INPUTS\") === \"true\";\n    const hideOutputs = getEnvironmentVariable(\"LANGCHAIN_HIDE_OUTPUTS\") === \"true\";\n    return {\n      apiUrl: apiUrl,\n      apiKey: apiKey,\n      webUrl: undefined,\n      hideInputs: hideInputs,\n      hideOutputs: hideOutputs\n    };\n  }\n  getHostUrl() {\n    if (this.webUrl) {\n      return this.webUrl;\n    } else if (isLocalhost(this.apiUrl)) {\n      this.webUrl = \"http://localhost\";\n      return \"http://localhost\";\n    } else if (this.apiUrl.includes(\"/api\") && !this.apiUrl.split(\".\", 1)[0].endsWith(\"api\")) {\n      this.webUrl = this.apiUrl.replace(\"/api\", \"\");\n      return this.webUrl;\n    } else if (this.apiUrl.split(\".\", 1)[0].includes(\"dev\")) {\n      this.webUrl = \"https://dev.smith.langchain.com\";\n      return \"https://dev.smith.langchain.com\";\n    } else {\n      this.webUrl = \"https://smith.langchain.com\";\n      return \"https://smith.langchain.com\";\n    }\n  }\n  get headers() {\n    const headers = {\n      \"User-Agent\": `langsmith-js/${__version__}`\n    };\n    if (this.apiKey) {\n      headers[\"x-api-key\"] = `${this.apiKey}`;\n    }\n    return headers;\n  }\n  processInputs(inputs) {\n    if (this.hideInputs === false) {\n      return inputs;\n    }\n    if (this.hideInputs === true) {\n      return {};\n    }\n    if (typeof this.hideInputs === \"function\") {\n      return this.hideInputs(inputs);\n    }\n    return inputs;\n  }\n  processOutputs(outputs) {\n    if (this.hideOutputs === false) {\n      return outputs;\n    }\n    if (this.hideOutputs === true) {\n      return {};\n    }\n    if (typeof this.hideOutputs === \"function\") {\n      return this.hideOutputs(outputs);\n    }\n    return outputs;\n  }\n  prepareRunCreateOrUpdateInputs(run) {\n    const runParams = {\n      ...run\n    };\n    if (runParams.inputs !== undefined) {\n      runParams.inputs = this.processInputs(runParams.inputs);\n    }\n    if (runParams.outputs !== undefined) {\n      runParams.outputs = this.processOutputs(runParams.outputs);\n    }\n    return runParams;\n  }\n  async _getResponse(path, queryParams) {\n    const paramsString = queryParams?.toString() ?? \"\";\n    const url = `${this.apiUrl}${path}?${paramsString}`;\n    const response = await this.caller.call(fetch, url, {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to fetch ${path}: ${response.status} ${response.statusText}`);\n    }\n    return response;\n  }\n  async _get(path, queryParams) {\n    const response = await this._getResponse(path, queryParams);\n    return response.json();\n  }\n  async *_getPaginated(path, queryParams = new URLSearchParams()) {\n    let offset = Number(queryParams.get(\"offset\")) || 0;\n    const limit = Number(queryParams.get(\"limit\")) || 100;\n    while (true) {\n      queryParams.set(\"offset\", String(offset));\n      queryParams.set(\"limit\", String(limit));\n      const url = `${this.apiUrl}${path}?${queryParams}`;\n      const response = await this.caller.call(fetch, url, {\n        method: \"GET\",\n        headers: this.headers,\n        signal: AbortSignal.timeout(this.timeout_ms)\n      });\n      if (!response.ok) {\n        throw new Error(`Failed to fetch ${path}: ${response.status} ${response.statusText}`);\n      }\n      const items = await response.json();\n      if (items.length === 0) {\n        break;\n      }\n      yield items;\n      if (items.length < limit) {\n        break;\n      }\n      offset += items.length;\n    }\n  }\n  async *_getCursorPaginatedList(path, body = null, requestMethod = \"POST\", dataKey = \"runs\") {\n    const bodyParams = body ? {\n      ...body\n    } : {};\n    while (true) {\n      const response = await this.caller.call(fetch, `${this.apiUrl}${path}`, {\n        method: requestMethod,\n        headers: {\n          ...this.headers,\n          \"Content-Type\": \"application/json\"\n        },\n        signal: AbortSignal.timeout(this.timeout_ms),\n        body: JSON.stringify(bodyParams)\n      });\n      const responseBody = await response.json();\n      if (!responseBody) {\n        break;\n      }\n      if (!responseBody[dataKey]) {\n        break;\n      }\n      yield responseBody[dataKey];\n      const cursors = responseBody.cursors;\n      if (!cursors) {\n        break;\n      }\n      if (!cursors.next) {\n        break;\n      }\n      bodyParams.cursor = cursors.next;\n    }\n  }\n  _filterForSampling(runs, patch = false) {\n    if (this.tracingSampleRate === undefined) {\n      return runs;\n    }\n    if (patch) {\n      const sampled = [];\n      for (const run of runs) {\n        if (this.sampledPostUuids.has(run.id)) {\n          sampled.push(run);\n          this.sampledPostUuids.delete(run.id);\n        }\n      }\n      return sampled;\n    } else {\n      const sampled = [];\n      for (const run of runs) {\n        if (Math.random() < this.tracingSampleRate) {\n          sampled.push(run);\n          this.sampledPostUuids.add(run.id);\n        }\n      }\n      return sampled;\n    }\n  }\n  async drainAutoBatchQueue() {\n    while (this.autoBatchQueue.size >= 0) {\n      const [batch, done] = this.autoBatchQueue.pop(this.pendingAutoBatchedRunLimit);\n      if (!batch.length) {\n        done();\n        return;\n      }\n      try {\n        await this.batchIngestRuns({\n          runCreates: batch.filter(item => item.action === \"create\").map(item => item.item),\n          runUpdates: batch.filter(item => item.action === \"update\").map(item => item.item)\n        });\n      } finally {\n        done();\n      }\n    }\n  }\n  async processRunOperation(item, immediatelyTriggerBatch) {\n    const oldTimeout = this.autoBatchTimeout;\n    clearTimeout(this.autoBatchTimeout);\n    this.autoBatchTimeout = undefined;\n    const itemPromise = this.autoBatchQueue.push(item);\n    if (immediatelyTriggerBatch || this.autoBatchQueue.size > this.pendingAutoBatchedRunLimit) {\n      await this.drainAutoBatchQueue();\n    }\n    if (this.autoBatchQueue.size > 0) {\n      this.autoBatchTimeout = setTimeout(() => {\n        this.autoBatchTimeout = undefined;\n        // This error would happen in the background and is uncatchable\n        // from the outside. So just log instead.\n        void this.drainAutoBatchQueue().catch(console.error);\n      }, oldTimeout ? this.autoBatchAggregationDelayMs : this.autoBatchInitialDelayMs);\n    }\n    return itemPromise;\n  }\n  async _getServerInfo() {\n    const response = await fetch(`${this.apiUrl}/info`, {\n      method: \"GET\",\n      headers: {\n        Accept: \"application/json\"\n      },\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      // consume the response body to release the connection\n      // https://undici.nodejs.org/#/?id=garbage-collection\n      await response.text();\n      throw new Error(\"Failed to retrieve server info.\");\n    }\n    return response.json();\n  }\n  async batchEndpointIsSupported() {\n    try {\n      this.serverInfo = await this._getServerInfo();\n    } catch (e) {\n      return false;\n    }\n    return true;\n  }\n  async createRun(run) {\n    if (!this._filterForSampling([run]).length) {\n      return;\n    }\n    const headers = {\n      ...this.headers,\n      \"Content-Type\": \"application/json\"\n    };\n    const session_name = run.project_name;\n    delete run.project_name;\n    const runCreate = this.prepareRunCreateOrUpdateInputs({\n      session_name,\n      ...run,\n      start_time: run.start_time ?? Date.now()\n    });\n    if (this.autoBatchTracing && runCreate.trace_id !== undefined && runCreate.dotted_order !== undefined) {\n      void this.processRunOperation({\n        action: \"create\",\n        item: runCreate\n      }).catch(console.error);\n      return;\n    }\n    const mergedRunCreateParams = await mergeRuntimeEnvIntoRunCreates([runCreate]);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/runs`, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify(mergedRunCreateParams[0]),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, \"create run\");\n  }\n  /**\n   * Batch ingest/upsert multiple runs in the Langsmith system.\n   * @param runs\n   */\n  async batchIngestRuns({\n    runCreates,\n    runUpdates\n  }) {\n    if (runCreates === undefined && runUpdates === undefined) {\n      return;\n    }\n    let preparedCreateParams = runCreates?.map(create => this.prepareRunCreateOrUpdateInputs(create)) ?? [];\n    let preparedUpdateParams = runUpdates?.map(update => this.prepareRunCreateOrUpdateInputs(update)) ?? [];\n    if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {\n      const createById = preparedCreateParams.reduce((params, run) => {\n        if (!run.id) {\n          return params;\n        }\n        params[run.id] = run;\n        return params;\n      }, {});\n      const standaloneUpdates = [];\n      for (const updateParam of preparedUpdateParams) {\n        if (updateParam.id !== undefined && createById[updateParam.id]) {\n          createById[updateParam.id] = {\n            ...createById[updateParam.id],\n            ...updateParam\n          };\n        } else {\n          standaloneUpdates.push(updateParam);\n        }\n      }\n      preparedCreateParams = Object.values(createById);\n      preparedUpdateParams = standaloneUpdates;\n    }\n    const rawBatch = {\n      post: this._filterForSampling(preparedCreateParams),\n      patch: this._filterForSampling(preparedUpdateParams, true)\n    };\n    if (!rawBatch.post.length && !rawBatch.patch.length) {\n      return;\n    }\n    preparedCreateParams = await mergeRuntimeEnvIntoRunCreates(preparedCreateParams);\n    if (this.batchEndpointSupported === undefined) {\n      this.batchEndpointSupported = await this.batchEndpointIsSupported();\n    }\n    if (!this.batchEndpointSupported) {\n      this.autoBatchTracing = false;\n      for (const preparedCreateParam of rawBatch.post) {\n        await this.createRun(preparedCreateParam);\n      }\n      for (const preparedUpdateParam of rawBatch.patch) {\n        if (preparedUpdateParam.id !== undefined) {\n          await this.updateRun(preparedUpdateParam.id, preparedUpdateParam);\n        }\n      }\n      return;\n    }\n    const sizeLimitBytes = this.serverInfo?.batch_ingest_config?.size_limit_bytes ?? DEFAULT_BATCH_SIZE_LIMIT_BYTES;\n    const batchChunks = {\n      post: [],\n      patch: []\n    };\n    let currentBatchSizeBytes = 0;\n    for (const k of [\"post\", \"patch\"]) {\n      const key = k;\n      const batchItems = rawBatch[key].reverse();\n      let batchItem = batchItems.pop();\n      while (batchItem !== undefined) {\n        const stringifiedBatchItem = JSON.stringify(batchItem);\n        if (currentBatchSizeBytes > 0 && currentBatchSizeBytes + stringifiedBatchItem.length > sizeLimitBytes) {\n          await this._postBatchIngestRuns(JSON.stringify(batchChunks));\n          currentBatchSizeBytes = 0;\n          batchChunks.post = [];\n          batchChunks.patch = [];\n        }\n        currentBatchSizeBytes += stringifiedBatchItem.length;\n        batchChunks[key].push(batchItem);\n        batchItem = batchItems.pop();\n      }\n    }\n    if (batchChunks.post.length > 0 || batchChunks.patch.length > 0) {\n      await this._postBatchIngestRuns(JSON.stringify(batchChunks));\n    }\n  }\n  async _postBatchIngestRuns(body) {\n    const headers = {\n      ...this.headers,\n      \"Content-Type\": \"application/json\",\n      Accept: \"application/json\"\n    };\n    const response = await this.batchIngestCaller.call(fetch, `${this.apiUrl}/runs/batch`, {\n      method: \"POST\",\n      headers,\n      body: body,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, \"batch create run\");\n  }\n  async updateRun(runId, run) {\n    assertUuid(runId);\n    if (run.inputs) {\n      run.inputs = this.processInputs(run.inputs);\n    }\n    if (run.outputs) {\n      run.outputs = this.processOutputs(run.outputs);\n    }\n    // TODO: Untangle types\n    const data = {\n      ...run,\n      id: runId\n    };\n    if (!this._filterForSampling([data], true).length) {\n      return;\n    }\n    if (this.autoBatchTracing && data.trace_id !== undefined && data.dotted_order !== undefined) {\n      if (run.end_time !== undefined && data.parent_run_id === undefined) {\n        // Trigger a batch as soon as a root trace ends and block to ensure trace finishes\n        // in serverless environments.\n        await this.processRunOperation({\n          action: \"update\",\n          item: data\n        }, true);\n        return;\n      } else {\n        void this.processRunOperation({\n          action: \"update\",\n          item: data\n        }).catch(console.error);\n      }\n      return;\n    }\n    const headers = {\n      ...this.headers,\n      \"Content-Type\": \"application/json\"\n    };\n    const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}`, {\n      method: \"PATCH\",\n      headers,\n      body: JSON.stringify(run),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, \"update run\");\n  }\n  async readRun(runId, {\n    loadChildRuns\n  } = {\n    loadChildRuns: false\n  }) {\n    assertUuid(runId);\n    let run = await this._get(`/runs/${runId}`);\n    if (loadChildRuns && run.child_run_ids) {\n      run = await this._loadChildRuns(run);\n    }\n    return run;\n  }\n  async getRunUrl({\n    runId,\n    run,\n    projectOpts\n  }) {\n    if (run !== undefined) {\n      let sessionId;\n      if (run.session_id) {\n        sessionId = run.session_id;\n      } else if (projectOpts?.projectName) {\n        sessionId = (await this.readProject({\n          projectName: projectOpts?.projectName\n        })).id;\n      } else if (projectOpts?.projectId) {\n        sessionId = projectOpts?.projectId;\n      } else {\n        const project = await this.readProject({\n          projectName: getEnvironmentVariable(\"LANGCHAIN_PROJECT\") || \"default\"\n        });\n        sessionId = project.id;\n      }\n      const tenantId = await this._getTenantId();\n      return `${this.getHostUrl()}/o/${tenantId}/projects/p/${sessionId}/r/${run.id}?poll=true`;\n    } else if (runId !== undefined) {\n      const run_ = await this.readRun(runId);\n      if (!run_.app_path) {\n        throw new Error(`Run ${runId} has no app_path`);\n      }\n      const baseUrl = this.getHostUrl();\n      return `${baseUrl}${run_.app_path}`;\n    } else {\n      throw new Error(\"Must provide either runId or run\");\n    }\n  }\n  async _loadChildRuns(run) {\n    const childRuns = await toArray(this.listRuns({\n      id: run.child_run_ids\n    }));\n    const treemap = {};\n    const runs = {};\n    // TODO: make dotted order required when the migration finishes\n    childRuns.sort((a, b) => (a?.dotted_order ?? \"\").localeCompare(b?.dotted_order ?? \"\"));\n    for (const childRun of childRuns) {\n      if (childRun.parent_run_id === null || childRun.parent_run_id === undefined) {\n        throw new Error(`Child run ${childRun.id} has no parent`);\n      }\n      if (!(childRun.parent_run_id in treemap)) {\n        treemap[childRun.parent_run_id] = [];\n      }\n      treemap[childRun.parent_run_id].push(childRun);\n      runs[childRun.id] = childRun;\n    }\n    run.child_runs = treemap[run.id] || [];\n    for (const runId in treemap) {\n      if (runId !== run.id) {\n        runs[runId].child_runs = treemap[runId];\n      }\n    }\n    return run;\n  }\n  /**\n   * List runs from the LangSmith server.\n   * @param projectId - The ID of the project to filter by.\n   * @param projectName - The name of the project to filter by.\n   * @param parentRunId - The ID of the parent run to filter by.\n   * @param traceId - The ID of the trace to filter by.\n   * @param referenceExampleId - The ID of the reference example to filter by.\n   * @param startTime - The start time to filter by.\n   * @param executionOrder - The execution order to filter by.\n   * @param runType - The run type to filter by.\n   * @param error - Indicates whether to filter by error runs.\n   * @param id - The ID of the run to filter by.\n   * @param query - The query string to filter by.\n   * @param filter - The filter string to apply to the run spans.\n   * @param traceFilter - The filter string to apply on the root run of the trace.\n   * @param limit - The maximum number of runs to retrieve.\n   * @returns {AsyncIterable<Run>} - The runs.\n   *\n   * @example\n   * // List all runs in a project\n   * const projectRuns = client.listRuns({ projectName: \"<your_project>\" });\n   *\n   * @example\n   * // List LLM and Chat runs in the last 24 hours\n   * const todaysLLMRuns = client.listRuns({\n   *   projectName: \"<your_project>\",\n   *   start_time: new Date(Date.now() - 24 * 60 * 60 * 1000),\n   *   run_type: \"llm\",\n   * });\n   *\n   * @example\n   * // List traces in a project\n   * const rootRuns = client.listRuns({\n   *   projectName: \"<your_project>\",\n   *   execution_order: 1,\n   * });\n   *\n   * @example\n   * // List runs without errors\n   * const correctRuns = client.listRuns({\n   *   projectName: \"<your_project>\",\n   *   error: false,\n   * });\n   *\n   * @example\n   * // List runs by run ID\n   * const runIds = [\n   *   \"a36092d2-4ad5-4fb4-9c0d-0dba9a2ed836\",\n   *   \"9398e6be-964f-4aa4-8ae9-ad78cd4b7074\",\n   * ];\n   * const selectedRuns = client.listRuns({ run_ids: runIds });\n   *\n   * @example\n   * // List all \"chain\" type runs that took more than 10 seconds and had `total_tokens` greater than 5000\n   * const chainRuns = client.listRuns({\n   *   projectName: \"<your_project>\",\n   *   filter: 'and(eq(run_type, \"chain\"), gt(latency, 10), gt(total_tokens, 5000))',\n   * });\n   *\n   * @example\n   * // List all runs called \"extractor\" whose root of the trace was assigned feedback \"user_score\" score of 1\n   * const goodExtractorRuns = client.listRuns({\n   *   projectName: \"<your_project>\",\n   *   filter: 'eq(name, \"extractor\")',\n   *   traceFilter: 'and(eq(feedback_key, \"user_score\"), eq(feedback_score, 1))',\n   * });\n   *\n   * @example\n   * // List all runs that started after a specific timestamp and either have \"error\" not equal to null or a \"Correctness\" feedback score equal to 0\n   * const complexRuns = client.listRuns({\n   *   projectName: \"<your_project>\",\n   *   filter: 'and(gt(start_time, \"2023-07-15T12:34:56Z\"), or(neq(error, null), and(eq(feedback_key, \"Correctness\"), eq(feedback_score, 0.0))))',\n   * });\n   *\n   * @example\n   * // List all runs where `tags` include \"experimental\" or \"beta\" and `latency` is greater than 2 seconds\n   * const taggedRuns = client.listRuns({\n   *   projectName: \"<your_project>\",\n   *   filter: 'and(or(has(tags, \"experimental\"), has(tags, \"beta\")), gt(latency, 2))',\n   * });\n   */\n  async *listRuns(props) {\n    const {\n      projectId,\n      projectName,\n      parentRunId,\n      traceId,\n      referenceExampleId,\n      startTime,\n      executionOrder,\n      runType,\n      error,\n      id,\n      query,\n      filter,\n      traceFilter,\n      treeFilter,\n      limit\n    } = props;\n    let projectIds = [];\n    if (projectId) {\n      projectIds = Array.isArray(projectId) ? projectId : [projectId];\n    }\n    if (projectName) {\n      const projectNames = Array.isArray(projectName) ? projectName : [projectName];\n      const projectIds_ = await Promise.all(projectNames.map(name => this.readProject({\n        projectName: name\n      }).then(project => project.id)));\n      projectIds.push(...projectIds_);\n    }\n    const body = {\n      session: projectIds.length ? projectIds : null,\n      run_type: runType,\n      reference_example: referenceExampleId,\n      query,\n      filter,\n      trace_filter: traceFilter,\n      tree_filter: treeFilter,\n      execution_order: executionOrder,\n      parent_run: parentRunId,\n      start_time: startTime ? startTime.toISOString() : null,\n      error,\n      id,\n      limit,\n      trace: traceId\n    };\n    for await (const runs of this._getCursorPaginatedList(\"/runs/query\", body)) {\n      yield* runs;\n    }\n  }\n  async shareRun(runId, {\n    shareId\n  } = {}) {\n    const data = {\n      run_id: runId,\n      share_token: shareId || uuid.v4()\n    };\n    assertUuid(runId);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n      method: \"PUT\",\n      headers: this.headers,\n      body: JSON.stringify(data),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const result = await response.json();\n    if (result === null || !(\"share_token\" in result)) {\n      throw new Error(\"Invalid response from server\");\n    }\n    return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n  }\n  async unshareRun(runId) {\n    assertUuid(runId);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, \"unshare run\");\n  }\n  async readRunSharedLink(runId) {\n    assertUuid(runId);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const result = await response.json();\n    if (result === null || !(\"share_token\" in result)) {\n      return undefined;\n    }\n    return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n  }\n  async listSharedRuns(shareToken, {\n    runIds\n  } = {}) {\n    const queryParams = new URLSearchParams({\n      share_token: shareToken\n    });\n    if (runIds !== undefined) {\n      for (const runId of runIds) {\n        queryParams.append(\"id\", runId);\n      }\n    }\n    assertUuid(shareToken);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/public/${shareToken}/runs${queryParams}`, {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const runs = await response.json();\n    return runs;\n  }\n  async readDatasetSharedSchema(datasetId, datasetName) {\n    if (!datasetId && !datasetName) {\n      throw new Error(\"Either datasetId or datasetName must be given\");\n    }\n    if (!datasetId) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId = dataset.id;\n    }\n    assertUuid(datasetId);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const shareSchema = await response.json();\n    shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n    return shareSchema;\n  }\n  async shareDataset(datasetId, datasetName) {\n    if (!datasetId && !datasetName) {\n      throw new Error(\"Either datasetId or datasetName must be given\");\n    }\n    if (!datasetId) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId = dataset.id;\n    }\n    const data = {\n      dataset_id: datasetId\n    };\n    assertUuid(datasetId);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n      method: \"PUT\",\n      headers: this.headers,\n      body: JSON.stringify(data),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const shareSchema = await response.json();\n    shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n    return shareSchema;\n  }\n  async unshareDataset(datasetId) {\n    assertUuid(datasetId);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, \"unshare dataset\");\n  }\n  async readSharedDataset(shareToken) {\n    assertUuid(shareToken);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/public/${shareToken}/datasets`, {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const dataset = await response.json();\n    return dataset;\n  }\n  async createProject({\n    projectName,\n    description = null,\n    metadata = null,\n    upsert = false,\n    projectExtra = null,\n    referenceDatasetId = null\n  }) {\n    const upsert_ = upsert ? `?upsert=true` : \"\";\n    const endpoint = `${this.apiUrl}/sessions${upsert_}`;\n    const extra = projectExtra || {};\n    if (metadata) {\n      extra[\"metadata\"] = metadata;\n    }\n    const body = {\n      name: projectName,\n      extra,\n      description\n    };\n    if (referenceDatasetId !== null) {\n      body[\"reference_dataset_id\"] = referenceDatasetId;\n    }\n    const response = await this.caller.call(fetch, endpoint, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(body),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const result = await response.json();\n    if (!response.ok) {\n      throw new Error(`Failed to create session ${projectName}: ${response.status} ${response.statusText}`);\n    }\n    return result;\n  }\n  async updateProject(projectId, {\n    name = null,\n    description = null,\n    metadata = null,\n    projectExtra = null,\n    endTime = null\n  }) {\n    const endpoint = `${this.apiUrl}/sessions/${projectId}`;\n    let extra = projectExtra;\n    if (metadata) {\n      extra = {\n        ...(extra || {}),\n        metadata\n      };\n    }\n    const body = {\n      name,\n      extra,\n      description,\n      end_time: endTime ? new Date(endTime).toISOString() : null\n    };\n    const response = await this.caller.call(fetch, endpoint, {\n      method: \"PATCH\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(body),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const result = await response.json();\n    if (!response.ok) {\n      throw new Error(`Failed to update project ${projectId}: ${response.status} ${response.statusText}`);\n    }\n    return result;\n  }\n  async hasProject({\n    projectId,\n    projectName\n  }) {\n    // TODO: Add a head request\n    let path = \"/sessions\";\n    const params = new URLSearchParams();\n    if (projectId !== undefined && projectName !== undefined) {\n      throw new Error(\"Must provide either projectName or projectId, not both\");\n    } else if (projectId !== undefined) {\n      assertUuid(projectId);\n      path += `/${projectId}`;\n    } else if (projectName !== undefined) {\n      params.append(\"name\", projectName);\n    } else {\n      throw new Error(\"Must provide projectName or projectId\");\n    }\n    const response = await this.caller.call(fetch, `${this.apiUrl}${path}?${params}`, {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    // consume the response body to release the connection\n    // https://undici.nodejs.org/#/?id=garbage-collection\n    try {\n      const result = await response.json();\n      if (!response.ok) {\n        return false;\n      }\n      // If it's OK and we're querying by name, need to check the list is not empty\n      if (Array.isArray(result)) {\n        return result.length > 0;\n      }\n      // projectId querying\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  async readProject({\n    projectId,\n    projectName,\n    includeStats\n  }) {\n    let path = \"/sessions\";\n    const params = new URLSearchParams();\n    if (projectId !== undefined && projectName !== undefined) {\n      throw new Error(\"Must provide either projectName or projectId, not both\");\n    } else if (projectId !== undefined) {\n      assertUuid(projectId);\n      path += `/${projectId}`;\n    } else if (projectName !== undefined) {\n      params.append(\"name\", projectName);\n    } else {\n      throw new Error(\"Must provide projectName or projectId\");\n    }\n    if (includeStats !== undefined) {\n      params.append(\"include_stats\", includeStats.toString());\n    }\n    const response = await this._get(path, params);\n    let result;\n    if (Array.isArray(response)) {\n      if (response.length === 0) {\n        throw new Error(`Project[id=${projectId}, name=${projectName}] not found`);\n      }\n      result = response[0];\n    } else {\n      result = response;\n    }\n    return result;\n  }\n  async _getTenantId() {\n    if (this._tenantId !== null) {\n      return this._tenantId;\n    }\n    const queryParams = new URLSearchParams({\n      limit: \"1\"\n    });\n    for await (const projects of this._getPaginated(\"/sessions\", queryParams)) {\n      this._tenantId = projects[0].tenant_id;\n      return projects[0].tenant_id;\n    }\n    throw new Error(\"No projects found to resolve tenant.\");\n  }\n  async *listProjects({\n    projectIds,\n    name,\n    nameContains,\n    referenceDatasetId,\n    referenceDatasetName,\n    referenceFree\n  } = {}) {\n    const params = new URLSearchParams();\n    if (projectIds !== undefined) {\n      for (const projectId of projectIds) {\n        params.append(\"id\", projectId);\n      }\n    }\n    if (name !== undefined) {\n      params.append(\"name\", name);\n    }\n    if (nameContains !== undefined) {\n      params.append(\"name_contains\", nameContains);\n    }\n    if (referenceDatasetId !== undefined) {\n      params.append(\"reference_dataset\", referenceDatasetId);\n    } else if (referenceDatasetName !== undefined) {\n      const dataset = await this.readDataset({\n        datasetName: referenceDatasetName\n      });\n      params.append(\"reference_dataset\", dataset.id);\n    }\n    if (referenceFree !== undefined) {\n      params.append(\"reference_free\", referenceFree.toString());\n    }\n    for await (const projects of this._getPaginated(\"/sessions\", params)) {\n      yield* projects;\n    }\n  }\n  async deleteProject({\n    projectId,\n    projectName\n  }) {\n    let projectId_;\n    if (projectId === undefined && projectName === undefined) {\n      throw new Error(\"Must provide projectName or projectId\");\n    } else if (projectId !== undefined && projectName !== undefined) {\n      throw new Error(\"Must provide either projectName or projectId, not both\");\n    } else if (projectId === undefined) {\n      projectId_ = (await this.readProject({\n        projectName\n      })).id;\n    } else {\n      projectId_ = projectId;\n    }\n    assertUuid(projectId_);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/sessions/${projectId_}`, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, `delete session ${projectId_} (${projectName})`);\n  }\n  async uploadCsv({\n    csvFile,\n    fileName,\n    inputKeys,\n    outputKeys,\n    description,\n    dataType,\n    name\n  }) {\n    const url = `${this.apiUrl}/datasets/upload`;\n    const formData = new FormData();\n    formData.append(\"file\", csvFile, fileName);\n    inputKeys.forEach(key => {\n      formData.append(\"input_keys\", key);\n    });\n    outputKeys.forEach(key => {\n      formData.append(\"output_keys\", key);\n    });\n    if (description) {\n      formData.append(\"description\", description);\n    }\n    if (dataType) {\n      formData.append(\"data_type\", dataType);\n    }\n    if (name) {\n      formData.append(\"name\", name);\n    }\n    const response = await this.caller.call(fetch, url, {\n      method: \"POST\",\n      headers: this.headers,\n      body: formData,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      const result = await response.json();\n      if (result.detail && result.detail.includes(\"already exists\")) {\n        throw new Error(`Dataset ${fileName} already exists`);\n      }\n      throw new Error(`Failed to upload CSV: ${response.status} ${response.statusText}`);\n    }\n    const result = await response.json();\n    return result;\n  }\n  async createDataset(name, {\n    description,\n    dataType\n  } = {}) {\n    const body = {\n      name,\n      description\n    };\n    if (dataType) {\n      body.data_type = dataType;\n    }\n    const response = await this.caller.call(fetch, `${this.apiUrl}/datasets`, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(body),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      const result = await response.json();\n      if (result.detail && result.detail.includes(\"already exists\")) {\n        throw new Error(`Dataset ${name} already exists`);\n      }\n      throw new Error(`Failed to create dataset ${response.status} ${response.statusText}`);\n    }\n    const result = await response.json();\n    return result;\n  }\n  async readDataset({\n    datasetId,\n    datasetName\n  }) {\n    let path = \"/datasets\";\n    // limit to 1 result\n    const params = new URLSearchParams({\n      limit: \"1\"\n    });\n    if (datasetId !== undefined && datasetName !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetId !== undefined) {\n      assertUuid(datasetId);\n      path += `/${datasetId}`;\n    } else if (datasetName !== undefined) {\n      params.append(\"name\", datasetName);\n    } else {\n      throw new Error(\"Must provide datasetName or datasetId\");\n    }\n    const response = await this._get(path, params);\n    let result;\n    if (Array.isArray(response)) {\n      if (response.length === 0) {\n        throw new Error(`Dataset[id=${datasetId}, name=${datasetName}] not found`);\n      }\n      result = response[0];\n    } else {\n      result = response;\n    }\n    return result;\n  }\n  async diffDatasetVersions({\n    datasetId,\n    datasetName,\n    fromVersion,\n    toVersion\n  }) {\n    let datasetId_ = datasetId;\n    if (datasetId_ === undefined && datasetName === undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId\");\n    } else if (datasetId_ !== undefined && datasetName !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetId_ === undefined) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId_ = dataset.id;\n    }\n    const urlParams = new URLSearchParams({\n      from_version: typeof fromVersion === \"string\" ? fromVersion : fromVersion.toISOString(),\n      to_version: typeof toVersion === \"string\" ? toVersion : toVersion.toISOString()\n    });\n    const response = await this._get(`/datasets/${datasetId_}/versions/diff`, urlParams);\n    return response;\n  }\n  async readDatasetOpenaiFinetuning({\n    datasetId,\n    datasetName\n  }) {\n    const path = \"/datasets\";\n    if (datasetId !== undefined) {\n      // do nothing\n    } else if (datasetName !== undefined) {\n      datasetId = (await this.readDataset({\n        datasetName\n      })).id;\n    } else {\n      throw new Error(\"Must provide datasetName or datasetId\");\n    }\n    const response = await this._getResponse(`${path}/${datasetId}/openai_ft`);\n    const datasetText = await response.text();\n    const dataset = datasetText.trim().split(\"\\n\").map(line => JSON.parse(line));\n    return dataset;\n  }\n  async *listDatasets({\n    limit = 100,\n    offset = 0,\n    datasetIds,\n    datasetName,\n    datasetNameContains\n  } = {}) {\n    const path = \"/datasets\";\n    const params = new URLSearchParams({\n      limit: limit.toString(),\n      offset: offset.toString()\n    });\n    if (datasetIds !== undefined) {\n      for (const id_ of datasetIds) {\n        params.append(\"id\", id_);\n      }\n    }\n    if (datasetName !== undefined) {\n      params.append(\"name\", datasetName);\n    }\n    if (datasetNameContains !== undefined) {\n      params.append(\"name_contains\", datasetNameContains);\n    }\n    for await (const datasets of this._getPaginated(path, params)) {\n      yield* datasets;\n    }\n  }\n  async deleteDataset({\n    datasetId,\n    datasetName\n  }) {\n    let path = \"/datasets\";\n    let datasetId_ = datasetId;\n    if (datasetId !== undefined && datasetName !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetName !== undefined) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId_ = dataset.id;\n    }\n    if (datasetId_ !== undefined) {\n      assertUuid(datasetId_);\n      path += `/${datasetId_}`;\n    } else {\n      throw new Error(\"Must provide datasetName or datasetId\");\n    }\n    const response = await this.caller.call(fetch, this.apiUrl + path, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n    }\n    await response.json();\n  }\n  async createExample(inputs, outputs, {\n    datasetId,\n    datasetName,\n    createdAt,\n    exampleId\n  }) {\n    let datasetId_ = datasetId;\n    if (datasetId_ === undefined && datasetName === undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId\");\n    } else if (datasetId_ !== undefined && datasetName !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetId_ === undefined) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId_ = dataset.id;\n    }\n    const createdAt_ = createdAt || new Date();\n    const data = {\n      dataset_id: datasetId_,\n      inputs,\n      outputs,\n      created_at: createdAt_?.toISOString(),\n      id: exampleId\n    };\n    const response = await this.caller.call(fetch, `${this.apiUrl}/examples`, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(data),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to create example: ${response.status} ${response.statusText}`);\n    }\n    const result = await response.json();\n    return result;\n  }\n  async createExamples(props) {\n    const {\n      inputs,\n      outputs,\n      sourceRunIds,\n      exampleIds,\n      datasetId,\n      datasetName\n    } = props;\n    let datasetId_ = datasetId;\n    if (datasetId_ === undefined && datasetName === undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId\");\n    } else if (datasetId_ !== undefined && datasetName !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetId_ === undefined) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId_ = dataset.id;\n    }\n    const formattedExamples = inputs.map((input, idx) => {\n      return {\n        dataset_id: datasetId_,\n        inputs: input,\n        outputs: outputs ? outputs[idx] : undefined,\n        id: exampleIds ? exampleIds[idx] : undefined,\n        source_run_id: sourceRunIds ? sourceRunIds[idx] : undefined\n      };\n    });\n    const response = await this.caller.call(fetch, `${this.apiUrl}/examples/bulk`, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(formattedExamples),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to create examples: ${response.status} ${response.statusText}`);\n    }\n    const result = await response.json();\n    return result;\n  }\n  async createLLMExample(input, generation, options) {\n    return this.createExample({\n      input\n    }, {\n      output: generation\n    }, options);\n  }\n  async createChatExample(input, generations, options) {\n    const finalInput = input.map(message => {\n      if (isLangChainMessage(message)) {\n        return convertLangChainMessageToExample(message);\n      }\n      return message;\n    });\n    const finalOutput = isLangChainMessage(generations) ? convertLangChainMessageToExample(generations) : generations;\n    return this.createExample({\n      input: finalInput\n    }, {\n      output: finalOutput\n    }, options);\n  }\n  async readExample(exampleId) {\n    assertUuid(exampleId);\n    const path = `/examples/${exampleId}`;\n    return await this._get(path);\n  }\n  async *listExamples({\n    datasetId,\n    datasetName,\n    exampleIds,\n    asOf,\n    inlineS3Urls\n  } = {}) {\n    let datasetId_;\n    if (datasetId !== undefined && datasetName !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetId !== undefined) {\n      datasetId_ = datasetId;\n    } else if (datasetName !== undefined) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId_ = dataset.id;\n    } else {\n      throw new Error(\"Must provide a datasetName or datasetId\");\n    }\n    const params = new URLSearchParams({\n      dataset: datasetId_\n    });\n    const dataset_version = asOf ? typeof asOf === \"string\" ? asOf : asOf?.toISOString() : undefined;\n    if (dataset_version) {\n      params.append(\"as_of\", dataset_version);\n    }\n    const inlineS3Urls_ = inlineS3Urls ?? true;\n    params.append(\"inline_s3_urls\", inlineS3Urls_.toString());\n    if (exampleIds !== undefined) {\n      for (const id_ of exampleIds) {\n        params.append(\"id\", id_);\n      }\n    }\n    for await (const examples of this._getPaginated(\"/examples\", params)) {\n      yield* examples;\n    }\n  }\n  async deleteExample(exampleId) {\n    assertUuid(exampleId);\n    const path = `/examples/${exampleId}`;\n    const response = await this.caller.call(fetch, this.apiUrl + path, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n    }\n    await response.json();\n  }\n  async updateExample(exampleId, update) {\n    assertUuid(exampleId);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/examples/${exampleId}`, {\n      method: \"PATCH\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(update),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to update example ${exampleId}: ${response.status} ${response.statusText}`);\n    }\n    const result = await response.json();\n    return result;\n  }\n  async evaluateRun(run, evaluator, {\n    sourceInfo,\n    loadChildRuns,\n    referenceExample\n  } = {\n    loadChildRuns: false\n  }) {\n    let run_;\n    if (typeof run === \"string\") {\n      run_ = await this.readRun(run, {\n        loadChildRuns\n      });\n    } else if (typeof run === \"object\" && \"id\" in run) {\n      run_ = run;\n    } else {\n      throw new Error(`Invalid run type: ${typeof run}`);\n    }\n    if (run_.reference_example_id !== null && run_.reference_example_id !== undefined) {\n      referenceExample = await this.readExample(run_.reference_example_id);\n    }\n    const feedbackResult = await evaluator.evaluateRun(run_, referenceExample);\n    let sourceInfo_ = sourceInfo ?? {};\n    if (feedbackResult.evaluatorInfo) {\n      sourceInfo_ = {\n        ...sourceInfo_,\n        ...feedbackResult.evaluatorInfo\n      };\n    }\n    const runId = feedbackResult.targetRunId ?? run_.id;\n    return await this.createFeedback(runId, feedbackResult.key, {\n      score: feedbackResult?.score,\n      value: feedbackResult?.value,\n      comment: feedbackResult?.comment,\n      correction: feedbackResult?.correction,\n      sourceInfo: sourceInfo_,\n      feedbackSourceType: \"model\",\n      sourceRunId: feedbackResult?.sourceRunId\n    });\n  }\n  async createFeedback(runId, key, {\n    score,\n    value,\n    correction,\n    comment,\n    sourceInfo,\n    feedbackSourceType = \"api\",\n    sourceRunId,\n    feedbackId,\n    feedbackConfig\n  }) {\n    const feedback_source = {\n      type: feedbackSourceType ?? \"api\",\n      metadata: sourceInfo ?? {}\n    };\n    if (sourceRunId !== undefined && feedback_source?.metadata !== undefined && !feedback_source.metadata[\"__run\"]) {\n      feedback_source.metadata[\"__run\"] = {\n        run_id: sourceRunId\n      };\n    }\n    if (feedback_source?.metadata !== undefined && feedback_source.metadata[\"__run\"]?.run_id !== undefined) {\n      assertUuid(feedback_source.metadata[\"__run\"].run_id);\n    }\n    const feedback = {\n      id: feedbackId ?? uuid.v4(),\n      run_id: runId,\n      key,\n      score,\n      value,\n      correction,\n      comment,\n      feedback_source: feedback_source,\n      feedbackConfig\n    };\n    const url = `${this.apiUrl}/feedback`;\n    const response = await this.caller.call(fetch, url, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(feedback),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, \"create feedback\");\n    return feedback;\n  }\n  async updateFeedback(feedbackId, {\n    score,\n    value,\n    correction,\n    comment\n  }) {\n    const feedbackUpdate = {};\n    if (score !== undefined && score !== null) {\n      feedbackUpdate[\"score\"] = score;\n    }\n    if (value !== undefined && value !== null) {\n      feedbackUpdate[\"value\"] = value;\n    }\n    if (correction !== undefined && correction !== null) {\n      feedbackUpdate[\"correction\"] = correction;\n    }\n    if (comment !== undefined && comment !== null) {\n      feedbackUpdate[\"comment\"] = comment;\n    }\n    assertUuid(feedbackId);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/feedback/${feedbackId}`, {\n      method: \"PATCH\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(feedbackUpdate),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, \"update feedback\");\n  }\n  async readFeedback(feedbackId) {\n    assertUuid(feedbackId);\n    const path = `/feedback/${feedbackId}`;\n    const response = await this._get(path);\n    return response;\n  }\n  async deleteFeedback(feedbackId) {\n    assertUuid(feedbackId);\n    const path = `/feedback/${feedbackId}`;\n    const response = await this.caller.call(fetch, this.apiUrl + path, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n    }\n    await response.json();\n  }\n  async *listFeedback({\n    runIds,\n    feedbackKeys,\n    feedbackSourceTypes\n  } = {}) {\n    const queryParams = new URLSearchParams();\n    if (runIds) {\n      queryParams.append(\"run\", runIds.join(\",\"));\n    }\n    if (feedbackKeys) {\n      for (const key of feedbackKeys) {\n        queryParams.append(\"key\", key);\n      }\n    }\n    if (feedbackSourceTypes) {\n      for (const type of feedbackSourceTypes) {\n        queryParams.append(\"source\", type);\n      }\n    }\n    for await (const feedbacks of this._getPaginated(\"/feedback\", queryParams)) {\n      yield* feedbacks;\n    }\n  }\n  /**\n   * Creates a presigned feedback token and URL.\n   *\n   * The token can be used to authorize feedback metrics without\n   * needing an API key. This is useful for giving browser-based\n   * applications the ability to submit feedback without needing\n   * to expose an API key.\n   *\n   * @param runId - The ID of the run.\n   * @param feedbackKey - The feedback key.\n   * @param options - Additional options for the token.\n   * @param options.expiration - The expiration time for the token.\n   *\n   * @returns A promise that resolves to a FeedbackIngestToken.\n   */\n  async createPresignedFeedbackToken(runId, feedbackKey, {\n    expiration,\n    feedbackConfig\n  } = {}) {\n    const body = {\n      run_id: runId,\n      feedback_key: feedbackKey,\n      feedback_config: feedbackConfig\n    };\n    if (expiration) {\n      if (typeof expiration === \"string\") {\n        body[\"expires_at\"] = expiration;\n      } else if (expiration?.hours || expiration?.minutes || expiration?.days) {\n        body[\"expires_in\"] = expiration;\n      }\n    } else {\n      body[\"expires_in\"] = {\n        hours: 3\n      };\n    }\n    const response = await this.caller.call(fetch, `${this.apiUrl}/feedback/tokens`, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(body),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const result = await response.json();\n    return result;\n  }\n  /**\n   * Retrieves a list of presigned feedback tokens for a given run ID.\n   * @param runId The ID of the run.\n   * @returns An async iterable of FeedbackIngestToken objects.\n   */\n  async *listPresignedFeedbackTokens(runId) {\n    assertUuid(runId);\n    const params = new URLSearchParams({\n      run_id: runId\n    });\n    for await (const tokens of this._getPaginated(\"/feedback/tokens\", params)) {\n      yield* tokens;\n    }\n  }\n}","map":{"version":3,"names":["uuid","AsyncCaller","convertLangChainMessageToExample","isLangChainMessage","getEnvironmentVariable","getLangChainEnvVarsMetadata","getRuntimeEnvironment","__version__","mergeRuntimeEnvIntoRunCreates","runs","runtimeEnv","envVars","map","run","extra","metadata","runtime","revision_id","getTracingSamplingRate","samplingRateStr","undefined","samplingRate","parseFloat","Error","isLocalhost","url","strippedUrl","replace","hostname","split","raiseForStatus","response","operation","body","text","ok","status","statusText","toArray","iterable","result","item","push","trimQuotes","str","trim","assertUuid","validate","handle429","retryAfter","parseInt","headers","get","Promise","resolve","setTimeout","Queue","constructor","Object","defineProperty","enumerable","configurable","writable","value","size","items","length","pop","upToN","popped","shift","it","forEach","DEFAULT_BATCH_SIZE_LIMIT_BYTES","Client","config","Set","defaultConfig","getDefaultClientConfig","tracingSampleRate","apiUrl","apiKey","webUrl","timeout_ms","caller","callerOptions","batchIngestCaller","onFailedResponseHook","hideInputs","hideOutputs","autoBatchTracing","pendingAutoBatchedRunLimit","getHostUrl","includes","endsWith","processInputs","inputs","processOutputs","outputs","prepareRunCreateOrUpdateInputs","runParams","_getResponse","path","queryParams","paramsString","toString","call","fetch","method","signal","AbortSignal","timeout","_get","json","_getPaginated","URLSearchParams","offset","Number","limit","set","String","_getCursorPaginatedList","requestMethod","dataKey","bodyParams","JSON","stringify","responseBody","cursors","next","cursor","_filterForSampling","patch","sampled","sampledPostUuids","has","id","delete","Math","random","add","drainAutoBatchQueue","autoBatchQueue","batch","done","batchIngestRuns","runCreates","filter","action","runUpdates","processRunOperation","immediatelyTriggerBatch","oldTimeout","autoBatchTimeout","clearTimeout","itemPromise","catch","console","error","autoBatchAggregationDelayMs","autoBatchInitialDelayMs","_getServerInfo","Accept","batchEndpointIsSupported","serverInfo","e","createRun","session_name","project_name","runCreate","start_time","Date","now","trace_id","dotted_order","mergedRunCreateParams","preparedCreateParams","create","preparedUpdateParams","update","createById","reduce","params","standaloneUpdates","updateParam","values","rawBatch","post","batchEndpointSupported","preparedCreateParam","preparedUpdateParam","updateRun","sizeLimitBytes","batch_ingest_config","size_limit_bytes","batchChunks","currentBatchSizeBytes","k","key","batchItems","reverse","batchItem","stringifiedBatchItem","_postBatchIngestRuns","runId","data","end_time","parent_run_id","readRun","loadChildRuns","child_run_ids","_loadChildRuns","getRunUrl","projectOpts","sessionId","session_id","projectName","readProject","projectId","project","tenantId","_getTenantId","run_","app_path","baseUrl","childRuns","listRuns","treemap","sort","a","b","localeCompare","childRun","child_runs","props","parentRunId","traceId","referenceExampleId","startTime","executionOrder","runType","query","traceFilter","treeFilter","projectIds","Array","isArray","projectNames","projectIds_","all","name","then","session","run_type","reference_example","trace_filter","tree_filter","execution_order","parent_run","toISOString","trace","shareRun","shareId","run_id","share_token","v4","unshareRun","readRunSharedLink","listSharedRuns","shareToken","runIds","append","readDatasetSharedSchema","datasetId","datasetName","dataset","readDataset","shareSchema","shareDataset","dataset_id","unshareDataset","readSharedDataset","createProject","description","upsert","projectExtra","referenceDatasetId","upsert_","endpoint","updateProject","endTime","hasProject","includeStats","_tenantId","projects","tenant_id","listProjects","nameContains","referenceDatasetName","referenceFree","deleteProject","projectId_","uploadCsv","csvFile","fileName","inputKeys","outputKeys","dataType","formData","FormData","detail","createDataset","data_type","diffDatasetVersions","fromVersion","toVersion","datasetId_","urlParams","from_version","to_version","readDatasetOpenaiFinetuning","datasetText","line","parse","listDatasets","datasetIds","datasetNameContains","id_","datasets","deleteDataset","createExample","createdAt","exampleId","createdAt_","created_at","createExamples","sourceRunIds","exampleIds","formattedExamples","input","idx","source_run_id","createLLMExample","generation","options","output","createChatExample","generations","finalInput","message","finalOutput","readExample","listExamples","asOf","inlineS3Urls","dataset_version","inlineS3Urls_","examples","deleteExample","updateExample","evaluateRun","evaluator","sourceInfo","referenceExample","reference_example_id","feedbackResult","sourceInfo_","evaluatorInfo","targetRunId","createFeedback","score","comment","correction","feedbackSourceType","sourceRunId","feedbackId","feedbackConfig","feedback_source","type","feedback","updateFeedback","feedbackUpdate","readFeedback","deleteFeedback","listFeedback","feedbackKeys","feedbackSourceTypes","join","feedbacks","createPresignedFeedbackToken","feedbackKey","expiration","feedback_key","feedback_config","hours","minutes","days","listPresignedFeedbackTokens","tokens"],"sources":["/home/nikhil/legalbot/legalbot/node_modules/langsmith/dist/client.js"],"sourcesContent":["import * as uuid from \"uuid\";\nimport { AsyncCaller } from \"./utils/async_caller.js\";\nimport { convertLangChainMessageToExample, isLangChainMessage, } from \"./utils/messages.js\";\nimport { getEnvironmentVariable, getLangChainEnvVarsMetadata, getRuntimeEnvironment, } from \"./utils/env.js\";\nimport { __version__ } from \"./index.js\";\nasync function mergeRuntimeEnvIntoRunCreates(runs) {\n    const runtimeEnv = await getRuntimeEnvironment();\n    const envVars = getLangChainEnvVarsMetadata();\n    return runs.map((run) => {\n        const extra = run.extra ?? {};\n        const metadata = extra.metadata;\n        run.extra = {\n            ...extra,\n            runtime: {\n                ...runtimeEnv,\n                ...extra?.runtime,\n            },\n            metadata: {\n                ...envVars,\n                ...(envVars.revision_id || run.revision_id\n                    ? { revision_id: run.revision_id ?? envVars.revision_id }\n                    : {}),\n                ...metadata,\n            },\n        };\n        return run;\n    });\n}\nconst getTracingSamplingRate = () => {\n    const samplingRateStr = getEnvironmentVariable(\"LANGCHAIN_TRACING_SAMPLING_RATE\");\n    if (samplingRateStr === undefined) {\n        return undefined;\n    }\n    const samplingRate = parseFloat(samplingRateStr);\n    if (samplingRate < 0 || samplingRate > 1) {\n        throw new Error(`LANGCHAIN_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${samplingRate}`);\n    }\n    return samplingRate;\n};\n// utility functions\nconst isLocalhost = (url) => {\n    const strippedUrl = url.replace(\"http://\", \"\").replace(\"https://\", \"\");\n    const hostname = strippedUrl.split(\"/\")[0].split(\":\")[0];\n    return (hostname === \"localhost\" || hostname === \"127.0.0.1\" || hostname === \"::1\");\n};\nconst raiseForStatus = async (response, operation) => {\n    // consume the response body to release the connection\n    // https://undici.nodejs.org/#/?id=garbage-collection\n    const body = await response.text();\n    if (!response.ok) {\n        throw new Error(`Failed to ${operation}: ${response.status} ${response.statusText} ${body}`);\n    }\n};\nasync function toArray(iterable) {\n    const result = [];\n    for await (const item of iterable) {\n        result.push(item);\n    }\n    return result;\n}\nfunction trimQuotes(str) {\n    if (str === undefined) {\n        return undefined;\n    }\n    return str\n        .trim()\n        .replace(/^\"(.*)\"$/, \"$1\")\n        .replace(/^'(.*)'$/, \"$1\");\n}\nfunction assertUuid(str) {\n    if (!uuid.validate(str)) {\n        throw new Error(`Invalid UUID: ${str}`);\n    }\n}\nconst handle429 = async (response) => {\n    if (response?.status === 429) {\n        const retryAfter = parseInt(response.headers.get(\"retry-after\") ?? \"30\", 10) * 1000;\n        if (retryAfter > 0) {\n            await new Promise((resolve) => setTimeout(resolve, retryAfter));\n            // Return directly after calling this check\n            return true;\n        }\n    }\n    // Fall back to existing status checks\n    return false;\n};\nexport class Queue {\n    constructor() {\n        Object.defineProperty(this, \"items\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n    }\n    get size() {\n        return this.items.length;\n    }\n    push(item) {\n        // this.items.push is synchronous with promise creation:\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise\n        return new Promise((resolve) => {\n            this.items.push([item, resolve]);\n        });\n    }\n    pop(upToN) {\n        if (upToN < 1) {\n            throw new Error(\"Number of items to pop off may not be less than 1.\");\n        }\n        const popped = [];\n        while (popped.length < upToN && this.items.length) {\n            const item = this.items.shift();\n            if (item) {\n                popped.push(item);\n            }\n            else {\n                break;\n            }\n        }\n        return [popped.map((it) => it[0]), () => popped.forEach((it) => it[1]())];\n    }\n}\n// 20 MB\nexport const DEFAULT_BATCH_SIZE_LIMIT_BYTES = 20971520;\nexport class Client {\n    constructor(config = {}) {\n        Object.defineProperty(this, \"apiKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"apiUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"webUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"caller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"batchIngestCaller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"timeout_ms\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_tenantId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: null\n        });\n        Object.defineProperty(this, \"hideInputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"hideOutputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tracingSampleRate\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"sampledPostUuids\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Set()\n        });\n        Object.defineProperty(this, \"autoBatchTracing\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"batchEndpointSupported\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"autoBatchQueue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Queue()\n        });\n        Object.defineProperty(this, \"pendingAutoBatchedRunLimit\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 100\n        });\n        Object.defineProperty(this, \"autoBatchTimeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"autoBatchInitialDelayMs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 250\n        });\n        Object.defineProperty(this, \"autoBatchAggregationDelayMs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 50\n        });\n        Object.defineProperty(this, \"serverInfo\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        const defaultConfig = Client.getDefaultClientConfig();\n        this.tracingSampleRate = getTracingSamplingRate();\n        this.apiUrl = trimQuotes(config.apiUrl ?? defaultConfig.apiUrl) ?? \"\";\n        this.apiKey = trimQuotes(config.apiKey ?? defaultConfig.apiKey);\n        this.webUrl = trimQuotes(config.webUrl ?? defaultConfig.webUrl);\n        this.timeout_ms = config.timeout_ms ?? 12000;\n        this.caller = new AsyncCaller(config.callerOptions ?? {});\n        this.batchIngestCaller = new AsyncCaller({\n            ...(config.callerOptions ?? {}),\n            onFailedResponseHook: handle429,\n        });\n        this.hideInputs = config.hideInputs ?? defaultConfig.hideInputs;\n        this.hideOutputs = config.hideOutputs ?? defaultConfig.hideOutputs;\n        this.autoBatchTracing = config.autoBatchTracing ?? this.autoBatchTracing;\n        this.pendingAutoBatchedRunLimit =\n            config.pendingAutoBatchedRunLimit ?? this.pendingAutoBatchedRunLimit;\n    }\n    static getDefaultClientConfig() {\n        const apiKey = getEnvironmentVariable(\"LANGCHAIN_API_KEY\");\n        const apiUrl = getEnvironmentVariable(\"LANGCHAIN_ENDPOINT\") ??\n            \"https://api.smith.langchain.com\";\n        const hideInputs = getEnvironmentVariable(\"LANGCHAIN_HIDE_INPUTS\") === \"true\";\n        const hideOutputs = getEnvironmentVariable(\"LANGCHAIN_HIDE_OUTPUTS\") === \"true\";\n        return {\n            apiUrl: apiUrl,\n            apiKey: apiKey,\n            webUrl: undefined,\n            hideInputs: hideInputs,\n            hideOutputs: hideOutputs,\n        };\n    }\n    getHostUrl() {\n        if (this.webUrl) {\n            return this.webUrl;\n        }\n        else if (isLocalhost(this.apiUrl)) {\n            this.webUrl = \"http://localhost\";\n            return \"http://localhost\";\n        }\n        else if (this.apiUrl.includes(\"/api\") &&\n            !this.apiUrl.split(\".\", 1)[0].endsWith(\"api\")) {\n            this.webUrl = this.apiUrl.replace(\"/api\", \"\");\n            return this.webUrl;\n        }\n        else if (this.apiUrl.split(\".\", 1)[0].includes(\"dev\")) {\n            this.webUrl = \"https://dev.smith.langchain.com\";\n            return \"https://dev.smith.langchain.com\";\n        }\n        else {\n            this.webUrl = \"https://smith.langchain.com\";\n            return \"https://smith.langchain.com\";\n        }\n    }\n    get headers() {\n        const headers = {\n            \"User-Agent\": `langsmith-js/${__version__}`,\n        };\n        if (this.apiKey) {\n            headers[\"x-api-key\"] = `${this.apiKey}`;\n        }\n        return headers;\n    }\n    processInputs(inputs) {\n        if (this.hideInputs === false) {\n            return inputs;\n        }\n        if (this.hideInputs === true) {\n            return {};\n        }\n        if (typeof this.hideInputs === \"function\") {\n            return this.hideInputs(inputs);\n        }\n        return inputs;\n    }\n    processOutputs(outputs) {\n        if (this.hideOutputs === false) {\n            return outputs;\n        }\n        if (this.hideOutputs === true) {\n            return {};\n        }\n        if (typeof this.hideOutputs === \"function\") {\n            return this.hideOutputs(outputs);\n        }\n        return outputs;\n    }\n    prepareRunCreateOrUpdateInputs(run) {\n        const runParams = { ...run };\n        if (runParams.inputs !== undefined) {\n            runParams.inputs = this.processInputs(runParams.inputs);\n        }\n        if (runParams.outputs !== undefined) {\n            runParams.outputs = this.processOutputs(runParams.outputs);\n        }\n        return runParams;\n    }\n    async _getResponse(path, queryParams) {\n        const paramsString = queryParams?.toString() ?? \"\";\n        const url = `${this.apiUrl}${path}?${paramsString}`;\n        const response = await this.caller.call(fetch, url, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to fetch ${path}: ${response.status} ${response.statusText}`);\n        }\n        return response;\n    }\n    async _get(path, queryParams) {\n        const response = await this._getResponse(path, queryParams);\n        return response.json();\n    }\n    async *_getPaginated(path, queryParams = new URLSearchParams()) {\n        let offset = Number(queryParams.get(\"offset\")) || 0;\n        const limit = Number(queryParams.get(\"limit\")) || 100;\n        while (true) {\n            queryParams.set(\"offset\", String(offset));\n            queryParams.set(\"limit\", String(limit));\n            const url = `${this.apiUrl}${path}?${queryParams}`;\n            const response = await this.caller.call(fetch, url, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n            });\n            if (!response.ok) {\n                throw new Error(`Failed to fetch ${path}: ${response.status} ${response.statusText}`);\n            }\n            const items = await response.json();\n            if (items.length === 0) {\n                break;\n            }\n            yield items;\n            if (items.length < limit) {\n                break;\n            }\n            offset += items.length;\n        }\n    }\n    async *_getCursorPaginatedList(path, body = null, requestMethod = \"POST\", dataKey = \"runs\") {\n        const bodyParams = body ? { ...body } : {};\n        while (true) {\n            const response = await this.caller.call(fetch, `${this.apiUrl}${path}`, {\n                method: requestMethod,\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                body: JSON.stringify(bodyParams),\n            });\n            const responseBody = await response.json();\n            if (!responseBody) {\n                break;\n            }\n            if (!responseBody[dataKey]) {\n                break;\n            }\n            yield responseBody[dataKey];\n            const cursors = responseBody.cursors;\n            if (!cursors) {\n                break;\n            }\n            if (!cursors.next) {\n                break;\n            }\n            bodyParams.cursor = cursors.next;\n        }\n    }\n    _filterForSampling(runs, patch = false) {\n        if (this.tracingSampleRate === undefined) {\n            return runs;\n        }\n        if (patch) {\n            const sampled = [];\n            for (const run of runs) {\n                if (this.sampledPostUuids.has(run.id)) {\n                    sampled.push(run);\n                    this.sampledPostUuids.delete(run.id);\n                }\n            }\n            return sampled;\n        }\n        else {\n            const sampled = [];\n            for (const run of runs) {\n                if (Math.random() < this.tracingSampleRate) {\n                    sampled.push(run);\n                    this.sampledPostUuids.add(run.id);\n                }\n            }\n            return sampled;\n        }\n    }\n    async drainAutoBatchQueue() {\n        while (this.autoBatchQueue.size >= 0) {\n            const [batch, done] = this.autoBatchQueue.pop(this.pendingAutoBatchedRunLimit);\n            if (!batch.length) {\n                done();\n                return;\n            }\n            try {\n                await this.batchIngestRuns({\n                    runCreates: batch\n                        .filter((item) => item.action === \"create\")\n                        .map((item) => item.item),\n                    runUpdates: batch\n                        .filter((item) => item.action === \"update\")\n                        .map((item) => item.item),\n                });\n            }\n            finally {\n                done();\n            }\n        }\n    }\n    async processRunOperation(item, immediatelyTriggerBatch) {\n        const oldTimeout = this.autoBatchTimeout;\n        clearTimeout(this.autoBatchTimeout);\n        this.autoBatchTimeout = undefined;\n        const itemPromise = this.autoBatchQueue.push(item);\n        if (immediatelyTriggerBatch ||\n            this.autoBatchQueue.size > this.pendingAutoBatchedRunLimit) {\n            await this.drainAutoBatchQueue();\n        }\n        if (this.autoBatchQueue.size > 0) {\n            this.autoBatchTimeout = setTimeout(() => {\n                this.autoBatchTimeout = undefined;\n                // This error would happen in the background and is uncatchable\n                // from the outside. So just log instead.\n                void this.drainAutoBatchQueue().catch(console.error);\n            }, oldTimeout\n                ? this.autoBatchAggregationDelayMs\n                : this.autoBatchInitialDelayMs);\n        }\n        return itemPromise;\n    }\n    async _getServerInfo() {\n        const response = await fetch(`${this.apiUrl}/info`, {\n            method: \"GET\",\n            headers: { Accept: \"application/json\" },\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            // consume the response body to release the connection\n            // https://undici.nodejs.org/#/?id=garbage-collection\n            await response.text();\n            throw new Error(\"Failed to retrieve server info.\");\n        }\n        return response.json();\n    }\n    async batchEndpointIsSupported() {\n        try {\n            this.serverInfo = await this._getServerInfo();\n        }\n        catch (e) {\n            return false;\n        }\n        return true;\n    }\n    async createRun(run) {\n        if (!this._filterForSampling([run]).length) {\n            return;\n        }\n        const headers = { ...this.headers, \"Content-Type\": \"application/json\" };\n        const session_name = run.project_name;\n        delete run.project_name;\n        const runCreate = this.prepareRunCreateOrUpdateInputs({\n            session_name,\n            ...run,\n            start_time: run.start_time ?? Date.now(),\n        });\n        if (this.autoBatchTracing &&\n            runCreate.trace_id !== undefined &&\n            runCreate.dotted_order !== undefined) {\n            void this.processRunOperation({\n                action: \"create\",\n                item: runCreate,\n            }).catch(console.error);\n            return;\n        }\n        const mergedRunCreateParams = await mergeRuntimeEnvIntoRunCreates([\n            runCreate,\n        ]);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs`, {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify(mergedRunCreateParams[0]),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, \"create run\");\n    }\n    /**\n     * Batch ingest/upsert multiple runs in the Langsmith system.\n     * @param runs\n     */\n    async batchIngestRuns({ runCreates, runUpdates, }) {\n        if (runCreates === undefined && runUpdates === undefined) {\n            return;\n        }\n        let preparedCreateParams = runCreates?.map((create) => this.prepareRunCreateOrUpdateInputs(create)) ?? [];\n        let preparedUpdateParams = runUpdates?.map((update) => this.prepareRunCreateOrUpdateInputs(update)) ?? [];\n        if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {\n            const createById = preparedCreateParams.reduce((params, run) => {\n                if (!run.id) {\n                    return params;\n                }\n                params[run.id] = run;\n                return params;\n            }, {});\n            const standaloneUpdates = [];\n            for (const updateParam of preparedUpdateParams) {\n                if (updateParam.id !== undefined && createById[updateParam.id]) {\n                    createById[updateParam.id] = {\n                        ...createById[updateParam.id],\n                        ...updateParam,\n                    };\n                }\n                else {\n                    standaloneUpdates.push(updateParam);\n                }\n            }\n            preparedCreateParams = Object.values(createById);\n            preparedUpdateParams = standaloneUpdates;\n        }\n        const rawBatch = {\n            post: this._filterForSampling(preparedCreateParams),\n            patch: this._filterForSampling(preparedUpdateParams, true),\n        };\n        if (!rawBatch.post.length && !rawBatch.patch.length) {\n            return;\n        }\n        preparedCreateParams = await mergeRuntimeEnvIntoRunCreates(preparedCreateParams);\n        if (this.batchEndpointSupported === undefined) {\n            this.batchEndpointSupported = await this.batchEndpointIsSupported();\n        }\n        if (!this.batchEndpointSupported) {\n            this.autoBatchTracing = false;\n            for (const preparedCreateParam of rawBatch.post) {\n                await this.createRun(preparedCreateParam);\n            }\n            for (const preparedUpdateParam of rawBatch.patch) {\n                if (preparedUpdateParam.id !== undefined) {\n                    await this.updateRun(preparedUpdateParam.id, preparedUpdateParam);\n                }\n            }\n            return;\n        }\n        const sizeLimitBytes = this.serverInfo?.batch_ingest_config?.size_limit_bytes ??\n            DEFAULT_BATCH_SIZE_LIMIT_BYTES;\n        const batchChunks = {\n            post: [],\n            patch: [],\n        };\n        let currentBatchSizeBytes = 0;\n        for (const k of [\"post\", \"patch\"]) {\n            const key = k;\n            const batchItems = rawBatch[key].reverse();\n            let batchItem = batchItems.pop();\n            while (batchItem !== undefined) {\n                const stringifiedBatchItem = JSON.stringify(batchItem);\n                if (currentBatchSizeBytes > 0 &&\n                    currentBatchSizeBytes + stringifiedBatchItem.length > sizeLimitBytes) {\n                    await this._postBatchIngestRuns(JSON.stringify(batchChunks));\n                    currentBatchSizeBytes = 0;\n                    batchChunks.post = [];\n                    batchChunks.patch = [];\n                }\n                currentBatchSizeBytes += stringifiedBatchItem.length;\n                batchChunks[key].push(batchItem);\n                batchItem = batchItems.pop();\n            }\n        }\n        if (batchChunks.post.length > 0 || batchChunks.patch.length > 0) {\n            await this._postBatchIngestRuns(JSON.stringify(batchChunks));\n        }\n    }\n    async _postBatchIngestRuns(body) {\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\",\n            Accept: \"application/json\",\n        };\n        const response = await this.batchIngestCaller.call(fetch, `${this.apiUrl}/runs/batch`, {\n            method: \"POST\",\n            headers,\n            body: body,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, \"batch create run\");\n    }\n    async updateRun(runId, run) {\n        assertUuid(runId);\n        if (run.inputs) {\n            run.inputs = this.processInputs(run.inputs);\n        }\n        if (run.outputs) {\n            run.outputs = this.processOutputs(run.outputs);\n        }\n        // TODO: Untangle types\n        const data = { ...run, id: runId };\n        if (!this._filterForSampling([data], true).length) {\n            return;\n        }\n        if (this.autoBatchTracing &&\n            data.trace_id !== undefined &&\n            data.dotted_order !== undefined) {\n            if (run.end_time !== undefined && data.parent_run_id === undefined) {\n                // Trigger a batch as soon as a root trace ends and block to ensure trace finishes\n                // in serverless environments.\n                await this.processRunOperation({ action: \"update\", item: data }, true);\n                return;\n            }\n            else {\n                void this.processRunOperation({ action: \"update\", item: data }).catch(console.error);\n            }\n            return;\n        }\n        const headers = { ...this.headers, \"Content-Type\": \"application/json\" };\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}`, {\n            method: \"PATCH\",\n            headers,\n            body: JSON.stringify(run),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, \"update run\");\n    }\n    async readRun(runId, { loadChildRuns } = { loadChildRuns: false }) {\n        assertUuid(runId);\n        let run = await this._get(`/runs/${runId}`);\n        if (loadChildRuns && run.child_run_ids) {\n            run = await this._loadChildRuns(run);\n        }\n        return run;\n    }\n    async getRunUrl({ runId, run, projectOpts, }) {\n        if (run !== undefined) {\n            let sessionId;\n            if (run.session_id) {\n                sessionId = run.session_id;\n            }\n            else if (projectOpts?.projectName) {\n                sessionId = (await this.readProject({ projectName: projectOpts?.projectName })).id;\n            }\n            else if (projectOpts?.projectId) {\n                sessionId = projectOpts?.projectId;\n            }\n            else {\n                const project = await this.readProject({\n                    projectName: getEnvironmentVariable(\"LANGCHAIN_PROJECT\") || \"default\",\n                });\n                sessionId = project.id;\n            }\n            const tenantId = await this._getTenantId();\n            return `${this.getHostUrl()}/o/${tenantId}/projects/p/${sessionId}/r/${run.id}?poll=true`;\n        }\n        else if (runId !== undefined) {\n            const run_ = await this.readRun(runId);\n            if (!run_.app_path) {\n                throw new Error(`Run ${runId} has no app_path`);\n            }\n            const baseUrl = this.getHostUrl();\n            return `${baseUrl}${run_.app_path}`;\n        }\n        else {\n            throw new Error(\"Must provide either runId or run\");\n        }\n    }\n    async _loadChildRuns(run) {\n        const childRuns = await toArray(this.listRuns({ id: run.child_run_ids }));\n        const treemap = {};\n        const runs = {};\n        // TODO: make dotted order required when the migration finishes\n        childRuns.sort((a, b) => (a?.dotted_order ?? \"\").localeCompare(b?.dotted_order ?? \"\"));\n        for (const childRun of childRuns) {\n            if (childRun.parent_run_id === null ||\n                childRun.parent_run_id === undefined) {\n                throw new Error(`Child run ${childRun.id} has no parent`);\n            }\n            if (!(childRun.parent_run_id in treemap)) {\n                treemap[childRun.parent_run_id] = [];\n            }\n            treemap[childRun.parent_run_id].push(childRun);\n            runs[childRun.id] = childRun;\n        }\n        run.child_runs = treemap[run.id] || [];\n        for (const runId in treemap) {\n            if (runId !== run.id) {\n                runs[runId].child_runs = treemap[runId];\n            }\n        }\n        return run;\n    }\n    /**\n     * List runs from the LangSmith server.\n     * @param projectId - The ID of the project to filter by.\n     * @param projectName - The name of the project to filter by.\n     * @param parentRunId - The ID of the parent run to filter by.\n     * @param traceId - The ID of the trace to filter by.\n     * @param referenceExampleId - The ID of the reference example to filter by.\n     * @param startTime - The start time to filter by.\n     * @param executionOrder - The execution order to filter by.\n     * @param runType - The run type to filter by.\n     * @param error - Indicates whether to filter by error runs.\n     * @param id - The ID of the run to filter by.\n     * @param query - The query string to filter by.\n     * @param filter - The filter string to apply to the run spans.\n     * @param traceFilter - The filter string to apply on the root run of the trace.\n     * @param limit - The maximum number of runs to retrieve.\n     * @returns {AsyncIterable<Run>} - The runs.\n     *\n     * @example\n     * // List all runs in a project\n     * const projectRuns = client.listRuns({ projectName: \"<your_project>\" });\n     *\n     * @example\n     * // List LLM and Chat runs in the last 24 hours\n     * const todaysLLMRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   start_time: new Date(Date.now() - 24 * 60 * 60 * 1000),\n     *   run_type: \"llm\",\n     * });\n     *\n     * @example\n     * // List traces in a project\n     * const rootRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   execution_order: 1,\n     * });\n     *\n     * @example\n     * // List runs without errors\n     * const correctRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   error: false,\n     * });\n     *\n     * @example\n     * // List runs by run ID\n     * const runIds = [\n     *   \"a36092d2-4ad5-4fb4-9c0d-0dba9a2ed836\",\n     *   \"9398e6be-964f-4aa4-8ae9-ad78cd4b7074\",\n     * ];\n     * const selectedRuns = client.listRuns({ run_ids: runIds });\n     *\n     * @example\n     * // List all \"chain\" type runs that took more than 10 seconds and had `total_tokens` greater than 5000\n     * const chainRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(eq(run_type, \"chain\"), gt(latency, 10), gt(total_tokens, 5000))',\n     * });\n     *\n     * @example\n     * // List all runs called \"extractor\" whose root of the trace was assigned feedback \"user_score\" score of 1\n     * const goodExtractorRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'eq(name, \"extractor\")',\n     *   traceFilter: 'and(eq(feedback_key, \"user_score\"), eq(feedback_score, 1))',\n     * });\n     *\n     * @example\n     * // List all runs that started after a specific timestamp and either have \"error\" not equal to null or a \"Correctness\" feedback score equal to 0\n     * const complexRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(gt(start_time, \"2023-07-15T12:34:56Z\"), or(neq(error, null), and(eq(feedback_key, \"Correctness\"), eq(feedback_score, 0.0))))',\n     * });\n     *\n     * @example\n     * // List all runs where `tags` include \"experimental\" or \"beta\" and `latency` is greater than 2 seconds\n     * const taggedRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(or(has(tags, \"experimental\"), has(tags, \"beta\")), gt(latency, 2))',\n     * });\n     */\n    async *listRuns(props) {\n        const { projectId, projectName, parentRunId, traceId, referenceExampleId, startTime, executionOrder, runType, error, id, query, filter, traceFilter, treeFilter, limit, } = props;\n        let projectIds = [];\n        if (projectId) {\n            projectIds = Array.isArray(projectId) ? projectId : [projectId];\n        }\n        if (projectName) {\n            const projectNames = Array.isArray(projectName)\n                ? projectName\n                : [projectName];\n            const projectIds_ = await Promise.all(projectNames.map((name) => this.readProject({ projectName: name }).then((project) => project.id)));\n            projectIds.push(...projectIds_);\n        }\n        const body = {\n            session: projectIds.length ? projectIds : null,\n            run_type: runType,\n            reference_example: referenceExampleId,\n            query,\n            filter,\n            trace_filter: traceFilter,\n            tree_filter: treeFilter,\n            execution_order: executionOrder,\n            parent_run: parentRunId,\n            start_time: startTime ? startTime.toISOString() : null,\n            error,\n            id,\n            limit,\n            trace: traceId,\n        };\n        for await (const runs of this._getCursorPaginatedList(\"/runs/query\", body)) {\n            yield* runs;\n        }\n    }\n    async shareRun(runId, { shareId } = {}) {\n        const data = {\n            run_id: runId,\n            share_token: shareId || uuid.v4(),\n        };\n        assertUuid(runId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"PUT\",\n            headers: this.headers,\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            throw new Error(\"Invalid response from server\");\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async unshareRun(runId) {\n        assertUuid(runId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, \"unshare run\");\n    }\n    async readRunSharedLink(runId) {\n        assertUuid(runId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            return undefined;\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async listSharedRuns(shareToken, { runIds, } = {}) {\n        const queryParams = new URLSearchParams({\n            share_token: shareToken,\n        });\n        if (runIds !== undefined) {\n            for (const runId of runIds) {\n                queryParams.append(\"id\", runId);\n            }\n        }\n        assertUuid(shareToken);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/public/${shareToken}/runs${queryParams}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const runs = await response.json();\n        return runs;\n    }\n    async readDatasetSharedSchema(datasetId, datasetName) {\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Either datasetId or datasetName must be given\");\n        }\n        if (!datasetId) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId = dataset.id;\n        }\n        assertUuid(datasetId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const shareSchema = await response.json();\n        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n        return shareSchema;\n    }\n    async shareDataset(datasetId, datasetName) {\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Either datasetId or datasetName must be given\");\n        }\n        if (!datasetId) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId = dataset.id;\n        }\n        const data = {\n            dataset_id: datasetId,\n        };\n        assertUuid(datasetId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"PUT\",\n            headers: this.headers,\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const shareSchema = await response.json();\n        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n        return shareSchema;\n    }\n    async unshareDataset(datasetId) {\n        assertUuid(datasetId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, \"unshare dataset\");\n    }\n    async readSharedDataset(shareToken) {\n        assertUuid(shareToken);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/public/${shareToken}/datasets`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const dataset = await response.json();\n        return dataset;\n    }\n    async createProject({ projectName, description = null, metadata = null, upsert = false, projectExtra = null, referenceDatasetId = null, }) {\n        const upsert_ = upsert ? `?upsert=true` : \"\";\n        const endpoint = `${this.apiUrl}/sessions${upsert_}`;\n        const extra = projectExtra || {};\n        if (metadata) {\n            extra[\"metadata\"] = metadata;\n        }\n        const body = {\n            name: projectName,\n            extra,\n            description,\n        };\n        if (referenceDatasetId !== null) {\n            body[\"reference_dataset_id\"] = referenceDatasetId;\n        }\n        const response = await this.caller.call(fetch, endpoint, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const result = await response.json();\n        if (!response.ok) {\n            throw new Error(`Failed to create session ${projectName}: ${response.status} ${response.statusText}`);\n        }\n        return result;\n    }\n    async updateProject(projectId, { name = null, description = null, metadata = null, projectExtra = null, endTime = null, }) {\n        const endpoint = `${this.apiUrl}/sessions/${projectId}`;\n        let extra = projectExtra;\n        if (metadata) {\n            extra = { ...(extra || {}), metadata };\n        }\n        const body = {\n            name,\n            extra,\n            description,\n            end_time: endTime ? new Date(endTime).toISOString() : null,\n        };\n        const response = await this.caller.call(fetch, endpoint, {\n            method: \"PATCH\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const result = await response.json();\n        if (!response.ok) {\n            throw new Error(`Failed to update project ${projectId}: ${response.status} ${response.statusText}`);\n        }\n        return result;\n    }\n    async hasProject({ projectId, projectName, }) {\n        // TODO: Add a head request\n        let path = \"/sessions\";\n        const params = new URLSearchParams();\n        if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        }\n        else if (projectId !== undefined) {\n            assertUuid(projectId);\n            path += `/${projectId}`;\n        }\n        else if (projectName !== undefined) {\n            params.append(\"name\", projectName);\n        }\n        else {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        const response = await this.caller.call(fetch, `${this.apiUrl}${path}?${params}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        // consume the response body to release the connection\n        // https://undici.nodejs.org/#/?id=garbage-collection\n        try {\n            const result = await response.json();\n            if (!response.ok) {\n                return false;\n            }\n            // If it's OK and we're querying by name, need to check the list is not empty\n            if (Array.isArray(result)) {\n                return result.length > 0;\n            }\n            // projectId querying\n            return true;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    async readProject({ projectId, projectName, includeStats, }) {\n        let path = \"/sessions\";\n        const params = new URLSearchParams();\n        if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        }\n        else if (projectId !== undefined) {\n            assertUuid(projectId);\n            path += `/${projectId}`;\n        }\n        else if (projectName !== undefined) {\n            params.append(\"name\", projectName);\n        }\n        else {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        if (includeStats !== undefined) {\n            params.append(\"include_stats\", includeStats.toString());\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Project[id=${projectId}, name=${projectName}] not found`);\n            }\n            result = response[0];\n        }\n        else {\n            result = response;\n        }\n        return result;\n    }\n    async _getTenantId() {\n        if (this._tenantId !== null) {\n            return this._tenantId;\n        }\n        const queryParams = new URLSearchParams({ limit: \"1\" });\n        for await (const projects of this._getPaginated(\"/sessions\", queryParams)) {\n            this._tenantId = projects[0].tenant_id;\n            return projects[0].tenant_id;\n        }\n        throw new Error(\"No projects found to resolve tenant.\");\n    }\n    async *listProjects({ projectIds, name, nameContains, referenceDatasetId, referenceDatasetName, referenceFree, } = {}) {\n        const params = new URLSearchParams();\n        if (projectIds !== undefined) {\n            for (const projectId of projectIds) {\n                params.append(\"id\", projectId);\n            }\n        }\n        if (name !== undefined) {\n            params.append(\"name\", name);\n        }\n        if (nameContains !== undefined) {\n            params.append(\"name_contains\", nameContains);\n        }\n        if (referenceDatasetId !== undefined) {\n            params.append(\"reference_dataset\", referenceDatasetId);\n        }\n        else if (referenceDatasetName !== undefined) {\n            const dataset = await this.readDataset({\n                datasetName: referenceDatasetName,\n            });\n            params.append(\"reference_dataset\", dataset.id);\n        }\n        if (referenceFree !== undefined) {\n            params.append(\"reference_free\", referenceFree.toString());\n        }\n        for await (const projects of this._getPaginated(\"/sessions\", params)) {\n            yield* projects;\n        }\n    }\n    async deleteProject({ projectId, projectName, }) {\n        let projectId_;\n        if (projectId === undefined && projectName === undefined) {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        else if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        }\n        else if (projectId === undefined) {\n            projectId_ = (await this.readProject({ projectName })).id;\n        }\n        else {\n            projectId_ = projectId;\n        }\n        assertUuid(projectId_);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/sessions/${projectId_}`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, `delete session ${projectId_} (${projectName})`);\n    }\n    async uploadCsv({ csvFile, fileName, inputKeys, outputKeys, description, dataType, name, }) {\n        const url = `${this.apiUrl}/datasets/upload`;\n        const formData = new FormData();\n        formData.append(\"file\", csvFile, fileName);\n        inputKeys.forEach((key) => {\n            formData.append(\"input_keys\", key);\n        });\n        outputKeys.forEach((key) => {\n            formData.append(\"output_keys\", key);\n        });\n        if (description) {\n            formData.append(\"description\", description);\n        }\n        if (dataType) {\n            formData.append(\"data_type\", dataType);\n        }\n        if (name) {\n            formData.append(\"name\", name);\n        }\n        const response = await this.caller.call(fetch, url, {\n            method: \"POST\",\n            headers: this.headers,\n            body: formData,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            const result = await response.json();\n            if (result.detail && result.detail.includes(\"already exists\")) {\n                throw new Error(`Dataset ${fileName} already exists`);\n            }\n            throw new Error(`Failed to upload CSV: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async createDataset(name, { description, dataType, } = {}) {\n        const body = {\n            name,\n            description,\n        };\n        if (dataType) {\n            body.data_type = dataType;\n        }\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            const result = await response.json();\n            if (result.detail && result.detail.includes(\"already exists\")) {\n                throw new Error(`Dataset ${name} already exists`);\n            }\n            throw new Error(`Failed to create dataset ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async readDataset({ datasetId, datasetName, }) {\n        let path = \"/datasets\";\n        // limit to 1 result\n        const params = new URLSearchParams({ limit: \"1\" });\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId !== undefined) {\n            assertUuid(datasetId);\n            path += `/${datasetId}`;\n        }\n        else if (datasetName !== undefined) {\n            params.append(\"name\", datasetName);\n        }\n        else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Dataset[id=${datasetId}, name=${datasetName}] not found`);\n            }\n            result = response[0];\n        }\n        else {\n            result = response;\n        }\n        return result;\n    }\n    async diffDatasetVersions({ datasetId, datasetName, fromVersion, toVersion, }) {\n        let datasetId_ = datasetId;\n        if (datasetId_ === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        else if (datasetId_ !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        const urlParams = new URLSearchParams({\n            from_version: typeof fromVersion === \"string\"\n                ? fromVersion\n                : fromVersion.toISOString(),\n            to_version: typeof toVersion === \"string\" ? toVersion : toVersion.toISOString(),\n        });\n        const response = await this._get(`/datasets/${datasetId_}/versions/diff`, urlParams);\n        return response;\n    }\n    async readDatasetOpenaiFinetuning({ datasetId, datasetName, }) {\n        const path = \"/datasets\";\n        if (datasetId !== undefined) {\n            // do nothing\n        }\n        else if (datasetName !== undefined) {\n            datasetId = (await this.readDataset({ datasetName })).id;\n        }\n        else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this._getResponse(`${path}/${datasetId}/openai_ft`);\n        const datasetText = await response.text();\n        const dataset = datasetText\n            .trim()\n            .split(\"\\n\")\n            .map((line) => JSON.parse(line));\n        return dataset;\n    }\n    async *listDatasets({ limit = 100, offset = 0, datasetIds, datasetName, datasetNameContains, } = {}) {\n        const path = \"/datasets\";\n        const params = new URLSearchParams({\n            limit: limit.toString(),\n            offset: offset.toString(),\n        });\n        if (datasetIds !== undefined) {\n            for (const id_ of datasetIds) {\n                params.append(\"id\", id_);\n            }\n        }\n        if (datasetName !== undefined) {\n            params.append(\"name\", datasetName);\n        }\n        if (datasetNameContains !== undefined) {\n            params.append(\"name_contains\", datasetNameContains);\n        }\n        for await (const datasets of this._getPaginated(path, params)) {\n            yield* datasets;\n        }\n    }\n    async deleteDataset({ datasetId, datasetName, }) {\n        let path = \"/datasets\";\n        let datasetId_ = datasetId;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        if (datasetId_ !== undefined) {\n            assertUuid(datasetId_);\n            path += `/${datasetId_}`;\n        }\n        else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this.caller.call(fetch, this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n        }\n        await response.json();\n    }\n    async createExample(inputs, outputs, { datasetId, datasetName, createdAt, exampleId }) {\n        let datasetId_ = datasetId;\n        if (datasetId_ === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        else if (datasetId_ !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        const createdAt_ = createdAt || new Date();\n        const data = {\n            dataset_id: datasetId_,\n            inputs,\n            outputs,\n            created_at: createdAt_?.toISOString(),\n            id: exampleId,\n        };\n        const response = await this.caller.call(fetch, `${this.apiUrl}/examples`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to create example: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async createExamples(props) {\n        const { inputs, outputs, sourceRunIds, exampleIds, datasetId, datasetName, } = props;\n        let datasetId_ = datasetId;\n        if (datasetId_ === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        else if (datasetId_ !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        const formattedExamples = inputs.map((input, idx) => {\n            return {\n                dataset_id: datasetId_,\n                inputs: input,\n                outputs: outputs ? outputs[idx] : undefined,\n                id: exampleIds ? exampleIds[idx] : undefined,\n                source_run_id: sourceRunIds ? sourceRunIds[idx] : undefined,\n            };\n        });\n        const response = await this.caller.call(fetch, `${this.apiUrl}/examples/bulk`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(formattedExamples),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to create examples: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async createLLMExample(input, generation, options) {\n        return this.createExample({ input }, { output: generation }, options);\n    }\n    async createChatExample(input, generations, options) {\n        const finalInput = input.map((message) => {\n            if (isLangChainMessage(message)) {\n                return convertLangChainMessageToExample(message);\n            }\n            return message;\n        });\n        const finalOutput = isLangChainMessage(generations)\n            ? convertLangChainMessageToExample(generations)\n            : generations;\n        return this.createExample({ input: finalInput }, { output: finalOutput }, options);\n    }\n    async readExample(exampleId) {\n        assertUuid(exampleId);\n        const path = `/examples/${exampleId}`;\n        return await this._get(path);\n    }\n    async *listExamples({ datasetId, datasetName, exampleIds, asOf, inlineS3Urls, } = {}) {\n        let datasetId_;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId !== undefined) {\n            datasetId_ = datasetId;\n        }\n        else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        else {\n            throw new Error(\"Must provide a datasetName or datasetId\");\n        }\n        const params = new URLSearchParams({ dataset: datasetId_ });\n        const dataset_version = asOf\n            ? typeof asOf === \"string\"\n                ? asOf\n                : asOf?.toISOString()\n            : undefined;\n        if (dataset_version) {\n            params.append(\"as_of\", dataset_version);\n        }\n        const inlineS3Urls_ = inlineS3Urls ?? true;\n        params.append(\"inline_s3_urls\", inlineS3Urls_.toString());\n        if (exampleIds !== undefined) {\n            for (const id_ of exampleIds) {\n                params.append(\"id\", id_);\n            }\n        }\n        for await (const examples of this._getPaginated(\"/examples\", params)) {\n            yield* examples;\n        }\n    }\n    async deleteExample(exampleId) {\n        assertUuid(exampleId);\n        const path = `/examples/${exampleId}`;\n        const response = await this.caller.call(fetch, this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n        }\n        await response.json();\n    }\n    async updateExample(exampleId, update) {\n        assertUuid(exampleId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/examples/${exampleId}`, {\n            method: \"PATCH\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(update),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to update example ${exampleId}: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async evaluateRun(run, evaluator, { sourceInfo, loadChildRuns, referenceExample, } = { loadChildRuns: false }) {\n        let run_;\n        if (typeof run === \"string\") {\n            run_ = await this.readRun(run, { loadChildRuns });\n        }\n        else if (typeof run === \"object\" && \"id\" in run) {\n            run_ = run;\n        }\n        else {\n            throw new Error(`Invalid run type: ${typeof run}`);\n        }\n        if (run_.reference_example_id !== null &&\n            run_.reference_example_id !== undefined) {\n            referenceExample = await this.readExample(run_.reference_example_id);\n        }\n        const feedbackResult = await evaluator.evaluateRun(run_, referenceExample);\n        let sourceInfo_ = sourceInfo ?? {};\n        if (feedbackResult.evaluatorInfo) {\n            sourceInfo_ = { ...sourceInfo_, ...feedbackResult.evaluatorInfo };\n        }\n        const runId = feedbackResult.targetRunId ?? run_.id;\n        return await this.createFeedback(runId, feedbackResult.key, {\n            score: feedbackResult?.score,\n            value: feedbackResult?.value,\n            comment: feedbackResult?.comment,\n            correction: feedbackResult?.correction,\n            sourceInfo: sourceInfo_,\n            feedbackSourceType: \"model\",\n            sourceRunId: feedbackResult?.sourceRunId,\n        });\n    }\n    async createFeedback(runId, key, { score, value, correction, comment, sourceInfo, feedbackSourceType = \"api\", sourceRunId, feedbackId, feedbackConfig, }) {\n        const feedback_source = {\n            type: feedbackSourceType ?? \"api\",\n            metadata: sourceInfo ?? {},\n        };\n        if (sourceRunId !== undefined &&\n            feedback_source?.metadata !== undefined &&\n            !feedback_source.metadata[\"__run\"]) {\n            feedback_source.metadata[\"__run\"] = { run_id: sourceRunId };\n        }\n        if (feedback_source?.metadata !== undefined &&\n            feedback_source.metadata[\"__run\"]?.run_id !== undefined) {\n            assertUuid(feedback_source.metadata[\"__run\"].run_id);\n        }\n        const feedback = {\n            id: feedbackId ?? uuid.v4(),\n            run_id: runId,\n            key,\n            score,\n            value,\n            correction,\n            comment,\n            feedback_source: feedback_source,\n            feedbackConfig,\n        };\n        const url = `${this.apiUrl}/feedback`;\n        const response = await this.caller.call(fetch, url, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(feedback),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, \"create feedback\");\n        return feedback;\n    }\n    async updateFeedback(feedbackId, { score, value, correction, comment, }) {\n        const feedbackUpdate = {};\n        if (score !== undefined && score !== null) {\n            feedbackUpdate[\"score\"] = score;\n        }\n        if (value !== undefined && value !== null) {\n            feedbackUpdate[\"value\"] = value;\n        }\n        if (correction !== undefined && correction !== null) {\n            feedbackUpdate[\"correction\"] = correction;\n        }\n        if (comment !== undefined && comment !== null) {\n            feedbackUpdate[\"comment\"] = comment;\n        }\n        assertUuid(feedbackId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/feedback/${feedbackId}`, {\n            method: \"PATCH\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(feedbackUpdate),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, \"update feedback\");\n    }\n    async readFeedback(feedbackId) {\n        assertUuid(feedbackId);\n        const path = `/feedback/${feedbackId}`;\n        const response = await this._get(path);\n        return response;\n    }\n    async deleteFeedback(feedbackId) {\n        assertUuid(feedbackId);\n        const path = `/feedback/${feedbackId}`;\n        const response = await this.caller.call(fetch, this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n        }\n        await response.json();\n    }\n    async *listFeedback({ runIds, feedbackKeys, feedbackSourceTypes, } = {}) {\n        const queryParams = new URLSearchParams();\n        if (runIds) {\n            queryParams.append(\"run\", runIds.join(\",\"));\n        }\n        if (feedbackKeys) {\n            for (const key of feedbackKeys) {\n                queryParams.append(\"key\", key);\n            }\n        }\n        if (feedbackSourceTypes) {\n            for (const type of feedbackSourceTypes) {\n                queryParams.append(\"source\", type);\n            }\n        }\n        for await (const feedbacks of this._getPaginated(\"/feedback\", queryParams)) {\n            yield* feedbacks;\n        }\n    }\n    /**\n     * Creates a presigned feedback token and URL.\n     *\n     * The token can be used to authorize feedback metrics without\n     * needing an API key. This is useful for giving browser-based\n     * applications the ability to submit feedback without needing\n     * to expose an API key.\n     *\n     * @param runId - The ID of the run.\n     * @param feedbackKey - The feedback key.\n     * @param options - Additional options for the token.\n     * @param options.expiration - The expiration time for the token.\n     *\n     * @returns A promise that resolves to a FeedbackIngestToken.\n     */\n    async createPresignedFeedbackToken(runId, feedbackKey, { expiration, feedbackConfig, } = {}) {\n        const body = {\n            run_id: runId,\n            feedback_key: feedbackKey,\n            feedback_config: feedbackConfig,\n        };\n        if (expiration) {\n            if (typeof expiration === \"string\") {\n                body[\"expires_at\"] = expiration;\n            }\n            else if (expiration?.hours || expiration?.minutes || expiration?.days) {\n                body[\"expires_in\"] = expiration;\n            }\n        }\n        else {\n            body[\"expires_in\"] = {\n                hours: 3,\n            };\n        }\n        const response = await this.caller.call(fetch, `${this.apiUrl}/feedback/tokens`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const result = await response.json();\n        return result;\n    }\n    /**\n     * Retrieves a list of presigned feedback tokens for a given run ID.\n     * @param runId The ID of the run.\n     * @returns An async iterable of FeedbackIngestToken objects.\n     */\n    async *listPresignedFeedbackTokens(runId) {\n        assertUuid(runId);\n        const params = new URLSearchParams({ run_id: runId });\n        for await (const tokens of this._getPaginated(\"/feedback/tokens\", params)) {\n            yield* tokens;\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}