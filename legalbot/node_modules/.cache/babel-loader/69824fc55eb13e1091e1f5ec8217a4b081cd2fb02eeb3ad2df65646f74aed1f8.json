{"ast":null,"code":"import { z } from \"zod\";\nimport { CallbackManager, parseCallbackConfigArg } from \"./callbacks/manager.js\";\nimport { BaseLangChain } from \"./language_models/base.js\";\nimport { ensureConfig } from \"./runnables/config.js\";\n/**\n * Custom error class used to handle exceptions related to tool input parsing.\n * It extends the built-in `Error` class and adds an optional `output`\n * property that can hold the output that caused the exception.\n */\nexport class ToolInputParsingException extends Error {\n  constructor(message, output) {\n    super(message);\n    Object.defineProperty(this, \"output\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.output = output;\n  }\n}\n/**\n * Base class for Tools that accept input of any shape defined by a Zod schema.\n */\nexport class StructuredTool extends BaseLangChain {\n  get lc_namespace() {\n    return [\"langchain\", \"tools\"];\n  }\n  constructor(fields) {\n    super(fields ?? {});\n    Object.defineProperty(this, \"returnDirect\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n  }\n  /**\n   * Invokes the tool with the provided input and configuration.\n   * @param input The input for the tool.\n   * @param config Optional configuration for the tool.\n   * @returns A Promise that resolves with a string.\n   */\n  async invoke(input, config) {\n    return this.call(input, ensureConfig(config));\n  }\n  /**\n   * Calls the tool with the provided argument, configuration, and tags. It\n   * parses the input according to the schema, handles any errors, and\n   * manages callbacks.\n   * @param arg The input argument for the tool.\n   * @param configArg Optional configuration or callbacks for the tool.\n   * @param tags Optional tags for the tool.\n   * @returns A Promise that resolves with a string.\n   */\n  async call(arg, configArg, /** @deprecated */\n  tags) {\n    let parsed;\n    try {\n      parsed = await this.schema.parseAsync(arg);\n    } catch (e) {\n      throw new ToolInputParsingException(`Received tool input did not match expected schema`, JSON.stringify(arg));\n    }\n    const config = parseCallbackConfigArg(configArg);\n    const callbackManager_ = await CallbackManager.configure(config.callbacks, this.callbacks, config.tags || tags, this.tags, config.metadata, this.metadata, {\n      verbose: this.verbose\n    });\n    const runManager = await callbackManager_?.handleToolStart(this.toJSON(), typeof parsed === \"string\" ? parsed : JSON.stringify(parsed), undefined, undefined, undefined, undefined, config.runName);\n    let result;\n    try {\n      result = await this._call(parsed, runManager, config);\n    } catch (e) {\n      await runManager?.handleToolError(e);\n      throw e;\n    }\n    await runManager?.handleToolEnd(result);\n    return result;\n  }\n}\n/**\n * Base class for Tools that accept input as a string.\n */\nexport class Tool extends StructuredTool {\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"schema\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: z.object({\n        input: z.string().optional()\n      }).transform(obj => obj.input)\n    });\n  }\n  /**\n   * Calls the tool with the provided argument and callbacks. It handles\n   * string inputs specifically.\n   * @param arg The input argument for the tool, which can be a string, undefined, or an input of the tool's schema.\n   * @param callbacks Optional callbacks for the tool.\n   * @returns A Promise that resolves with a string.\n   */\n  call(arg, callbacks) {\n    return super.call(typeof arg === \"string\" || !arg ? {\n      input: arg\n    } : arg, callbacks);\n  }\n}\n/**\n * A tool that can be created dynamically from a function, name, and description.\n */\nexport class DynamicTool extends Tool {\n  static lc_name() {\n    return \"DynamicTool\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"description\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"func\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.name = fields.name;\n    this.description = fields.description;\n    this.func = fields.func;\n    this.returnDirect = fields.returnDirect ?? this.returnDirect;\n  }\n  async call(arg, configArg) {\n    const config = parseCallbackConfigArg(configArg);\n    if (config.runName === undefined) {\n      config.runName = this.name;\n    }\n    return super.call(arg, config);\n  }\n  /** @ignore */\n  async _call(input, runManager, config) {\n    return this.func(input, runManager, config);\n  }\n}\n/**\n * A tool that can be created dynamically from a function, name, and\n * description, designed to work with structured data. It extends the\n * StructuredTool class and overrides the _call method to execute the\n * provided function when the tool is called.\n */\nexport class DynamicStructuredTool extends StructuredTool {\n  static lc_name() {\n    return \"DynamicStructuredTool\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"description\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"func\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"schema\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.name = fields.name;\n    this.description = fields.description;\n    this.func = fields.func;\n    this.returnDirect = fields.returnDirect ?? this.returnDirect;\n    this.schema = fields.schema;\n  }\n  async call(arg, configArg, /** @deprecated */\n  tags) {\n    const config = parseCallbackConfigArg(configArg);\n    if (config.runName === undefined) {\n      config.runName = this.name;\n    }\n    return super.call(arg, config, tags);\n  }\n  _call(arg, runManager, config) {\n    return this.func(arg, runManager, config);\n  }\n}","map":{"version":3,"names":["z","CallbackManager","parseCallbackConfigArg","BaseLangChain","ensureConfig","ToolInputParsingException","Error","constructor","message","output","Object","defineProperty","enumerable","configurable","writable","value","StructuredTool","lc_namespace","fields","invoke","input","config","call","arg","configArg","tags","parsed","schema","parseAsync","e","JSON","stringify","callbackManager_","configure","callbacks","metadata","verbose","runManager","handleToolStart","toJSON","undefined","runName","result","_call","handleToolError","handleToolEnd","Tool","object","string","optional","transform","obj","DynamicTool","lc_name","name","description","func","returnDirect","DynamicStructuredTool"],"sources":["/home/nikhil/legalbot/legalbot/node_modules/@langchain/core/dist/tools.js"],"sourcesContent":["import { z } from \"zod\";\nimport { CallbackManager, parseCallbackConfigArg, } from \"./callbacks/manager.js\";\nimport { BaseLangChain, } from \"./language_models/base.js\";\nimport { ensureConfig } from \"./runnables/config.js\";\n/**\n * Custom error class used to handle exceptions related to tool input parsing.\n * It extends the built-in `Error` class and adds an optional `output`\n * property that can hold the output that caused the exception.\n */\nexport class ToolInputParsingException extends Error {\n    constructor(message, output) {\n        super(message);\n        Object.defineProperty(this, \"output\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.output = output;\n    }\n}\n/**\n * Base class for Tools that accept input of any shape defined by a Zod schema.\n */\nexport class StructuredTool extends BaseLangChain {\n    get lc_namespace() {\n        return [\"langchain\", \"tools\"];\n    }\n    constructor(fields) {\n        super(fields ?? {});\n        Object.defineProperty(this, \"returnDirect\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n    }\n    /**\n     * Invokes the tool with the provided input and configuration.\n     * @param input The input for the tool.\n     * @param config Optional configuration for the tool.\n     * @returns A Promise that resolves with a string.\n     */\n    async invoke(input, config) {\n        return this.call(input, ensureConfig(config));\n    }\n    /**\n     * Calls the tool with the provided argument, configuration, and tags. It\n     * parses the input according to the schema, handles any errors, and\n     * manages callbacks.\n     * @param arg The input argument for the tool.\n     * @param configArg Optional configuration or callbacks for the tool.\n     * @param tags Optional tags for the tool.\n     * @returns A Promise that resolves with a string.\n     */\n    async call(arg, configArg, \n    /** @deprecated */\n    tags) {\n        let parsed;\n        try {\n            parsed = await this.schema.parseAsync(arg);\n        }\n        catch (e) {\n            throw new ToolInputParsingException(`Received tool input did not match expected schema`, JSON.stringify(arg));\n        }\n        const config = parseCallbackConfigArg(configArg);\n        const callbackManager_ = await CallbackManager.configure(config.callbacks, this.callbacks, config.tags || tags, this.tags, config.metadata, this.metadata, { verbose: this.verbose });\n        const runManager = await callbackManager_?.handleToolStart(this.toJSON(), typeof parsed === \"string\" ? parsed : JSON.stringify(parsed), undefined, undefined, undefined, undefined, config.runName);\n        let result;\n        try {\n            result = await this._call(parsed, runManager, config);\n        }\n        catch (e) {\n            await runManager?.handleToolError(e);\n            throw e;\n        }\n        await runManager?.handleToolEnd(result);\n        return result;\n    }\n}\n/**\n * Base class for Tools that accept input as a string.\n */\nexport class Tool extends StructuredTool {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"schema\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: z\n                .object({ input: z.string().optional() })\n                .transform((obj) => obj.input)\n        });\n    }\n    /**\n     * Calls the tool with the provided argument and callbacks. It handles\n     * string inputs specifically.\n     * @param arg The input argument for the tool, which can be a string, undefined, or an input of the tool's schema.\n     * @param callbacks Optional callbacks for the tool.\n     * @returns A Promise that resolves with a string.\n     */\n    call(arg, callbacks) {\n        return super.call(typeof arg === \"string\" || !arg ? { input: arg } : arg, callbacks);\n    }\n}\n/**\n * A tool that can be created dynamically from a function, name, and description.\n */\nexport class DynamicTool extends Tool {\n    static lc_name() {\n        return \"DynamicTool\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = fields.name;\n        this.description = fields.description;\n        this.func = fields.func;\n        this.returnDirect = fields.returnDirect ?? this.returnDirect;\n    }\n    async call(arg, configArg) {\n        const config = parseCallbackConfigArg(configArg);\n        if (config.runName === undefined) {\n            config.runName = this.name;\n        }\n        return super.call(arg, config);\n    }\n    /** @ignore */\n    async _call(input, runManager, config) {\n        return this.func(input, runManager, config);\n    }\n}\n/**\n * A tool that can be created dynamically from a function, name, and\n * description, designed to work with structured data. It extends the\n * StructuredTool class and overrides the _call method to execute the\n * provided function when the tool is called.\n */\nexport class DynamicStructuredTool extends StructuredTool {\n    static lc_name() {\n        return \"DynamicStructuredTool\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"schema\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = fields.name;\n        this.description = fields.description;\n        this.func = fields.func;\n        this.returnDirect = fields.returnDirect ?? this.returnDirect;\n        this.schema = fields.schema;\n    }\n    async call(arg, configArg, \n    /** @deprecated */\n    tags) {\n        const config = parseCallbackConfigArg(configArg);\n        if (config.runName === undefined) {\n            config.runName = this.name;\n        }\n        return super.call(arg, config, tags);\n    }\n    _call(arg, runManager, config) {\n        return this.func(arg, runManager, config);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}