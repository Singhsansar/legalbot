{"ast":null,"code":"import * as uuid from \"uuid\";\nimport flatten from \"flat\";\nimport { VectorStore } from \"@langchain/core/vectorstores\";\nimport { Document } from \"@langchain/core/documents\";\nimport { AsyncCaller } from \"@langchain/core/utils/async_caller\";\nimport { chunkArray } from \"@langchain/core/utils/chunk_array\";\nimport { maximalMarginalRelevance } from \"@langchain/core/utils/math\";\n/**\n * Class for managing and operating vector search applications with\n * Pinecone, the cloud-native high-scale vector database\n */\nexport class PineconeStore extends VectorStore {\n  _vectorstoreType() {\n    return \"pinecone\";\n  }\n  constructor(embeddings, params) {\n    super(embeddings, params);\n    Object.defineProperty(this, \"textKey\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"pineconeIndex\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"filter\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"caller\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.embeddings = embeddings;\n    const {\n      namespace,\n      pineconeIndex,\n      textKey,\n      filter,\n      ...asyncCallerArgs\n    } = params;\n    this.namespace = namespace;\n    this.pineconeIndex = pineconeIndex;\n    this.textKey = textKey ?? \"text\";\n    this.filter = filter;\n    this.caller = new AsyncCaller(asyncCallerArgs);\n  }\n  /**\n   * Method that adds documents to the Pinecone database.\n   * @param documents Array of documents to add to the Pinecone database.\n   * @param options Optional ids for the documents.\n   * @returns Promise that resolves with the ids of the added documents.\n   */\n  async addDocuments(documents, options) {\n    const texts = documents.map(({\n      pageContent\n    }) => pageContent);\n    return this.addVectors(await this.embeddings.embedDocuments(texts), documents, options);\n  }\n  /**\n   * Method that adds vectors to the Pinecone database.\n   * @param vectors Array of vectors to add to the Pinecone database.\n   * @param documents Array of documents associated with the vectors.\n   * @param options Optional ids for the vectors.\n   * @returns Promise that resolves with the ids of the added vectors.\n   */\n  async addVectors(vectors, documents, options) {\n    const ids = Array.isArray(options) ? options : options?.ids;\n    const documentIds = ids == null ? documents.map(() => uuid.v4()) : ids;\n    const pineconeVectors = vectors.map((values, idx) => {\n      // Pinecone doesn't support nested objects, so we flatten them\n      const documentMetadata = {\n        ...documents[idx].metadata\n      };\n      // preserve string arrays which are allowed\n      const stringArrays = {};\n      for (const key of Object.keys(documentMetadata)) {\n        if (Array.isArray(documentMetadata[key]) &&\n        // eslint-disable-next-line @typescript-eslint/ban-types, @typescript-eslint/no-explicit-any\n        documentMetadata[key].every(el => typeof el === \"string\")) {\n          stringArrays[key] = documentMetadata[key];\n          delete documentMetadata[key];\n        }\n      }\n      const metadata = {\n        ...flatten(documentMetadata),\n        ...stringArrays,\n        [this.textKey]: documents[idx].pageContent\n      };\n      // Pinecone doesn't support null values, so we remove them\n      for (const key of Object.keys(metadata)) {\n        if (metadata[key] == null) {\n          delete metadata[key];\n        } else if (typeof metadata[key] === \"object\" && Object.keys(metadata[key]).length === 0) {\n          delete metadata[key];\n        }\n      }\n      return {\n        id: documentIds[idx],\n        metadata,\n        values\n      };\n    });\n    const optionsNamespace = !Array.isArray(options) && options?.namespace ? options.namespace : this.namespace;\n    const namespace = this.pineconeIndex.namespace(optionsNamespace ?? \"\");\n    // Pinecone recommends a limit of 100 vectors per upsert request\n    const chunkSize = 100;\n    const chunkedVectors = chunkArray(pineconeVectors, chunkSize);\n    const batchRequests = chunkedVectors.map(chunk => this.caller.call(async () => namespace.upsert(chunk)));\n    await Promise.all(batchRequests);\n    return documentIds;\n  }\n  /**\n   * Method that deletes vectors from the Pinecone database.\n   * @param params Parameters for the delete operation.\n   * @returns Promise that resolves when the delete operation is complete.\n   */\n  async delete(params) {\n    const {\n      deleteAll,\n      ids,\n      filter\n    } = params;\n    const optionsNamespace = params.namespace ?? this.namespace;\n    const namespace = this.pineconeIndex.namespace(optionsNamespace ?? \"\");\n    if (deleteAll) {\n      await namespace.deleteAll();\n    } else if (ids) {\n      const batchSize = 1000;\n      for (let i = 0; i < ids.length; i += batchSize) {\n        const batchIds = ids.slice(i, i + batchSize);\n        await namespace.deleteMany(batchIds);\n      }\n    } else if (filter) {\n      await namespace.deleteMany(filter);\n    } else {\n      throw new Error(\"Either ids or delete_all must be provided.\");\n    }\n  }\n  async _runPineconeQuery(query, k, filter, options) {\n    if (filter && this.filter) {\n      throw new Error(\"cannot provide both `filter` and `this.filter`\");\n    }\n    const _filter = filter ?? this.filter;\n    let optionsNamespace = this.namespace ?? \"\";\n    if (_filter && \"namespace\" in _filter) {\n      optionsNamespace = _filter.namespace;\n      delete _filter.namespace;\n    }\n    const namespace = this.pineconeIndex.namespace(optionsNamespace ?? \"\");\n    const results = await namespace.query({\n      includeMetadata: true,\n      topK: k,\n      vector: query,\n      filter: _filter,\n      ...options\n    });\n    return results;\n  }\n  /**\n   * Method that performs a similarity search in the Pinecone database and\n   * returns the results along with their scores.\n   * @param query Query vector for the similarity search.\n   * @param k Number of top results to return.\n   * @param filter Optional filter to apply to the search.\n   * @returns Promise that resolves with an array of documents and their scores.\n   */\n  async similaritySearchVectorWithScore(query, k, filter) {\n    const results = await this._runPineconeQuery(query, k, filter);\n    const result = [];\n    if (results.matches) {\n      for (const res of results.matches) {\n        const {\n          [this.textKey]: pageContent,\n          ...metadata\n        } = res.metadata ?? {};\n        if (res.score) {\n          result.push([new Document({\n            metadata,\n            pageContent\n          }), res.score]);\n        }\n      }\n    }\n    return result;\n  }\n  /**\n   * Return documents selected using the maximal marginal relevance.\n   * Maximal marginal relevance optimizes for similarity to the query AND diversity\n   * among selected documents.\n   *\n   * @param {string} query - Text to look up documents similar to.\n   * @param {number} options.k - Number of documents to return.\n   * @param {number} options.fetchK=20 - Number of documents to fetch before passing to the MMR algorithm.\n   * @param {number} options.lambda=0.5 - Number between 0 and 1 that determines the degree of diversity among the results,\n   *                 where 0 corresponds to maximum diversity and 1 to minimum diversity.\n   * @param {PineconeMetadata} options.filter - Optional filter to apply to the search.\n   *\n   * @returns {Promise<DocumentInterface[]>} - List of documents selected by maximal marginal relevance.\n   */\n  async maxMarginalRelevanceSearch(query, options) {\n    const queryEmbedding = await this.embeddings.embedQuery(query);\n    const results = await this._runPineconeQuery(queryEmbedding, options.fetchK ?? 20, options.filter, {\n      includeValues: true\n    });\n    const matches = results?.matches ?? [];\n    const embeddingList = matches.map(match => match.values);\n    const mmrIndexes = maximalMarginalRelevance(queryEmbedding, embeddingList, options.lambda, options.k);\n    const topMmrMatches = mmrIndexes.map(idx => matches[idx]);\n    const finalResult = [];\n    for (const res of topMmrMatches) {\n      const {\n        [this.textKey]: pageContent,\n        ...metadata\n      } = res.metadata ?? {};\n      if (res.score) {\n        finalResult.push(new Document({\n          metadata,\n          pageContent\n        }));\n      }\n    }\n    return finalResult;\n  }\n  /**\n   * Static method that creates a new instance of the PineconeStore class\n   * from texts.\n   * @param texts Array of texts to add to the Pinecone database.\n   * @param metadatas Metadata associated with the texts.\n   * @param embeddings Embeddings to use for the texts.\n   * @param dbConfig Configuration for the Pinecone database.\n   * @returns Promise that resolves with a new instance of the PineconeStore class.\n   */\n  static async fromTexts(texts, metadatas, embeddings, dbConfig) {\n    const docs = [];\n    for (let i = 0; i < texts.length; i += 1) {\n      const metadata = Array.isArray(metadatas) ? metadatas[i] : metadatas;\n      const newDoc = new Document({\n        pageContent: texts[i],\n        metadata\n      });\n      docs.push(newDoc);\n    }\n    const args = {\n      pineconeIndex: dbConfig.pineconeIndex,\n      textKey: dbConfig.textKey,\n      namespace: dbConfig.namespace\n    };\n    return PineconeStore.fromDocuments(docs, embeddings, args);\n  }\n  /**\n   * Static method that creates a new instance of the PineconeStore class\n   * from documents.\n   * @param docs Array of documents to add to the Pinecone database.\n   * @param embeddings Embeddings to use for the documents.\n   * @param dbConfig Configuration for the Pinecone database.\n   * @returns Promise that resolves with a new instance of the PineconeStore class.\n   */\n  static async fromDocuments(docs, embeddings, dbConfig) {\n    const args = dbConfig;\n    args.textKey = dbConfig.textKey ?? \"text\";\n    const instance = new this(embeddings, args);\n    await instance.addDocuments(docs);\n    return instance;\n  }\n  /**\n   * Static method that creates a new instance of the PineconeStore class\n   * from an existing index.\n   * @param embeddings Embeddings to use for the documents.\n   * @param dbConfig Configuration for the Pinecone database.\n   * @returns Promise that resolves with a new instance of the PineconeStore class.\n   */\n  static async fromExistingIndex(embeddings, dbConfig) {\n    const instance = new this(embeddings, dbConfig);\n    return instance;\n  }\n}","map":{"version":3,"names":["uuid","flatten","VectorStore","Document","AsyncCaller","chunkArray","maximalMarginalRelevance","PineconeStore","_vectorstoreType","constructor","embeddings","params","Object","defineProperty","enumerable","configurable","writable","value","namespace","pineconeIndex","textKey","filter","asyncCallerArgs","caller","addDocuments","documents","options","texts","map","pageContent","addVectors","embedDocuments","vectors","ids","Array","isArray","documentIds","v4","pineconeVectors","values","idx","documentMetadata","metadata","stringArrays","key","keys","every","el","length","id","optionsNamespace","chunkSize","chunkedVectors","batchRequests","chunk","call","upsert","Promise","all","delete","deleteAll","batchSize","i","batchIds","slice","deleteMany","Error","_runPineconeQuery","query","k","_filter","results","includeMetadata","topK","vector","similaritySearchVectorWithScore","result","matches","res","score","push","maxMarginalRelevanceSearch","queryEmbedding","embedQuery","fetchK","includeValues","embeddingList","match","mmrIndexes","lambda","topMmrMatches","finalResult","fromTexts","metadatas","dbConfig","docs","newDoc","args","fromDocuments","instance","fromExistingIndex"],"sources":["/home/nikhil/legalbot/legalbot/node_modules/@langchain/pinecone/dist/vectorstores.js"],"sourcesContent":["import * as uuid from \"uuid\";\nimport flatten from \"flat\";\nimport { VectorStore, } from \"@langchain/core/vectorstores\";\nimport { Document } from \"@langchain/core/documents\";\nimport { AsyncCaller, } from \"@langchain/core/utils/async_caller\";\nimport { chunkArray } from \"@langchain/core/utils/chunk_array\";\nimport { maximalMarginalRelevance } from \"@langchain/core/utils/math\";\n/**\n * Class for managing and operating vector search applications with\n * Pinecone, the cloud-native high-scale vector database\n */\nexport class PineconeStore extends VectorStore {\n    _vectorstoreType() {\n        return \"pinecone\";\n    }\n    constructor(embeddings, params) {\n        super(embeddings, params);\n        Object.defineProperty(this, \"textKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"pineconeIndex\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"filter\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"caller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.embeddings = embeddings;\n        const { namespace, pineconeIndex, textKey, filter, ...asyncCallerArgs } = params;\n        this.namespace = namespace;\n        this.pineconeIndex = pineconeIndex;\n        this.textKey = textKey ?? \"text\";\n        this.filter = filter;\n        this.caller = new AsyncCaller(asyncCallerArgs);\n    }\n    /**\n     * Method that adds documents to the Pinecone database.\n     * @param documents Array of documents to add to the Pinecone database.\n     * @param options Optional ids for the documents.\n     * @returns Promise that resolves with the ids of the added documents.\n     */\n    async addDocuments(documents, options) {\n        const texts = documents.map(({ pageContent }) => pageContent);\n        return this.addVectors(await this.embeddings.embedDocuments(texts), documents, options);\n    }\n    /**\n     * Method that adds vectors to the Pinecone database.\n     * @param vectors Array of vectors to add to the Pinecone database.\n     * @param documents Array of documents associated with the vectors.\n     * @param options Optional ids for the vectors.\n     * @returns Promise that resolves with the ids of the added vectors.\n     */\n    async addVectors(vectors, documents, options) {\n        const ids = Array.isArray(options) ? options : options?.ids;\n        const documentIds = ids == null ? documents.map(() => uuid.v4()) : ids;\n        const pineconeVectors = vectors.map((values, idx) => {\n            // Pinecone doesn't support nested objects, so we flatten them\n            const documentMetadata = { ...documents[idx].metadata };\n            // preserve string arrays which are allowed\n            const stringArrays = {};\n            for (const key of Object.keys(documentMetadata)) {\n                if (Array.isArray(documentMetadata[key]) &&\n                    // eslint-disable-next-line @typescript-eslint/ban-types, @typescript-eslint/no-explicit-any\n                    documentMetadata[key].every((el) => typeof el === \"string\")) {\n                    stringArrays[key] = documentMetadata[key];\n                    delete documentMetadata[key];\n                }\n            }\n            const metadata = {\n                ...flatten(documentMetadata),\n                ...stringArrays,\n                [this.textKey]: documents[idx].pageContent,\n            };\n            // Pinecone doesn't support null values, so we remove them\n            for (const key of Object.keys(metadata)) {\n                if (metadata[key] == null) {\n                    delete metadata[key];\n                }\n                else if (typeof metadata[key] === \"object\" &&\n                    Object.keys(metadata[key]).length === 0) {\n                    delete metadata[key];\n                }\n            }\n            return {\n                id: documentIds[idx],\n                metadata,\n                values,\n            };\n        });\n        const optionsNamespace = !Array.isArray(options) && options?.namespace\n            ? options.namespace\n            : this.namespace;\n        const namespace = this.pineconeIndex.namespace(optionsNamespace ?? \"\");\n        // Pinecone recommends a limit of 100 vectors per upsert request\n        const chunkSize = 100;\n        const chunkedVectors = chunkArray(pineconeVectors, chunkSize);\n        const batchRequests = chunkedVectors.map((chunk) => this.caller.call(async () => namespace.upsert(chunk)));\n        await Promise.all(batchRequests);\n        return documentIds;\n    }\n    /**\n     * Method that deletes vectors from the Pinecone database.\n     * @param params Parameters for the delete operation.\n     * @returns Promise that resolves when the delete operation is complete.\n     */\n    async delete(params) {\n        const { deleteAll, ids, filter } = params;\n        const optionsNamespace = params.namespace ?? this.namespace;\n        const namespace = this.pineconeIndex.namespace(optionsNamespace ?? \"\");\n        if (deleteAll) {\n            await namespace.deleteAll();\n        }\n        else if (ids) {\n            const batchSize = 1000;\n            for (let i = 0; i < ids.length; i += batchSize) {\n                const batchIds = ids.slice(i, i + batchSize);\n                await namespace.deleteMany(batchIds);\n            }\n        }\n        else if (filter) {\n            await namespace.deleteMany(filter);\n        }\n        else {\n            throw new Error(\"Either ids or delete_all must be provided.\");\n        }\n    }\n    async _runPineconeQuery(query, k, filter, options) {\n        if (filter && this.filter) {\n            throw new Error(\"cannot provide both `filter` and `this.filter`\");\n        }\n        const _filter = filter ?? this.filter;\n        let optionsNamespace = this.namespace ?? \"\";\n        if (_filter && \"namespace\" in _filter) {\n            optionsNamespace = _filter.namespace;\n            delete _filter.namespace;\n        }\n        const namespace = this.pineconeIndex.namespace(optionsNamespace ?? \"\");\n        const results = await namespace.query({\n            includeMetadata: true,\n            topK: k,\n            vector: query,\n            filter: _filter,\n            ...options,\n        });\n        return results;\n    }\n    /**\n     * Method that performs a similarity search in the Pinecone database and\n     * returns the results along with their scores.\n     * @param query Query vector for the similarity search.\n     * @param k Number of top results to return.\n     * @param filter Optional filter to apply to the search.\n     * @returns Promise that resolves with an array of documents and their scores.\n     */\n    async similaritySearchVectorWithScore(query, k, filter) {\n        const results = await this._runPineconeQuery(query, k, filter);\n        const result = [];\n        if (results.matches) {\n            for (const res of results.matches) {\n                const { [this.textKey]: pageContent, ...metadata } = (res.metadata ??\n                    {});\n                if (res.score) {\n                    result.push([new Document({ metadata, pageContent }), res.score]);\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Return documents selected using the maximal marginal relevance.\n     * Maximal marginal relevance optimizes for similarity to the query AND diversity\n     * among selected documents.\n     *\n     * @param {string} query - Text to look up documents similar to.\n     * @param {number} options.k - Number of documents to return.\n     * @param {number} options.fetchK=20 - Number of documents to fetch before passing to the MMR algorithm.\n     * @param {number} options.lambda=0.5 - Number between 0 and 1 that determines the degree of diversity among the results,\n     *                 where 0 corresponds to maximum diversity and 1 to minimum diversity.\n     * @param {PineconeMetadata} options.filter - Optional filter to apply to the search.\n     *\n     * @returns {Promise<DocumentInterface[]>} - List of documents selected by maximal marginal relevance.\n     */\n    async maxMarginalRelevanceSearch(query, options) {\n        const queryEmbedding = await this.embeddings.embedQuery(query);\n        const results = await this._runPineconeQuery(queryEmbedding, options.fetchK ?? 20, options.filter, { includeValues: true });\n        const matches = results?.matches ?? [];\n        const embeddingList = matches.map((match) => match.values);\n        const mmrIndexes = maximalMarginalRelevance(queryEmbedding, embeddingList, options.lambda, options.k);\n        const topMmrMatches = mmrIndexes.map((idx) => matches[idx]);\n        const finalResult = [];\n        for (const res of topMmrMatches) {\n            const { [this.textKey]: pageContent, ...metadata } = (res.metadata ??\n                {});\n            if (res.score) {\n                finalResult.push(new Document({ metadata, pageContent }));\n            }\n        }\n        return finalResult;\n    }\n    /**\n     * Static method that creates a new instance of the PineconeStore class\n     * from texts.\n     * @param texts Array of texts to add to the Pinecone database.\n     * @param metadatas Metadata associated with the texts.\n     * @param embeddings Embeddings to use for the texts.\n     * @param dbConfig Configuration for the Pinecone database.\n     * @returns Promise that resolves with a new instance of the PineconeStore class.\n     */\n    static async fromTexts(texts, metadatas, embeddings, dbConfig) {\n        const docs = [];\n        for (let i = 0; i < texts.length; i += 1) {\n            const metadata = Array.isArray(metadatas) ? metadatas[i] : metadatas;\n            const newDoc = new Document({\n                pageContent: texts[i],\n                metadata,\n            });\n            docs.push(newDoc);\n        }\n        const args = {\n            pineconeIndex: dbConfig.pineconeIndex,\n            textKey: dbConfig.textKey,\n            namespace: dbConfig.namespace,\n        };\n        return PineconeStore.fromDocuments(docs, embeddings, args);\n    }\n    /**\n     * Static method that creates a new instance of the PineconeStore class\n     * from documents.\n     * @param docs Array of documents to add to the Pinecone database.\n     * @param embeddings Embeddings to use for the documents.\n     * @param dbConfig Configuration for the Pinecone database.\n     * @returns Promise that resolves with a new instance of the PineconeStore class.\n     */\n    static async fromDocuments(docs, embeddings, dbConfig) {\n        const args = dbConfig;\n        args.textKey = dbConfig.textKey ?? \"text\";\n        const instance = new this(embeddings, args);\n        await instance.addDocuments(docs);\n        return instance;\n    }\n    /**\n     * Static method that creates a new instance of the PineconeStore class\n     * from an existing index.\n     * @param embeddings Embeddings to use for the documents.\n     * @param dbConfig Configuration for the Pinecone database.\n     * @returns Promise that resolves with a new instance of the PineconeStore class.\n     */\n    static async fromExistingIndex(embeddings, dbConfig) {\n        const instance = new this(embeddings, dbConfig);\n        return instance;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}