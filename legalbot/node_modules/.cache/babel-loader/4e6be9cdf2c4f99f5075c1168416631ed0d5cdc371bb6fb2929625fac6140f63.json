{"ast":null,"code":"import { GoogleGenerativeAI } from \"@google/generative-ai\";\nimport { getEnvironmentVariable } from \"@langchain/core/utils/env\";\nimport { Embeddings } from \"@langchain/core/embeddings\";\nimport { chunkArray } from \"@langchain/core/utils/chunk_array\";\n/**\n * Class that extends the Embeddings class and provides methods for\n * generating embeddings using the Google Palm API.\n * @example\n * ```typescript\n * const model = new GoogleGenerativeAIEmbeddings({\n *   apiKey: \"<YOUR API KEY>\",\n *   modelName: \"embedding-001\",\n * });\n *\n * // Embed a single query\n * const res = await model.embedQuery(\n *   \"What would be a good company name for a company that makes colorful socks?\"\n * );\n * console.log({ res });\n *\n * // Embed multiple documents\n * const documentRes = await model.embedDocuments([\"Hello world\", \"Bye bye\"]);\n * console.log({ documentRes });\n * ```\n */\nexport class GoogleGenerativeAIEmbeddings extends Embeddings {\n  constructor(fields) {\n    super(fields ?? {});\n    Object.defineProperty(this, \"apiKey\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"modelName\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"embedding-001\"\n    });\n    Object.defineProperty(this, \"taskType\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"title\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"stripNewLines\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"maxBatchSize\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 100\n    }); // Max batch size for embedDocuments set by GenerativeModel client's batchEmbedContents call\n    Object.defineProperty(this, \"client\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.modelName = fields?.modelName?.replace(/^models\\//, \"\") ?? this.modelName;\n    this.taskType = fields?.taskType ?? this.taskType;\n    this.title = fields?.title ?? this.title;\n    if (this.title && this.taskType !== \"RETRIEVAL_DOCUMENT\") {\n      throw new Error(\"title can only be sepcified with TaskType.RETRIEVAL_DOCUMENT\");\n    }\n    this.apiKey = fields?.apiKey ?? getEnvironmentVariable(\"GOOGLE_API_KEY\");\n    if (!this.apiKey) {\n      throw new Error(\"Please set an API key for Google GenerativeAI \" + \"in the environmentb variable GOOGLE_API_KEY \" + \"or in the `apiKey` field of the \" + \"GoogleGenerativeAIEmbeddings constructor\");\n    }\n    this.client = new GoogleGenerativeAI(this.apiKey).getGenerativeModel({\n      model: this.modelName\n    });\n  }\n  _convertToContent(text) {\n    const cleanedText = this.stripNewLines ? text.replace(/\\n/g, \" \") : text;\n    return {\n      content: {\n        role: \"user\",\n        parts: [{\n          text: cleanedText\n        }]\n      },\n      taskType: this.taskType,\n      title: this.title\n    };\n  }\n  async _embedQueryContent(text) {\n    const req = this._convertToContent(text);\n    const res = await this.client.embedContent(req);\n    return res.embedding.values ?? [];\n  }\n  async _embedDocumentsContent(documents) {\n    const batchEmbedChunks = chunkArray(documents, this.maxBatchSize);\n    const batchEmbedRequests = batchEmbedChunks.map(chunk => ({\n      requests: chunk.map(doc => this._convertToContent(doc))\n    }));\n    const responses = await Promise.allSettled(batchEmbedRequests.map(req => this.client.batchEmbedContents(req)));\n    const embeddings = responses.flatMap((res, idx) => {\n      if (res.status === \"fulfilled\") {\n        return res.value.embeddings.map(e => e.values || []);\n      } else {\n        return Array(batchEmbedChunks[idx].length).fill([]);\n      }\n    });\n    return embeddings;\n  }\n  /**\n   * Method that takes a document as input and returns a promise that\n   * resolves to an embedding for the document. It calls the _embedText\n   * method with the document as the input.\n   * @param document Document for which to generate an embedding.\n   * @returns Promise that resolves to an embedding for the input document.\n   */\n  embedQuery(document) {\n    return this.caller.call(this._embedQueryContent.bind(this), document);\n  }\n  /**\n   * Method that takes an array of documents as input and returns a promise\n   * that resolves to a 2D array of embeddings for each document. It calls\n   * the _embedText method for each document in the array.\n   * @param documents Array of documents for which to generate embeddings.\n   * @returns Promise that resolves to a 2D array of embeddings for each input document.\n   */\n  embedDocuments(documents) {\n    return this.caller.call(this._embedDocumentsContent.bind(this), documents);\n  }\n}","map":{"version":3,"names":["GoogleGenerativeAI","getEnvironmentVariable","Embeddings","chunkArray","GoogleGenerativeAIEmbeddings","constructor","fields","Object","defineProperty","enumerable","configurable","writable","value","modelName","replace","taskType","title","Error","apiKey","client","getGenerativeModel","model","_convertToContent","text","cleanedText","stripNewLines","content","role","parts","_embedQueryContent","req","res","embedContent","embedding","values","_embedDocumentsContent","documents","batchEmbedChunks","maxBatchSize","batchEmbedRequests","map","chunk","requests","doc","responses","Promise","allSettled","batchEmbedContents","embeddings","flatMap","idx","status","e","Array","length","fill","embedQuery","document","caller","call","bind","embedDocuments"],"sources":["/home/nikhil/legalbot/legalbot/node_modules/@langchain/google-genai/dist/embeddings.js"],"sourcesContent":["import { GoogleGenerativeAI } from \"@google/generative-ai\";\nimport { getEnvironmentVariable } from \"@langchain/core/utils/env\";\nimport { Embeddings } from \"@langchain/core/embeddings\";\nimport { chunkArray } from \"@langchain/core/utils/chunk_array\";\n/**\n * Class that extends the Embeddings class and provides methods for\n * generating embeddings using the Google Palm API.\n * @example\n * ```typescript\n * const model = new GoogleGenerativeAIEmbeddings({\n *   apiKey: \"<YOUR API KEY>\",\n *   modelName: \"embedding-001\",\n * });\n *\n * // Embed a single query\n * const res = await model.embedQuery(\n *   \"What would be a good company name for a company that makes colorful socks?\"\n * );\n * console.log({ res });\n *\n * // Embed multiple documents\n * const documentRes = await model.embedDocuments([\"Hello world\", \"Bye bye\"]);\n * console.log({ documentRes });\n * ```\n */\nexport class GoogleGenerativeAIEmbeddings extends Embeddings {\n    constructor(fields) {\n        super(fields ?? {});\n        Object.defineProperty(this, \"apiKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"modelName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"embedding-001\"\n        });\n        Object.defineProperty(this, \"taskType\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"title\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"stripNewLines\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"maxBatchSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 100\n        }); // Max batch size for embedDocuments set by GenerativeModel client's batchEmbedContents call\n        Object.defineProperty(this, \"client\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.modelName =\n            fields?.modelName?.replace(/^models\\//, \"\") ?? this.modelName;\n        this.taskType = fields?.taskType ?? this.taskType;\n        this.title = fields?.title ?? this.title;\n        if (this.title && this.taskType !== \"RETRIEVAL_DOCUMENT\") {\n            throw new Error(\"title can only be sepcified with TaskType.RETRIEVAL_DOCUMENT\");\n        }\n        this.apiKey = fields?.apiKey ?? getEnvironmentVariable(\"GOOGLE_API_KEY\");\n        if (!this.apiKey) {\n            throw new Error(\"Please set an API key for Google GenerativeAI \" +\n                \"in the environmentb variable GOOGLE_API_KEY \" +\n                \"or in the `apiKey` field of the \" +\n                \"GoogleGenerativeAIEmbeddings constructor\");\n        }\n        this.client = new GoogleGenerativeAI(this.apiKey).getGenerativeModel({\n            model: this.modelName,\n        });\n    }\n    _convertToContent(text) {\n        const cleanedText = this.stripNewLines ? text.replace(/\\n/g, \" \") : text;\n        return {\n            content: { role: \"user\", parts: [{ text: cleanedText }] },\n            taskType: this.taskType,\n            title: this.title,\n        };\n    }\n    async _embedQueryContent(text) {\n        const req = this._convertToContent(text);\n        const res = await this.client.embedContent(req);\n        return res.embedding.values ?? [];\n    }\n    async _embedDocumentsContent(documents) {\n        const batchEmbedChunks = chunkArray(documents, this.maxBatchSize);\n        const batchEmbedRequests = batchEmbedChunks.map((chunk) => ({\n            requests: chunk.map((doc) => this._convertToContent(doc)),\n        }));\n        const responses = await Promise.allSettled(batchEmbedRequests.map((req) => this.client.batchEmbedContents(req)));\n        const embeddings = responses.flatMap((res, idx) => {\n            if (res.status === \"fulfilled\") {\n                return res.value.embeddings.map((e) => e.values || []);\n            }\n            else {\n                return Array(batchEmbedChunks[idx].length).fill([]);\n            }\n        });\n        return embeddings;\n    }\n    /**\n     * Method that takes a document as input and returns a promise that\n     * resolves to an embedding for the document. It calls the _embedText\n     * method with the document as the input.\n     * @param document Document for which to generate an embedding.\n     * @returns Promise that resolves to an embedding for the input document.\n     */\n    embedQuery(document) {\n        return this.caller.call(this._embedQueryContent.bind(this), document);\n    }\n    /**\n     * Method that takes an array of documents as input and returns a promise\n     * that resolves to a 2D array of embeddings for each document. It calls\n     * the _embedText method for each document in the array.\n     * @param documents Array of documents for which to generate embeddings.\n     * @returns Promise that resolves to a 2D array of embeddings for each input document.\n     */\n    embedDocuments(documents) {\n        return this.caller.call(this._embedDocumentsContent.bind(this), documents);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}