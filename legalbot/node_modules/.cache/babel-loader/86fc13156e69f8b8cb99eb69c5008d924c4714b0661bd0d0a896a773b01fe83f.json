{"ast":null,"code":"import { BaseOutputParser } from \"./base.js\";\nimport { isBaseMessage, isBaseMessageChunk } from \"../messages/index.js\";\nimport { GenerationChunk, ChatGenerationChunk } from \"../outputs.js\";\nimport { deepCompareStrict } from \"../utils/@cfworker/json-schema/index.js\";\n/**\n * Class to parse the output of an LLM call that also allows streaming inputs.\n */\nexport class BaseTransformOutputParser extends BaseOutputParser {\n  async *_transform(inputGenerator) {\n    for await (const chunk of inputGenerator) {\n      if (typeof chunk === \"string\") {\n        yield this.parseResult([{\n          text: chunk\n        }]);\n      } else {\n        yield this.parseResult([{\n          message: chunk,\n          text: this._baseMessageToString(chunk)\n        }]);\n      }\n    }\n  }\n  /**\n   * Transforms an asynchronous generator of input into an asynchronous\n   * generator of parsed output.\n   * @param inputGenerator An asynchronous generator of input.\n   * @param options A configuration object.\n   * @returns An asynchronous generator of parsed output.\n   */\n  async *transform(inputGenerator, options) {\n    yield* this._transformStreamWithConfig(inputGenerator, this._transform.bind(this), {\n      ...options,\n      runType: \"parser\"\n    });\n  }\n}\n/**\n * A base class for output parsers that can handle streaming input. It\n * extends the `BaseTransformOutputParser` class and provides a method for\n * converting parsed outputs into a diff format.\n */\nexport class BaseCumulativeTransformOutputParser extends BaseTransformOutputParser {\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"diff\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    this.diff = fields?.diff ?? this.diff;\n  }\n  async *_transform(inputGenerator) {\n    let prevParsed;\n    let accGen;\n    for await (const chunk of inputGenerator) {\n      if (typeof chunk !== \"string\" && typeof chunk.content !== \"string\") {\n        throw new Error(\"Cannot handle non-string output.\");\n      }\n      let chunkGen;\n      if (isBaseMessageChunk(chunk)) {\n        if (typeof chunk.content !== \"string\") {\n          throw new Error(\"Cannot handle non-string message output.\");\n        }\n        chunkGen = new ChatGenerationChunk({\n          message: chunk,\n          text: chunk.content\n        });\n      } else if (isBaseMessage(chunk)) {\n        if (typeof chunk.content !== \"string\") {\n          throw new Error(\"Cannot handle non-string message output.\");\n        }\n        chunkGen = new ChatGenerationChunk({\n          message: chunk.toChunk(),\n          text: chunk.content\n        });\n      } else {\n        chunkGen = new GenerationChunk({\n          text: chunk\n        });\n      }\n      if (accGen === undefined) {\n        accGen = chunkGen;\n      } else {\n        accGen = accGen.concat(chunkGen);\n      }\n      const parsed = await this.parsePartialResult([accGen]);\n      if (parsed !== undefined && parsed !== null && !deepCompareStrict(parsed, prevParsed)) {\n        if (this.diff) {\n          yield this._diff(prevParsed, parsed);\n        } else {\n          yield parsed;\n        }\n        prevParsed = parsed;\n      }\n    }\n  }\n}","map":{"version":3,"names":["BaseOutputParser","isBaseMessage","isBaseMessageChunk","GenerationChunk","ChatGenerationChunk","deepCompareStrict","BaseTransformOutputParser","_transform","inputGenerator","chunk","parseResult","text","message","_baseMessageToString","transform","options","_transformStreamWithConfig","bind","runType","BaseCumulativeTransformOutputParser","constructor","fields","Object","defineProperty","enumerable","configurable","writable","value","diff","prevParsed","accGen","content","Error","chunkGen","toChunk","undefined","concat","parsed","parsePartialResult","_diff"],"sources":["/home/nikhil/legalbot/legalbot/node_modules/@langchain/core/dist/output_parsers/transform.js"],"sourcesContent":["import { BaseOutputParser } from \"./base.js\";\nimport { isBaseMessage, isBaseMessageChunk, } from \"../messages/index.js\";\nimport { GenerationChunk, ChatGenerationChunk, } from \"../outputs.js\";\nimport { deepCompareStrict } from \"../utils/@cfworker/json-schema/index.js\";\n/**\n * Class to parse the output of an LLM call that also allows streaming inputs.\n */\nexport class BaseTransformOutputParser extends BaseOutputParser {\n    async *_transform(inputGenerator) {\n        for await (const chunk of inputGenerator) {\n            if (typeof chunk === \"string\") {\n                yield this.parseResult([{ text: chunk }]);\n            }\n            else {\n                yield this.parseResult([\n                    {\n                        message: chunk,\n                        text: this._baseMessageToString(chunk),\n                    },\n                ]);\n            }\n        }\n    }\n    /**\n     * Transforms an asynchronous generator of input into an asynchronous\n     * generator of parsed output.\n     * @param inputGenerator An asynchronous generator of input.\n     * @param options A configuration object.\n     * @returns An asynchronous generator of parsed output.\n     */\n    async *transform(inputGenerator, options) {\n        yield* this._transformStreamWithConfig(inputGenerator, this._transform.bind(this), {\n            ...options,\n            runType: \"parser\",\n        });\n    }\n}\n/**\n * A base class for output parsers that can handle streaming input. It\n * extends the `BaseTransformOutputParser` class and provides a method for\n * converting parsed outputs into a diff format.\n */\nexport class BaseCumulativeTransformOutputParser extends BaseTransformOutputParser {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"diff\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        this.diff = fields?.diff ?? this.diff;\n    }\n    async *_transform(inputGenerator) {\n        let prevParsed;\n        let accGen;\n        for await (const chunk of inputGenerator) {\n            if (typeof chunk !== \"string\" && typeof chunk.content !== \"string\") {\n                throw new Error(\"Cannot handle non-string output.\");\n            }\n            let chunkGen;\n            if (isBaseMessageChunk(chunk)) {\n                if (typeof chunk.content !== \"string\") {\n                    throw new Error(\"Cannot handle non-string message output.\");\n                }\n                chunkGen = new ChatGenerationChunk({\n                    message: chunk,\n                    text: chunk.content,\n                });\n            }\n            else if (isBaseMessage(chunk)) {\n                if (typeof chunk.content !== \"string\") {\n                    throw new Error(\"Cannot handle non-string message output.\");\n                }\n                chunkGen = new ChatGenerationChunk({\n                    message: chunk.toChunk(),\n                    text: chunk.content,\n                });\n            }\n            else {\n                chunkGen = new GenerationChunk({ text: chunk });\n            }\n            if (accGen === undefined) {\n                accGen = chunkGen;\n            }\n            else {\n                accGen = accGen.concat(chunkGen);\n            }\n            const parsed = await this.parsePartialResult([accGen]);\n            if (parsed !== undefined &&\n                parsed !== null &&\n                !deepCompareStrict(parsed, prevParsed)) {\n                if (this.diff) {\n                    yield this._diff(prevParsed, parsed);\n                }\n                else {\n                    yield parsed;\n                }\n                prevParsed = parsed;\n            }\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}