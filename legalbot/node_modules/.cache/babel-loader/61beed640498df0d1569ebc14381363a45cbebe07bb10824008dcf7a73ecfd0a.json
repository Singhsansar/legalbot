{"ast":null,"code":"import { similarity as ml_distance_similarity, distance as ml_distance } from \"ml-distance\";\n/**\n * Apply a row-wise function between two matrices with the same number of columns.\n *\n * @param {number[][]} X - The first matrix.\n * @param {number[][]} Y - The second matrix.\n * @param {VectorFunction} func - The function to apply.\n *\n * @throws {Error} If the number of columns in X and Y are not the same.\n *\n * @returns {number[][] | [[]]} A matrix where each row represents the result of applying the function between the corresponding rows of X and Y.\n */\nexport function matrixFunc(X, Y, func) {\n  if (X.length === 0 || X[0].length === 0 || Y.length === 0 || Y[0].length === 0) {\n    return [[]];\n  }\n  if (X[0].length !== Y[0].length) {\n    throw new Error(`Number of columns in X and Y must be the same. X has shape ${[X.length, X[0].length]} and Y has shape ${[Y.length, Y[0].length]}.`);\n  }\n  return X.map(xVector => Y.map(yVector => func(xVector, yVector)).map(similarity => Number.isNaN(similarity) ? 0 : similarity));\n}\nexport function normalize(M, similarity = false) {\n  const max = matrixMaxVal(M);\n  return M.map(row => row.map(val => similarity ? 1 - val / max : val / max));\n}\n/**\n * This function calculates the row-wise cosine similarity between two matrices with the same number of columns.\n *\n * @param {number[][]} X - The first matrix.\n * @param {number[][]} Y - The second matrix.\n *\n * @throws {Error} If the number of columns in X and Y are not the same.\n *\n * @returns {number[][] | [[]]} A matrix where each row represents the cosine similarity values between the corresponding rows of X and Y.\n */\nexport function cosineSimilarity(X, Y) {\n  return matrixFunc(X, Y, ml_distance_similarity.cosine);\n}\nexport function innerProduct(X, Y) {\n  return matrixFunc(X, Y, ml_distance.innerProduct);\n}\nexport function euclideanDistance(X, Y) {\n  return matrixFunc(X, Y, ml_distance.euclidean);\n}\n/**\n * This function implements the Maximal Marginal Relevance algorithm\n * to select a set of embeddings that maximizes the diversity and relevance to a query embedding.\n *\n * @param {number[]|number[][]} queryEmbedding - The query embedding.\n * @param {number[][]} embeddingList - The list of embeddings to select from.\n * @param {number} [lambda=0.5] - The trade-off parameter between relevance and diversity.\n * @param {number} [k=4] - The maximum number of embeddings to select.\n *\n * @returns {number[]} The indexes of the selected embeddings in the embeddingList.\n */\nexport function maximalMarginalRelevance(queryEmbedding, embeddingList, lambda = 0.5, k = 4) {\n  if (Math.min(k, embeddingList.length) <= 0) {\n    return [];\n  }\n  const queryEmbeddingExpanded = Array.isArray(queryEmbedding[0]) ? queryEmbedding : [queryEmbedding];\n  const similarityToQuery = cosineSimilarity(queryEmbeddingExpanded, embeddingList)[0];\n  const mostSimilarEmbeddingIndex = argMax(similarityToQuery).maxIndex;\n  const selectedEmbeddings = [embeddingList[mostSimilarEmbeddingIndex]];\n  const selectedEmbeddingsIndexes = [mostSimilarEmbeddingIndex];\n  while (selectedEmbeddingsIndexes.length < Math.min(k, embeddingList.length)) {\n    let bestScore = -Infinity;\n    let bestIndex = -1;\n    const similarityToSelected = cosineSimilarity(embeddingList, selectedEmbeddings);\n    similarityToQuery.forEach((queryScore, queryScoreIndex) => {\n      if (selectedEmbeddingsIndexes.includes(queryScoreIndex)) {\n        return;\n      }\n      const maxSimilarityToSelected = Math.max(...similarityToSelected[queryScoreIndex]);\n      const score = lambda * queryScore - (1 - lambda) * maxSimilarityToSelected;\n      if (score > bestScore) {\n        bestScore = score;\n        bestIndex = queryScoreIndex;\n      }\n    });\n    selectedEmbeddings.push(embeddingList[bestIndex]);\n    selectedEmbeddingsIndexes.push(bestIndex);\n  }\n  return selectedEmbeddingsIndexes;\n}\n/**\n * Finds the index of the maximum value in the given array.\n * @param {number[]} array - The input array.\n *\n * @returns {number} The index of the maximum value in the array. If the array is empty, returns -1.\n */\nfunction argMax(array) {\n  if (array.length === 0) {\n    return {\n      maxIndex: -1,\n      maxValue: NaN\n    };\n  }\n  let maxValue = array[0];\n  let maxIndex = 0;\n  for (let i = 1; i < array.length; i += 1) {\n    if (array[i] > maxValue) {\n      maxIndex = i;\n      maxValue = array[i];\n    }\n  }\n  return {\n    maxIndex,\n    maxValue\n  };\n}\nfunction matrixMaxVal(arrays) {\n  return arrays.reduce((acc, array) => Math.max(acc, argMax(array).maxValue), 0);\n}","map":{"version":3,"names":["similarity","ml_distance_similarity","distance","ml_distance","matrixFunc","X","Y","func","length","Error","map","xVector","yVector","Number","isNaN","normalize","M","max","matrixMaxVal","row","val","cosineSimilarity","cosine","innerProduct","euclideanDistance","euclidean","maximalMarginalRelevance","queryEmbedding","embeddingList","lambda","k","Math","min","queryEmbeddingExpanded","Array","isArray","similarityToQuery","mostSimilarEmbeddingIndex","argMax","maxIndex","selectedEmbeddings","selectedEmbeddingsIndexes","bestScore","Infinity","bestIndex","similarityToSelected","forEach","queryScore","queryScoreIndex","includes","maxSimilarityToSelected","score","push","array","maxValue","NaN","i","arrays","reduce","acc"],"sources":["/home/nikhil/legalbot/legalbot/node_modules/@langchain/core/dist/utils/math.js"],"sourcesContent":["import { similarity as ml_distance_similarity, distance as ml_distance, } from \"ml-distance\";\n/**\n * Apply a row-wise function between two matrices with the same number of columns.\n *\n * @param {number[][]} X - The first matrix.\n * @param {number[][]} Y - The second matrix.\n * @param {VectorFunction} func - The function to apply.\n *\n * @throws {Error} If the number of columns in X and Y are not the same.\n *\n * @returns {number[][] | [[]]} A matrix where each row represents the result of applying the function between the corresponding rows of X and Y.\n */\nexport function matrixFunc(X, Y, func) {\n    if (X.length === 0 ||\n        X[0].length === 0 ||\n        Y.length === 0 ||\n        Y[0].length === 0) {\n        return [[]];\n    }\n    if (X[0].length !== Y[0].length) {\n        throw new Error(`Number of columns in X and Y must be the same. X has shape ${[\n            X.length,\n            X[0].length,\n        ]} and Y has shape ${[Y.length, Y[0].length]}.`);\n    }\n    return X.map((xVector) => Y.map((yVector) => func(xVector, yVector)).map((similarity) => Number.isNaN(similarity) ? 0 : similarity));\n}\nexport function normalize(M, similarity = false) {\n    const max = matrixMaxVal(M);\n    return M.map((row) => row.map((val) => (similarity ? 1 - val / max : val / max)));\n}\n/**\n * This function calculates the row-wise cosine similarity between two matrices with the same number of columns.\n *\n * @param {number[][]} X - The first matrix.\n * @param {number[][]} Y - The second matrix.\n *\n * @throws {Error} If the number of columns in X and Y are not the same.\n *\n * @returns {number[][] | [[]]} A matrix where each row represents the cosine similarity values between the corresponding rows of X and Y.\n */\nexport function cosineSimilarity(X, Y) {\n    return matrixFunc(X, Y, ml_distance_similarity.cosine);\n}\nexport function innerProduct(X, Y) {\n    return matrixFunc(X, Y, ml_distance.innerProduct);\n}\nexport function euclideanDistance(X, Y) {\n    return matrixFunc(X, Y, ml_distance.euclidean);\n}\n/**\n * This function implements the Maximal Marginal Relevance algorithm\n * to select a set of embeddings that maximizes the diversity and relevance to a query embedding.\n *\n * @param {number[]|number[][]} queryEmbedding - The query embedding.\n * @param {number[][]} embeddingList - The list of embeddings to select from.\n * @param {number} [lambda=0.5] - The trade-off parameter between relevance and diversity.\n * @param {number} [k=4] - The maximum number of embeddings to select.\n *\n * @returns {number[]} The indexes of the selected embeddings in the embeddingList.\n */\nexport function maximalMarginalRelevance(queryEmbedding, embeddingList, lambda = 0.5, k = 4) {\n    if (Math.min(k, embeddingList.length) <= 0) {\n        return [];\n    }\n    const queryEmbeddingExpanded = (Array.isArray(queryEmbedding[0]) ? queryEmbedding : [queryEmbedding]);\n    const similarityToQuery = cosineSimilarity(queryEmbeddingExpanded, embeddingList)[0];\n    const mostSimilarEmbeddingIndex = argMax(similarityToQuery).maxIndex;\n    const selectedEmbeddings = [embeddingList[mostSimilarEmbeddingIndex]];\n    const selectedEmbeddingsIndexes = [mostSimilarEmbeddingIndex];\n    while (selectedEmbeddingsIndexes.length < Math.min(k, embeddingList.length)) {\n        let bestScore = -Infinity;\n        let bestIndex = -1;\n        const similarityToSelected = cosineSimilarity(embeddingList, selectedEmbeddings);\n        similarityToQuery.forEach((queryScore, queryScoreIndex) => {\n            if (selectedEmbeddingsIndexes.includes(queryScoreIndex)) {\n                return;\n            }\n            const maxSimilarityToSelected = Math.max(...similarityToSelected[queryScoreIndex]);\n            const score = lambda * queryScore - (1 - lambda) * maxSimilarityToSelected;\n            if (score > bestScore) {\n                bestScore = score;\n                bestIndex = queryScoreIndex;\n            }\n        });\n        selectedEmbeddings.push(embeddingList[bestIndex]);\n        selectedEmbeddingsIndexes.push(bestIndex);\n    }\n    return selectedEmbeddingsIndexes;\n}\n/**\n * Finds the index of the maximum value in the given array.\n * @param {number[]} array - The input array.\n *\n * @returns {number} The index of the maximum value in the array. If the array is empty, returns -1.\n */\nfunction argMax(array) {\n    if (array.length === 0) {\n        return {\n            maxIndex: -1,\n            maxValue: NaN,\n        };\n    }\n    let maxValue = array[0];\n    let maxIndex = 0;\n    for (let i = 1; i < array.length; i += 1) {\n        if (array[i] > maxValue) {\n            maxIndex = i;\n            maxValue = array[i];\n        }\n    }\n    return { maxIndex, maxValue };\n}\nfunction matrixMaxVal(arrays) {\n    return arrays.reduce((acc, array) => Math.max(acc, argMax(array).maxValue), 0);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}