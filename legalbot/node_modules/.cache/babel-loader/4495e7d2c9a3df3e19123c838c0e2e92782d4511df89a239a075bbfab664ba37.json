{"ast":null,"code":"import { z } from \"zod\";\nimport pRetry from \"p-retry\";\nimport { CallbackManager } from \"../callbacks/manager.js\";\nimport { LogStreamCallbackHandler, RunLog, RunLogPatch } from \"../tracers/log_stream.js\";\nimport { Serializable } from \"../load/serializable.js\";\nimport { IterableReadableStream, concat, atee, pipeGeneratorWithSetup, AsyncGeneratorWithSetup } from \"../utils/stream.js\";\nimport { DEFAULT_RECURSION_LIMIT, ensureConfig, getCallbackManagerForConfig, mergeConfigs, patchConfig } from \"./config.js\";\nimport { AsyncCaller } from \"../utils/async_caller.js\";\nimport { RootListenersTracer } from \"../tracers/root_listener.js\";\nimport { _RootEventFilter, isRunnableInterface } from \"./utils.js\";\nimport { AsyncLocalStorageProviderSingleton } from \"../singletons/index.js\";\nimport { Graph } from \"./graph.js\";\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function _coerceToDict(value, defaultKey) {\n  return value && !Array.isArray(value) &&\n  // eslint-disable-next-line no-instanceof/no-instanceof\n  !(value instanceof Date) && typeof value === \"object\" ? value : {\n    [defaultKey]: value\n  };\n}\n/**\n * A Runnable is a generic unit of work that can be invoked, batched, streamed, and/or\n * transformed.\n */\nexport class Runnable extends Serializable {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, \"lc_runnable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n  }\n  getName(suffix) {\n    const name =\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this.name ?? this.constructor.lc_name() ?? this.constructor.name;\n    return suffix ? `${name}${suffix}` : name;\n  }\n  /**\n   * Bind arguments to a Runnable, returning a new Runnable.\n   * @param kwargs\n   * @returns A new RunnableBinding that, when invoked, will apply the bound args.\n   */\n  bind(kwargs) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableBinding({\n      bound: this,\n      kwargs,\n      config: {}\n    });\n  }\n  /**\n   * Return a new Runnable that maps a list of inputs to a list of outputs,\n   * by calling invoke() with each input.\n   */\n  map() {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableEach({\n      bound: this\n    });\n  }\n  /**\n   * Add retry logic to an existing runnable.\n   * @param kwargs\n   * @returns A new RunnableRetry that, when invoked, will retry according to the parameters.\n   */\n  withRetry(fields) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableRetry({\n      bound: this,\n      kwargs: {},\n      config: {},\n      maxAttemptNumber: fields?.stopAfterAttempt,\n      ...fields\n    });\n  }\n  /**\n   * Bind config to a Runnable, returning a new Runnable.\n   * @param config New configuration parameters to attach to the new runnable.\n   * @returns A new RunnableBinding with a config matching what's passed.\n   */\n  withConfig(config) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableBinding({\n      bound: this,\n      config,\n      kwargs: {}\n    });\n  }\n  /**\n   * Create a new runnable from the current one that will try invoking\n   * other passed fallback runnables if the initial invocation fails.\n   * @param fields.fallbacks Other runnables to call if the runnable errors.\n   * @returns A new RunnableWithFallbacks.\n   */\n  withFallbacks(fields) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableWithFallbacks({\n      runnable: this,\n      fallbacks: fields.fallbacks\n    });\n  }\n  _getOptionsList(options, length = 0) {\n    if (Array.isArray(options)) {\n      if (options.length !== length) {\n        throw new Error(`Passed \"options\" must be an array with the same length as the inputs, but got ${options.length} options for ${length} inputs`);\n      }\n      return options.map(ensureConfig);\n    }\n    return Array.from({\n      length\n    }, () => ensureConfig(options));\n  }\n  async batch(inputs, options, batchOptions) {\n    const configList = this._getOptionsList(options ?? {}, inputs.length);\n    const maxConcurrency = configList[0]?.maxConcurrency ?? batchOptions?.maxConcurrency;\n    const caller = new AsyncCaller({\n      maxConcurrency,\n      onFailedAttempt: e => {\n        throw e;\n      }\n    });\n    const batchCalls = inputs.map((input, i) => caller.call(async () => {\n      try {\n        const result = await this.invoke(input, configList[i]);\n        return result;\n      } catch (e) {\n        if (batchOptions?.returnExceptions) {\n          return e;\n        }\n        throw e;\n      }\n    }));\n    return Promise.all(batchCalls);\n  }\n  /**\n   * Default streaming implementation.\n   * Subclasses should override this method if they support streaming output.\n   * @param input\n   * @param options\n   */\n  async *_streamIterator(input, options) {\n    yield this.invoke(input, options);\n  }\n  /**\n   * Stream output in chunks.\n   * @param input\n   * @param options\n   * @returns A readable stream that is also an iterable.\n   */\n  async stream(input, options) {\n    // Buffer the first streamed chunk to allow for initial errors\n    // to surface immediately.\n    const wrappedGenerator = new AsyncGeneratorWithSetup(this._streamIterator(input, ensureConfig(options)));\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n  _separateRunnableConfigFromCallOptions(options = {}) {\n    const runnableConfig = ensureConfig({\n      callbacks: options.callbacks,\n      tags: options.tags,\n      metadata: options.metadata,\n      runName: options.runName,\n      configurable: options.configurable,\n      recursionLimit: options.recursionLimit,\n      maxConcurrency: options.maxConcurrency\n    });\n    const callOptions = {\n      ...options\n    };\n    delete callOptions.callbacks;\n    delete callOptions.tags;\n    delete callOptions.metadata;\n    delete callOptions.runName;\n    delete callOptions.configurable;\n    delete callOptions.recursionLimit;\n    delete callOptions.maxConcurrency;\n    return [runnableConfig, callOptions];\n  }\n  async _callWithConfig(func, input, options) {\n    const config = ensureConfig(options);\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), undefined, config?.runType, undefined, undefined, config?.runName ?? this.getName());\n    let output;\n    try {\n      output = await func.call(this, input, config, runManager);\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n    return output;\n  }\n  /**\n   * Internal method that handles batching and configuration for a runnable\n   * It takes a function, input values, and optional configuration, and\n   * returns a promise that resolves to the output values.\n   * @param func The function to be executed for each input value.\n   * @param input The input values to be processed.\n   * @param config Optional configuration for the function execution.\n   * @returns A promise that resolves to the output values.\n   */\n  async _batchWithConfig(func, inputs, options, batchOptions) {\n    const optionsList = this._getOptionsList(options ?? {}, inputs.length);\n    const callbackManagers = await Promise.all(optionsList.map(getCallbackManagerForConfig));\n    const runManagers = await Promise.all(callbackManagers.map((callbackManager, i) => callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), undefined, optionsList[i].runType, undefined, undefined, optionsList[i].runName ?? this.getName())));\n    let outputs;\n    try {\n      outputs = await func.call(this, inputs, optionsList, runManagers, batchOptions);\n    } catch (e) {\n      await Promise.all(runManagers.map(runManager => runManager?.handleChainError(e)));\n      throw e;\n    }\n    await Promise.all(runManagers.map(runManager => runManager?.handleChainEnd(_coerceToDict(outputs, \"output\"))));\n    return outputs;\n  }\n  /**\n   * Helper method to transform an Iterator of Input values into an Iterator of\n   * Output values, with callbacks.\n   * Use this to implement `stream()` or `transform()` in Runnable subclasses.\n   */\n  async *_transformStreamWithConfig(inputGenerator, transformer, options) {\n    let finalInput;\n    let finalInputSupported = true;\n    let finalOutput;\n    let finalOutputSupported = true;\n    const config = ensureConfig(options);\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    async function* wrapInputForTracing() {\n      for await (const chunk of inputGenerator) {\n        if (finalInputSupported) {\n          if (finalInput === undefined) {\n            finalInput = chunk;\n          } else {\n            try {\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              finalInput = concat(finalInput, chunk);\n            } catch {\n              finalInput = undefined;\n              finalInputSupported = false;\n            }\n          }\n        }\n        yield chunk;\n      }\n    }\n    let runManager;\n    try {\n      const pipe = await pipeGeneratorWithSetup(transformer.bind(this), wrapInputForTracing(), async () => callbackManager_?.handleChainStart(this.toJSON(), {\n        input: \"\"\n      }, undefined, config?.runType, undefined, undefined, config?.runName ?? this.getName()), config);\n      runManager = pipe.setup;\n      const isLogStreamHandler = handler => handler.name === \"log_stream_tracer\";\n      const streamLogHandler = runManager?.handlers.find(isLogStreamHandler);\n      let iterator = pipe.output;\n      if (streamLogHandler !== undefined && runManager !== undefined) {\n        iterator = await streamLogHandler.tapOutputIterable(runManager.runId, pipe.output);\n      }\n      for await (const chunk of iterator) {\n        yield chunk;\n        if (finalOutputSupported) {\n          if (finalOutput === undefined) {\n            finalOutput = chunk;\n          } else {\n            try {\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              finalOutput = concat(finalOutput, chunk);\n            } catch {\n              finalOutput = undefined;\n              finalOutputSupported = false;\n            }\n          }\n        }\n      }\n    } catch (e) {\n      await runManager?.handleChainError(e, undefined, undefined, undefined, {\n        inputs: _coerceToDict(finalInput, \"input\")\n      });\n      throw e;\n    }\n    await runManager?.handleChainEnd(finalOutput ?? {}, undefined, undefined, undefined, {\n      inputs: _coerceToDict(finalInput, \"input\")\n    });\n  }\n  getGraph(_) {\n    const graph = new Graph();\n    // TODO: Add input schema for runnables\n    const inputNode = graph.addNode({\n      name: `${this.getName()}Input`,\n      schema: z.any()\n    });\n    const runnableNode = graph.addNode(this);\n    // TODO: Add output schemas for runnables\n    const outputNode = graph.addNode({\n      name: `${this.getName()}Output`,\n      schema: z.any()\n    });\n    graph.addEdge(inputNode, runnableNode);\n    graph.addEdge(runnableNode, outputNode);\n    return graph;\n  }\n  /**\n   * Create a new runnable sequence that runs each individual runnable in series,\n   * piping the output of one runnable into another runnable or runnable-like.\n   * @param coerceable A runnable, function, or object whose values are functions or runnables.\n   * @returns A new runnable sequence.\n   */\n  pipe(coerceable) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableSequence({\n      first: this,\n      last: _coerceToRunnable(coerceable)\n    });\n  }\n  /**\n   * Pick keys from the dict output of this runnable. Returns a new runnable.\n   */\n  pick(keys) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return this.pipe(new RunnablePick(keys));\n  }\n  /**\n   * Assigns new fields to the dict output of this runnable. Returns a new runnable.\n   */\n  assign(mapping) {\n    return this.pipe(\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    new RunnableAssign(\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    new RunnableMap({\n      steps: mapping\n    })));\n  }\n  /**\n   * Default implementation of transform, which buffers input and then calls stream.\n   * Subclasses should override this method if they can start producing output while\n   * input is still being generated.\n   * @param generator\n   * @param options\n   */\n  async *transform(generator, options) {\n    let finalChunk;\n    for await (const chunk of generator) {\n      if (finalChunk === undefined) {\n        finalChunk = chunk;\n      } else {\n        // Make a best effort to gather, for any type that supports concat.\n        // This method should throw an error if gathering fails.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        finalChunk = concat(finalChunk, chunk);\n      }\n    }\n    yield* this._streamIterator(finalChunk, ensureConfig(options));\n  }\n  /**\n   * Stream all output from a runnable, as reported to the callback system.\n   * This includes all inner runs of LLMs, Retrievers, Tools, etc.\n   * Output is streamed as Log objects, which include a list of\n   * jsonpatch ops that describe how the state of the run has changed in each\n   * step, and the final state of the run.\n   * The jsonpatch ops can be applied in order to construct state.\n   * @param input\n   * @param options\n   * @param streamOptions\n   */\n  async *streamLog(input, options, streamOptions) {\n    const logStreamCallbackHandler = new LogStreamCallbackHandler({\n      ...streamOptions,\n      autoClose: false,\n      _schemaFormat: \"original\"\n    });\n    const config = ensureConfig(options);\n    yield* this._streamLog(input, logStreamCallbackHandler, config);\n  }\n  async *_streamLog(input, logStreamCallbackHandler, config) {\n    const {\n      callbacks\n    } = config;\n    if (callbacks === undefined) {\n      // eslint-disable-next-line no-param-reassign\n      config.callbacks = [logStreamCallbackHandler];\n    } else if (Array.isArray(callbacks)) {\n      // eslint-disable-next-line no-param-reassign\n      config.callbacks = callbacks.concat([logStreamCallbackHandler]);\n    } else {\n      const copiedCallbacks = callbacks.copy();\n      copiedCallbacks.inheritableHandlers.push(logStreamCallbackHandler);\n      // eslint-disable-next-line no-param-reassign\n      config.callbacks = copiedCallbacks;\n    }\n    const runnableStreamPromise = this.stream(input, config);\n    async function consumeRunnableStream() {\n      try {\n        const runnableStream = await runnableStreamPromise;\n        for await (const chunk of runnableStream) {\n          const patch = new RunLogPatch({\n            ops: [{\n              op: \"add\",\n              path: \"/streamed_output/-\",\n              value: chunk\n            }]\n          });\n          await logStreamCallbackHandler.writer.write(patch);\n        }\n      } finally {\n        await logStreamCallbackHandler.writer.close();\n      }\n    }\n    const runnableStreamConsumePromise = consumeRunnableStream();\n    try {\n      for await (const log of logStreamCallbackHandler) {\n        yield log;\n      }\n    } finally {\n      await runnableStreamConsumePromise;\n    }\n  }\n  /**\n   * Generate a stream of events emitted by the internal steps of the runnable.\n   *\n   * Use to create an iterator over StreamEvents that provide real-time information\n   * about the progress of the runnable, including StreamEvents from intermediate\n   * results.\n   *\n   * A StreamEvent is a dictionary with the following schema:\n   *\n   * - `event`: string - Event names are of the format: on_[runnable_type]_(start|stream|end).\n   * - `name`: string - The name of the runnable that generated the event.\n   * - `run_id`: string - Randomly generated ID associated with the given execution of\n   *   the runnable that emitted the event. A child runnable that gets invoked as part of the execution of a\n   *   parent runnable is assigned its own unique ID.\n   * - `tags`: string[] - The tags of the runnable that generated the event.\n   * - `metadata`: Record<string, any> - The metadata of the runnable that generated the event.\n   * - `data`: Record<string, any>\n   *\n   * Below is a table that illustrates some events that might be emitted by various\n   * chains. Metadata fields have been omitted from the table for brevity.\n   * Chain definitions have been included after the table.\n   *\n   * | event                | name             | chunk                              | input                                         | output                                          |\n   * |----------------------|------------------|------------------------------------|-----------------------------------------------|-------------------------------------------------|\n   * | on_llm_start         | [model name]     |                                    | {'input': 'hello'}                            |                                                 |\n   * | on_llm_stream        | [model name]     | 'Hello' OR AIMessageChunk(\"hello\") |                                               |                                                 |\n   * | on_llm_end           | [model name]     |                                    | 'Hello human!'                                |\n   * | on_chain_start       | format_docs      |                                    |                                               |                                                 |\n   * | on_chain_stream      | format_docs      | \"hello world!, goodbye world!\"     |                                               |                                                 |\n   * | on_chain_end         | format_docs      |                                    | [Document(...)]                               | \"hello world!, goodbye world!\"                  |\n   * | on_tool_start        | some_tool        |                                    | {\"x\": 1, \"y\": \"2\"}                            |                                                 |\n   * | on_tool_stream       | some_tool        |   {\"x\": 1, \"y\": \"2\"}               |                                               |                                                 |\n   * | on_tool_end          | some_tool        |                                    |                                               | {\"x\": 1, \"y\": \"2\"}                              |\n   * | on_retriever_start   | [retriever name] |                                    | {\"query\": \"hello\"}                            |                                                 |\n   * | on_retriever_chunk   | [retriever name] |  {documents: [...]}                |                                               |                                                 |\n   * | on_retriever_end     | [retriever name] |                                    | {\"query\": \"hello\"}                            | {documents: [...]}                              |\n   * | on_prompt_start      | [template_name]  |                                    | {\"question\": \"hello\"}                         |                                                 |\n   * | on_prompt_end        | [template_name]  |                                    | {\"question\": \"hello\"}                         | ChatPromptValue(messages: [SystemMessage, ...]) |\n   */\n  async *streamEvents(input, options, streamOptions) {\n    if (options.version !== \"v1\") {\n      throw new Error(`Only version \"v1\" of the events schema is currently supported.`);\n    }\n    let runLog;\n    let hasEncounteredStartEvent = false;\n    const config = ensureConfig(options);\n    const rootTags = config.tags ?? [];\n    const rootMetadata = config.metadata ?? {};\n    const rootName = config.runName ?? this.getName();\n    const logStreamCallbackHandler = new LogStreamCallbackHandler({\n      ...streamOptions,\n      autoClose: false,\n      _schemaFormat: \"streaming_events\"\n    });\n    const rootEventFilter = new _RootEventFilter({\n      ...streamOptions\n    });\n    const logStream = this._streamLog(input, logStreamCallbackHandler, config);\n    for await (const log of logStream) {\n      if (!runLog) {\n        runLog = RunLog.fromRunLogPatch(log);\n      } else {\n        runLog = runLog.concat(log);\n      }\n      if (runLog.state === undefined) {\n        throw new Error(`Internal error: \"streamEvents\" state is missing. Please open a bug report.`);\n      }\n      // Yield the start event for the root runnable if it hasn't been seen.\n      // The root run is never filtered out\n      if (!hasEncounteredStartEvent) {\n        hasEncounteredStartEvent = true;\n        const state = {\n          ...runLog.state\n        };\n        const event = {\n          run_id: state.id,\n          event: `on_${state.type}_start`,\n          name: rootName,\n          tags: rootTags,\n          metadata: rootMetadata,\n          data: {\n            input\n          }\n        };\n        if (rootEventFilter.includeEvent(event, state.type)) {\n          yield event;\n        }\n      }\n      const paths = log.ops.filter(op => op.path.startsWith(\"/logs/\")).map(op => op.path.split(\"/\")[2]);\n      const dedupedPaths = [...new Set(paths)];\n      for (const path of dedupedPaths) {\n        let eventType;\n        let data = {};\n        const logEntry = runLog.state.logs[path];\n        if (logEntry.end_time === undefined) {\n          if (logEntry.streamed_output.length > 0) {\n            eventType = \"stream\";\n          } else {\n            eventType = \"start\";\n          }\n        } else {\n          eventType = \"end\";\n        }\n        if (eventType === \"start\") {\n          // Include the inputs with the start event if they are available.\n          // Usually they will NOT be available for components that operate\n          // on streams, since those components stream the input and\n          // don't know its final value until the end of the stream.\n          if (logEntry.inputs !== undefined) {\n            data.input = logEntry.inputs;\n          }\n        } else if (eventType === \"end\") {\n          if (logEntry.inputs !== undefined) {\n            data.input = logEntry.inputs;\n          }\n          data.output = logEntry.final_output;\n        } else if (eventType === \"stream\") {\n          const chunkCount = logEntry.streamed_output.length;\n          if (chunkCount !== 1) {\n            throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: \"${logEntry.name}\"`);\n          }\n          data = {\n            chunk: logEntry.streamed_output[0]\n          };\n          // Clean up the stream, we don't need it anymore.\n          // And this avoids duplicates as well!\n          logEntry.streamed_output = [];\n        }\n        yield {\n          event: `on_${logEntry.type}_${eventType}`,\n          name: logEntry.name,\n          run_id: logEntry.id,\n          tags: logEntry.tags,\n          metadata: logEntry.metadata,\n          data\n        };\n      }\n      // Finally, we take care of the streaming output from the root chain\n      // if there is any.\n      const {\n        state\n      } = runLog;\n      if (state.streamed_output.length > 0) {\n        const chunkCount = state.streamed_output.length;\n        if (chunkCount !== 1) {\n          throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: \"${state.name}\"`);\n        }\n        const data = {\n          chunk: state.streamed_output[0]\n        };\n        // Clean up the stream, we don't need it anymore.\n        state.streamed_output = [];\n        const event = {\n          event: `on_${state.type}_stream`,\n          run_id: state.id,\n          tags: rootTags,\n          metadata: rootMetadata,\n          name: rootName,\n          data\n        };\n        if (rootEventFilter.includeEvent(event, state.type)) {\n          yield event;\n        }\n      }\n    }\n    const state = runLog?.state;\n    if (state !== undefined) {\n      // Finally, yield the end event for the root runnable.\n      const event = {\n        event: `on_${state.type}_end`,\n        name: rootName,\n        run_id: state.id,\n        tags: rootTags,\n        metadata: rootMetadata,\n        data: {\n          output: state.final_output\n        }\n      };\n      if (rootEventFilter.includeEvent(event, state.type)) yield event;\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static isRunnable(thing) {\n    return isRunnableInterface(thing);\n  }\n  /**\n   * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n   * The Run object contains information about the run, including its id,\n   * type, input, output, error, startTime, endTime, and any tags or metadata\n   * added to the run.\n   *\n   * @param {Object} params - The object containing the callback functions.\n   * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n   * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n   * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n   */\n  withListeners({\n    onStart,\n    onEnd,\n    onError\n  }) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableBinding({\n      bound: this,\n      config: {},\n      configFactories: [config => ({\n        callbacks: [new RootListenersTracer({\n          config,\n          onStart,\n          onEnd,\n          onError\n        })]\n      })]\n    });\n  }\n}\n/**\n * A runnable that delegates calls to another runnable with a set of kwargs.\n */\nexport class RunnableBinding extends Runnable {\n  static lc_name() {\n    return \"RunnableBinding\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"bound\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"config\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"kwargs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"configFactories\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.bound = fields.bound;\n    this.kwargs = fields.kwargs;\n    this.config = fields.config;\n    this.configFactories = fields.configFactories;\n  }\n  getName(suffix) {\n    return this.bound.getName(suffix);\n  }\n  async _mergeConfig(...options) {\n    const config = mergeConfigs(this.config, ...options);\n    return mergeConfigs(config, ...(this.configFactories ? await Promise.all(this.configFactories.map(async configFactory => await configFactory(config))) : []));\n  }\n  bind(kwargs) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return new this.constructor({\n      bound: this.bound,\n      kwargs: {\n        ...this.kwargs,\n        ...kwargs\n      },\n      config: this.config\n    });\n  }\n  withConfig(config) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return new this.constructor({\n      bound: this.bound,\n      kwargs: this.kwargs,\n      config: {\n        ...this.config,\n        ...config\n      }\n    });\n  }\n  withRetry(fields) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return new this.constructor({\n      bound: this.bound.withRetry(fields),\n      kwargs: this.kwargs,\n      config: this.config\n    });\n  }\n  async invoke(input, options) {\n    return this.bound.invoke(input, await this._mergeConfig(ensureConfig(options), this.kwargs));\n  }\n  async batch(inputs, options, batchOptions) {\n    const mergedOptions = Array.isArray(options) ? await Promise.all(options.map(async individualOption => this._mergeConfig(ensureConfig(individualOption), this.kwargs))) : await this._mergeConfig(ensureConfig(options), this.kwargs);\n    return this.bound.batch(inputs, mergedOptions, batchOptions);\n  }\n  async *_streamIterator(input, options) {\n    yield* this.bound._streamIterator(input, await this._mergeConfig(ensureConfig(options), this.kwargs));\n  }\n  async stream(input, options) {\n    return this.bound.stream(input, await this._mergeConfig(ensureConfig(options), this.kwargs));\n  }\n  async *transform(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  generator, options) {\n    yield* this.bound.transform(generator, await this._mergeConfig(ensureConfig(options), this.kwargs));\n  }\n  async *streamEvents(input, options, streamOptions) {\n    yield* this.bound.streamEvents(input, {\n      ...(await this._mergeConfig(ensureConfig(options), this.kwargs)),\n      version: options.version\n    }, streamOptions);\n  }\n  static isRunnableBinding(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  thing\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ) {\n    return thing.bound && Runnable.isRunnable(thing.bound);\n  }\n  /**\n   * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n   * The Run object contains information about the run, including its id,\n   * type, input, output, error, startTime, endTime, and any tags or metadata\n   * added to the run.\n   *\n   * @param {Object} params - The object containing the callback functions.\n   * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n   * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n   * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n   */\n  withListeners({\n    onStart,\n    onEnd,\n    onError\n  }) {\n    return new RunnableBinding({\n      bound: this.bound,\n      kwargs: this.kwargs,\n      config: this.config,\n      configFactories: [config => ({\n        callbacks: [new RootListenersTracer({\n          config,\n          onStart,\n          onEnd,\n          onError\n        })]\n      })]\n    });\n  }\n}\n/**\n * A runnable that delegates calls to another runnable\n * with each element of the input sequence.\n */\nexport class RunnableEach extends Runnable {\n  static lc_name() {\n    return \"RunnableEach\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"bound\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.bound = fields.bound;\n  }\n  /**\n   * Binds the runnable with the specified arguments.\n   * @param kwargs The arguments to bind the runnable with.\n   * @returns A new instance of the `RunnableEach` class that is bound with the specified arguments.\n   */\n  bind(kwargs) {\n    return new RunnableEach({\n      bound: this.bound.bind(kwargs)\n    });\n  }\n  /**\n   * Invokes the runnable with the specified input and configuration.\n   * @param input The input to invoke the runnable with.\n   * @param config The configuration to invoke the runnable with.\n   * @returns A promise that resolves to the output of the runnable.\n   */\n  async invoke(inputs, config) {\n    return this._callWithConfig(this._invoke, inputs, config);\n  }\n  /**\n   * A helper method that is used to invoke the runnable with the specified input and configuration.\n   * @param input The input to invoke the runnable with.\n   * @param config The configuration to invoke the runnable with.\n   * @returns A promise that resolves to the output of the runnable.\n   */\n  async _invoke(inputs, config, runManager) {\n    return this.bound.batch(inputs, patchConfig(config, {\n      callbacks: runManager?.getChild()\n    }));\n  }\n  /**\n   * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n   * The Run object contains information about the run, including its id,\n   * type, input, output, error, startTime, endTime, and any tags or metadata\n   * added to the run.\n   *\n   * @param {Object} params - The object containing the callback functions.\n   * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n   * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n   * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n   */\n  withListeners({\n    onStart,\n    onEnd,\n    onError\n  }) {\n    return new RunnableEach({\n      bound: this.bound.withListeners({\n        onStart,\n        onEnd,\n        onError\n      })\n    });\n  }\n}\n/**\n * Base class for runnables that can be retried a\n * specified number of times.\n */\nexport class RunnableRetry extends RunnableBinding {\n  static lc_name() {\n    return \"RunnableRetry\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"maxAttemptNumber\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 3\n    });\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Object.defineProperty(this, \"onFailedAttempt\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: () => {}\n    });\n    this.maxAttemptNumber = fields.maxAttemptNumber ?? this.maxAttemptNumber;\n    this.onFailedAttempt = fields.onFailedAttempt ?? this.onFailedAttempt;\n  }\n  _patchConfigForRetry(attempt, config, runManager) {\n    const tag = attempt > 1 ? `retry:attempt:${attempt}` : undefined;\n    return patchConfig(config, {\n      callbacks: runManager?.getChild(tag)\n    });\n  }\n  async _invoke(input, config, runManager) {\n    return pRetry(attemptNumber => super.invoke(input, this._patchConfigForRetry(attemptNumber, config, runManager)), {\n      onFailedAttempt: this.onFailedAttempt,\n      retries: Math.max(this.maxAttemptNumber - 1, 0),\n      randomize: true\n    });\n  }\n  /**\n   * Method that invokes the runnable with the specified input, run manager,\n   * and config. It handles the retry logic by catching any errors and\n   * recursively invoking itself with the updated config for the next retry\n   * attempt.\n   * @param input The input for the runnable.\n   * @param runManager The run manager for the runnable.\n   * @param config The config for the runnable.\n   * @returns A promise that resolves to the output of the runnable.\n   */\n  async invoke(input, config) {\n    return this._callWithConfig(this._invoke, input, config);\n  }\n  async _batch(inputs, configs, runManagers, batchOptions) {\n    const resultsMap = {};\n    try {\n      await pRetry(async attemptNumber => {\n        const remainingIndexes = inputs.map((_, i) => i).filter(i => resultsMap[i.toString()] === undefined ||\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        resultsMap[i.toString()] instanceof Error);\n        const remainingInputs = remainingIndexes.map(i => inputs[i]);\n        const patchedConfigs = remainingIndexes.map(i => this._patchConfigForRetry(attemptNumber, configs?.[i], runManagers?.[i]));\n        const results = await super.batch(remainingInputs, patchedConfigs, {\n          ...batchOptions,\n          returnExceptions: true\n        });\n        let firstException;\n        for (let i = 0; i < results.length; i += 1) {\n          const result = results[i];\n          const resultMapIndex = remainingIndexes[i];\n          // eslint-disable-next-line no-instanceof/no-instanceof\n          if (result instanceof Error) {\n            if (firstException === undefined) {\n              firstException = result;\n            }\n          }\n          resultsMap[resultMapIndex.toString()] = result;\n        }\n        if (firstException) {\n          throw firstException;\n        }\n        return results;\n      }, {\n        onFailedAttempt: this.onFailedAttempt,\n        retries: Math.max(this.maxAttemptNumber - 1, 0),\n        randomize: true\n      });\n    } catch (e) {\n      if (batchOptions?.returnExceptions !== true) {\n        throw e;\n      }\n    }\n    return Object.keys(resultsMap).sort((a, b) => parseInt(a, 10) - parseInt(b, 10)).map(key => resultsMap[parseInt(key, 10)]);\n  }\n  async batch(inputs, options, batchOptions) {\n    return this._batchWithConfig(this._batch.bind(this), inputs, options, batchOptions);\n  }\n}\n/**\n * A sequence of runnables, where the output of each is the input of the next.\n * @example\n * ```typescript\n * const promptTemplate = PromptTemplate.fromTemplate(\n *   \"Tell me a joke about {topic}\",\n * );\n * const chain = RunnableSequence.from([promptTemplate, new ChatOpenAI({})]);\n * const result = await chain.invoke({ topic: \"bears\" });\n * ```\n */\nexport class RunnableSequence extends Runnable {\n  static lc_name() {\n    return \"RunnableSequence\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"first\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"middle\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Object.defineProperty(this, \"last\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    this.first = fields.first;\n    this.middle = fields.middle ?? this.middle;\n    this.last = fields.last;\n    this.name = fields.name;\n  }\n  get steps() {\n    return [this.first, ...this.middle, this.last];\n  }\n  async invoke(input, options) {\n    const config = ensureConfig(options);\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), undefined, undefined, undefined, undefined, config?.runName);\n    let nextStepInput = input;\n    let finalOutput;\n    try {\n      const initialSteps = [this.first, ...this.middle];\n      for (let i = 0; i < initialSteps.length; i += 1) {\n        const step = initialSteps[i];\n        nextStepInput = await step.invoke(nextStepInput, patchConfig(config, {\n          callbacks: runManager?.getChild(`seq:step:${i + 1}`)\n        }));\n      }\n      // TypeScript can't detect that the last output of the sequence returns RunOutput, so call it out of the loop here\n      finalOutput = await this.last.invoke(nextStepInput, patchConfig(config, {\n        callbacks: runManager?.getChild(`seq:step:${this.steps.length}`)\n      }));\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n    return finalOutput;\n  }\n  async batch(inputs, options, batchOptions) {\n    const configList = this._getOptionsList(options ?? {}, inputs.length);\n    const callbackManagers = await Promise.all(configList.map(getCallbackManagerForConfig));\n    const runManagers = await Promise.all(callbackManagers.map((callbackManager, i) => callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), undefined, undefined, undefined, undefined, configList[i].runName)));\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let nextStepInputs = inputs;\n    try {\n      for (let i = 0; i < this.steps.length; i += 1) {\n        const step = this.steps[i];\n        nextStepInputs = await step.batch(nextStepInputs, runManagers.map((runManager, j) => {\n          const childRunManager = runManager?.getChild(`seq:step:${i + 1}`);\n          return patchConfig(configList[j], {\n            callbacks: childRunManager\n          });\n        }), batchOptions);\n      }\n    } catch (e) {\n      await Promise.all(runManagers.map(runManager => runManager?.handleChainError(e)));\n      throw e;\n    }\n    await Promise.all(runManagers.map(runManager => runManager?.handleChainEnd(_coerceToDict(nextStepInputs, \"output\"))));\n    return nextStepInputs;\n  }\n  async *_streamIterator(input, options) {\n    const callbackManager_ = await getCallbackManagerForConfig(options);\n    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), undefined, undefined, undefined, undefined, options?.runName);\n    const steps = [this.first, ...this.middle, this.last];\n    let concatSupported = true;\n    let finalOutput;\n    async function* inputGenerator() {\n      yield input;\n    }\n    try {\n      let finalGenerator = steps[0].transform(inputGenerator(), patchConfig(options, {\n        callbacks: runManager?.getChild(`seq:step:1`)\n      }));\n      for (let i = 1; i < steps.length; i += 1) {\n        const step = steps[i];\n        finalGenerator = await step.transform(finalGenerator, patchConfig(options, {\n          callbacks: runManager?.getChild(`seq:step:${i + 1}`)\n        }));\n      }\n      for await (const chunk of finalGenerator) {\n        yield chunk;\n        if (concatSupported) {\n          if (finalOutput === undefined) {\n            finalOutput = chunk;\n          } else {\n            try {\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              finalOutput = concat(finalOutput, chunk);\n            } catch (e) {\n              finalOutput = undefined;\n              concatSupported = false;\n            }\n          }\n        }\n      }\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n  }\n  getGraph(config) {\n    const graph = new Graph();\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let currentLastNode = null;\n    this.steps.forEach((step, index) => {\n      const stepGraph = step.getGraph(config);\n      if (index !== 0) {\n        stepGraph.trimFirstNode();\n      }\n      if (index !== this.steps.length - 1) {\n        stepGraph.trimLastNode();\n      }\n      graph.extend(stepGraph);\n      const stepFirstNode = stepGraph.firstNode();\n      if (!stepFirstNode) {\n        throw new Error(`Runnable ${step} has no first node`);\n      }\n      if (currentLastNode) {\n        graph.addEdge(currentLastNode, stepFirstNode);\n      }\n      currentLastNode = stepGraph.lastNode();\n    });\n    return graph;\n  }\n  pipe(coerceable) {\n    if (RunnableSequence.isRunnableSequence(coerceable)) {\n      return new RunnableSequence({\n        first: this.first,\n        middle: this.middle.concat([this.last, coerceable.first, ...coerceable.middle]),\n        last: coerceable.last,\n        name: this.name ?? coerceable.name\n      });\n    } else {\n      return new RunnableSequence({\n        first: this.first,\n        middle: [...this.middle, this.last],\n        last: _coerceToRunnable(coerceable),\n        name: this.name\n      });\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static isRunnableSequence(thing) {\n    return Array.isArray(thing.middle) && Runnable.isRunnable(thing);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static from([first, ...runnables], name) {\n    return new RunnableSequence({\n      first: _coerceToRunnable(first),\n      middle: runnables.slice(0, -1).map(_coerceToRunnable),\n      last: _coerceToRunnable(runnables[runnables.length - 1]),\n      name\n    });\n  }\n}\n/**\n * A runnable that runs a mapping of runnables in parallel,\n * and returns a mapping of their outputs.\n * @example\n * ```typescript\n * const mapChain = RunnableMap.from({\n *   joke: PromptTemplate.fromTemplate(\"Tell me a joke about {topic}\").pipe(\n *     new ChatAnthropic({}),\n *   ),\n *   poem: PromptTemplate.fromTemplate(\"write a 2-line poem about {topic}\").pipe(\n *     new ChatAnthropic({}),\n *   ),\n * });\n * const result = await mapChain.invoke({ topic: \"bear\" });\n * ```\n */\nexport class RunnableMap extends Runnable {\n  static lc_name() {\n    return \"RunnableMap\";\n  }\n  getStepsKeys() {\n    return Object.keys(this.steps);\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"steps\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.steps = {};\n    for (const [key, value] of Object.entries(fields.steps)) {\n      this.steps[key] = _coerceToRunnable(value);\n    }\n  }\n  static from(steps) {\n    return new RunnableMap({\n      steps\n    });\n  }\n  async invoke(input, options) {\n    const config = ensureConfig(options);\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), {\n      input\n    }, undefined, undefined, undefined, undefined, config?.runName);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const output = {};\n    try {\n      await Promise.all(Object.entries(this.steps).map(async ([key, runnable]) => {\n        output[key] = await runnable.invoke(input, patchConfig(config, {\n          callbacks: runManager?.getChild(`map:key:${key}`)\n        }));\n      }));\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(output);\n    return output;\n  }\n  async *_transform(generator, runManager, options) {\n    // shallow copy steps to ignore changes while iterating\n    const steps = {\n      ...this.steps\n    };\n    // each step gets a copy of the input iterator\n    const inputCopies = atee(generator, Object.keys(steps).length);\n    // start the first iteration of each output iterator\n    const tasks = new Map(Object.entries(steps).map(([key, runnable], i) => {\n      const gen = runnable.transform(inputCopies[i], patchConfig(options, {\n        callbacks: runManager?.getChild(`map:key:${key}`)\n      }));\n      return [key, gen.next().then(result => ({\n        key,\n        gen,\n        result\n      }))];\n    }));\n    // yield chunks as they become available,\n    // starting new iterations as needed,\n    // until all iterators are done\n    while (tasks.size) {\n      const {\n        key,\n        result,\n        gen\n      } = await Promise.race(tasks.values());\n      tasks.delete(key);\n      if (!result.done) {\n        yield {\n          [key]: result.value\n        };\n        tasks.set(key, gen.next().then(result => ({\n          key,\n          gen,\n          result\n        })));\n      }\n    }\n  }\n  transform(generator, options) {\n    return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n  }\n  async stream(input, options) {\n    async function* generator() {\n      yield input;\n    }\n    const wrappedGenerator = new AsyncGeneratorWithSetup(this.transform(generator(), options));\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n}\n/**\n * A runnable that runs a callable.\n */\nexport class RunnableLambda extends Runnable {\n  static lc_name() {\n    return \"RunnableLambda\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"func\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.func = fields.func;\n  }\n  static from(func) {\n    return new RunnableLambda({\n      func\n    });\n  }\n  async _invoke(input, config, runManager) {\n    return new Promise((resolve, reject) => {\n      const childConfig = patchConfig(config, {\n        callbacks: runManager?.getChild(),\n        recursionLimit: (config?.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1\n      });\n      void AsyncLocalStorageProviderSingleton.getInstance().run(childConfig, async () => {\n        try {\n          let output = await this.func(input, {\n            ...childConfig,\n            config: childConfig\n          });\n          if (output && Runnable.isRunnable(output)) {\n            if (config?.recursionLimit === 0) {\n              throw new Error(\"Recursion limit reached.\");\n            }\n            output = await output.invoke(input, {\n              ...childConfig,\n              recursionLimit: (childConfig.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1\n            });\n          }\n          resolve(output);\n        } catch (e) {\n          reject(e);\n        }\n      });\n    });\n  }\n  async invoke(input, options) {\n    return this._callWithConfig(this._invoke, input, options);\n  }\n  async *_transform(generator, runManager, config) {\n    let finalChunk;\n    for await (const chunk of generator) {\n      if (finalChunk === undefined) {\n        finalChunk = chunk;\n      } else {\n        // Make a best effort to gather, for any type that supports concat.\n        try {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          finalChunk = concat(finalChunk, chunk);\n        } catch (e) {\n          finalChunk = chunk;\n        }\n      }\n    }\n    const output = await new Promise((resolve, reject) => {\n      void AsyncLocalStorageProviderSingleton.getInstance().run(config, async () => {\n        try {\n          const res = await this.func(finalChunk, {\n            ...config,\n            config\n          });\n          resolve(res);\n        } catch (e) {\n          reject(e);\n        }\n      });\n    });\n    if (output && Runnable.isRunnable(output)) {\n      if (config?.recursionLimit === 0) {\n        throw new Error(\"Recursion limit reached.\");\n      }\n      const stream = await output.stream(finalChunk, patchConfig(config, {\n        callbacks: runManager?.getChild(),\n        recursionLimit: (config?.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1\n      }));\n      for await (const chunk of stream) {\n        yield chunk;\n      }\n    } else {\n      yield output;\n    }\n  }\n  transform(generator, options) {\n    return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n  }\n  async stream(input, options) {\n    async function* generator() {\n      yield input;\n    }\n    const wrappedGenerator = new AsyncGeneratorWithSetup(this.transform(generator(), options));\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n}\nexport class RunnableParallel extends RunnableMap {}\n/**\n * A Runnable that can fallback to other Runnables if it fails.\n */\nexport class RunnableWithFallbacks extends Runnable {\n  static lc_name() {\n    return \"RunnableWithFallbacks\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"runnable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"fallbacks\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.runnable = fields.runnable;\n    this.fallbacks = fields.fallbacks;\n  }\n  *runnables() {\n    yield this.runnable;\n    for (const fallback of this.fallbacks) {\n      yield fallback;\n    }\n  }\n  async invoke(input, options) {\n    const callbackManager_ = await CallbackManager.configure(options?.callbacks, undefined, options?.tags, undefined, options?.metadata);\n    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), undefined, undefined, undefined, undefined, options?.runName);\n    let firstError;\n    for (const runnable of this.runnables()) {\n      try {\n        const output = await runnable.invoke(input, patchConfig(options, {\n          callbacks: runManager?.getChild()\n        }));\n        await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n        return output;\n      } catch (e) {\n        if (firstError === undefined) {\n          firstError = e;\n        }\n      }\n    }\n    if (firstError === undefined) {\n      throw new Error(\"No error stored at end of fallback.\");\n    }\n    await runManager?.handleChainError(firstError);\n    throw firstError;\n  }\n  async batch(inputs, options, batchOptions) {\n    if (batchOptions?.returnExceptions) {\n      throw new Error(\"Not implemented.\");\n    }\n    const configList = this._getOptionsList(options ?? {}, inputs.length);\n    const callbackManagers = await Promise.all(configList.map(config => CallbackManager.configure(config?.callbacks, undefined, config?.tags, undefined, config?.metadata)));\n    const runManagers = await Promise.all(callbackManagers.map((callbackManager, i) => callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), undefined, undefined, undefined, undefined, configList[i].runName)));\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let firstError;\n    for (const runnable of this.runnables()) {\n      try {\n        const outputs = await runnable.batch(inputs, runManagers.map((runManager, j) => patchConfig(configList[j], {\n          callbacks: runManager?.getChild()\n        })), batchOptions);\n        await Promise.all(runManagers.map((runManager, i) => runManager?.handleChainEnd(_coerceToDict(outputs[i], \"output\"))));\n        return outputs;\n      } catch (e) {\n        if (firstError === undefined) {\n          firstError = e;\n        }\n      }\n    }\n    if (!firstError) {\n      throw new Error(\"No error stored at end of fallbacks.\");\n    }\n    await Promise.all(runManagers.map(runManager => runManager?.handleChainError(firstError)));\n    throw firstError;\n  }\n}\n// TODO: Figure out why the compiler needs help eliminating Error as a RunOutput type\nexport function _coerceToRunnable(coerceable) {\n  if (typeof coerceable === \"function\") {\n    return new RunnableLambda({\n      func: coerceable\n    });\n  } else if (Runnable.isRunnable(coerceable)) {\n    return coerceable;\n  } else if (!Array.isArray(coerceable) && typeof coerceable === \"object\") {\n    const runnables = {};\n    for (const [key, value] of Object.entries(coerceable)) {\n      runnables[key] = _coerceToRunnable(value);\n    }\n    return new RunnableMap({\n      steps: runnables\n    });\n  } else {\n    throw new Error(`Expected a Runnable, function or object.\\nInstead got an unsupported type.`);\n  }\n}\n/**\n * A runnable that assigns key-value pairs to inputs of type `Record<string, unknown>`.\n */\nexport class RunnableAssign extends Runnable {\n  static lc_name() {\n    return \"RunnableAssign\";\n  }\n  constructor(fields) {\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    if (fields instanceof RunnableMap) {\n      // eslint-disable-next-line no-param-reassign\n      fields = {\n        mapper: fields\n      };\n    }\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"mapper\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.mapper = fields.mapper;\n  }\n  async invoke(input, options) {\n    const mapperResult = await this.mapper.invoke(input, options);\n    return {\n      ...input,\n      ...mapperResult\n    };\n  }\n  async *_transform(generator, runManager, options) {\n    // collect mapper keys\n    const mapperKeys = this.mapper.getStepsKeys();\n    // create two input gens, one for the mapper, one for the input\n    const [forPassthrough, forMapper] = atee(generator);\n    // create mapper output gen\n    const mapperOutput = this.mapper.transform(forMapper, patchConfig(options, {\n      callbacks: runManager?.getChild()\n    }));\n    // start the mapper\n    const firstMapperChunkPromise = mapperOutput.next();\n    // yield the passthrough\n    for await (const chunk of forPassthrough) {\n      if (typeof chunk !== \"object\" || Array.isArray(chunk)) {\n        throw new Error(`RunnableAssign can only be used with objects as input, got ${typeof chunk}`);\n      }\n      const filtered = Object.fromEntries(Object.entries(chunk).filter(([key]) => !mapperKeys.includes(key)));\n      if (Object.keys(filtered).length > 0) {\n        yield filtered;\n      }\n    }\n    // yield the mapper output\n    yield (await firstMapperChunkPromise).value;\n    for await (const chunk of mapperOutput) {\n      yield chunk;\n    }\n  }\n  transform(generator, options) {\n    return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n  }\n  async stream(input, options) {\n    async function* generator() {\n      yield input;\n    }\n    const wrappedGenerator = new AsyncGeneratorWithSetup(this.transform(generator(), options));\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n}\n/**\n * A runnable that assigns key-value pairs to inputs of type `Record<string, unknown>`.\n */\nexport class RunnablePick extends Runnable {\n  static lc_name() {\n    return \"RunnablePick\";\n  }\n  constructor(fields) {\n    if (typeof fields === \"string\" || Array.isArray(fields)) {\n      // eslint-disable-next-line no-param-reassign\n      fields = {\n        keys: fields\n      };\n    }\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"keys\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.keys = fields.keys;\n  }\n  async _pick(input) {\n    if (typeof this.keys === \"string\") {\n      return input[this.keys];\n    } else {\n      const picked = this.keys.map(key => [key, input[key]]).filter(v => v[1] !== undefined);\n      return picked.length === 0 ? undefined : Object.fromEntries(picked);\n    }\n  }\n  async invoke(input, options) {\n    return this._callWithConfig(this._pick.bind(this), input, options);\n  }\n  async *_transform(generator) {\n    for await (const chunk of generator) {\n      const picked = await this._pick(chunk);\n      if (picked !== undefined) {\n        yield picked;\n      }\n    }\n  }\n  transform(generator, options) {\n    return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n  }\n  async stream(input, options) {\n    async function* generator() {\n      yield input;\n    }\n    const wrappedGenerator = new AsyncGeneratorWithSetup(this.transform(generator(), options));\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n}","map":{"version":3,"names":["z","pRetry","CallbackManager","LogStreamCallbackHandler","RunLog","RunLogPatch","Serializable","IterableReadableStream","concat","atee","pipeGeneratorWithSetup","AsyncGeneratorWithSetup","DEFAULT_RECURSION_LIMIT","ensureConfig","getCallbackManagerForConfig","mergeConfigs","patchConfig","AsyncCaller","RootListenersTracer","_RootEventFilter","isRunnableInterface","AsyncLocalStorageProviderSingleton","Graph","_coerceToDict","value","defaultKey","Array","isArray","Date","Runnable","constructor","arguments","Object","defineProperty","enumerable","configurable","writable","getName","suffix","name","lc_name","bind","kwargs","RunnableBinding","bound","config","map","RunnableEach","withRetry","fields","RunnableRetry","maxAttemptNumber","stopAfterAttempt","withConfig","withFallbacks","RunnableWithFallbacks","runnable","fallbacks","_getOptionsList","options","length","Error","from","batch","inputs","batchOptions","configList","maxConcurrency","caller","onFailedAttempt","e","batchCalls","input","i","call","result","invoke","returnExceptions","Promise","all","_streamIterator","stream","wrappedGenerator","setup","fromAsyncGenerator","_separateRunnableConfigFromCallOptions","runnableConfig","callbacks","tags","metadata","runName","recursionLimit","callOptions","_callWithConfig","func","callbackManager_","runManager","handleChainStart","toJSON","undefined","runType","output","handleChainError","handleChainEnd","_batchWithConfig","optionsList","callbackManagers","runManagers","callbackManager","outputs","_transformStreamWithConfig","inputGenerator","transformer","finalInput","finalInputSupported","finalOutput","finalOutputSupported","wrapInputForTracing","chunk","pipe","isLogStreamHandler","handler","streamLogHandler","handlers","find","iterator","tapOutputIterable","runId","getGraph","_","graph","inputNode","addNode","schema","any","runnableNode","outputNode","addEdge","coerceable","RunnableSequence","first","last","_coerceToRunnable","pick","keys","RunnablePick","assign","mapping","RunnableAssign","RunnableMap","steps","transform","generator","finalChunk","streamLog","streamOptions","logStreamCallbackHandler","autoClose","_schemaFormat","_streamLog","copiedCallbacks","copy","inheritableHandlers","push","runnableStreamPromise","consumeRunnableStream","runnableStream","patch","ops","op","path","writer","write","close","runnableStreamConsumePromise","log","streamEvents","version","runLog","hasEncounteredStartEvent","rootTags","rootMetadata","rootName","rootEventFilter","logStream","fromRunLogPatch","state","event","run_id","id","type","data","includeEvent","paths","filter","startsWith","split","dedupedPaths","Set","eventType","logEntry","logs","end_time","streamed_output","final_output","chunkCount","isRunnable","thing","withListeners","onStart","onEnd","onError","configFactories","_mergeConfig","configFactory","mergedOptions","individualOption","isRunnableBinding","_invoke","getChild","_patchConfigForRetry","attempt","tag","attemptNumber","retries","Math","max","randomize","_batch","configs","resultsMap","remainingIndexes","toString","remainingInputs","patchedConfigs","results","firstException","resultMapIndex","sort","a","b","parseInt","key","middle","nextStepInput","initialSteps","step","nextStepInputs","j","childRunManager","concatSupported","finalGenerator","currentLastNode","forEach","index","stepGraph","trimFirstNode","trimLastNode","extend","stepFirstNode","firstNode","lastNode","isRunnableSequence","runnables","slice","getStepsKeys","entries","_transform","inputCopies","tasks","Map","gen","next","then","size","race","values","delete","done","set","RunnableLambda","resolve","reject","childConfig","getInstance","run","res","RunnableParallel","fallback","configure","firstError","mapper","mapperResult","mapperKeys","forPassthrough","forMapper","mapperOutput","firstMapperChunkPromise","filtered","fromEntries","includes","_pick","picked","v"],"sources":["/home/nikhil/legalbot/legalbot/node_modules/@langchain/core/dist/runnables/base.js"],"sourcesContent":["import { z } from \"zod\";\nimport pRetry from \"p-retry\";\nimport { CallbackManager, } from \"../callbacks/manager.js\";\nimport { LogStreamCallbackHandler, RunLog, RunLogPatch, } from \"../tracers/log_stream.js\";\nimport { Serializable } from \"../load/serializable.js\";\nimport { IterableReadableStream, concat, atee, pipeGeneratorWithSetup, AsyncGeneratorWithSetup, } from \"../utils/stream.js\";\nimport { DEFAULT_RECURSION_LIMIT, ensureConfig, getCallbackManagerForConfig, mergeConfigs, patchConfig, } from \"./config.js\";\nimport { AsyncCaller } from \"../utils/async_caller.js\";\nimport { RootListenersTracer } from \"../tracers/root_listener.js\";\nimport { _RootEventFilter, isRunnableInterface } from \"./utils.js\";\nimport { AsyncLocalStorageProviderSingleton } from \"../singletons/index.js\";\nimport { Graph } from \"./graph.js\";\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function _coerceToDict(value, defaultKey) {\n    return value &&\n        !Array.isArray(value) &&\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        !(value instanceof Date) &&\n        typeof value === \"object\"\n        ? value\n        : { [defaultKey]: value };\n}\n/**\n * A Runnable is a generic unit of work that can be invoked, batched, streamed, and/or\n * transformed.\n */\nexport class Runnable extends Serializable {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_runnable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    getName(suffix) {\n        const name = \n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.name ?? this.constructor.lc_name() ?? this.constructor.name;\n        return suffix ? `${name}${suffix}` : name;\n    }\n    /**\n     * Bind arguments to a Runnable, returning a new Runnable.\n     * @param kwargs\n     * @returns A new RunnableBinding that, when invoked, will apply the bound args.\n     */\n    bind(kwargs) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableBinding({ bound: this, kwargs, config: {} });\n    }\n    /**\n     * Return a new Runnable that maps a list of inputs to a list of outputs,\n     * by calling invoke() with each input.\n     */\n    map() {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableEach({ bound: this });\n    }\n    /**\n     * Add retry logic to an existing runnable.\n     * @param kwargs\n     * @returns A new RunnableRetry that, when invoked, will retry according to the parameters.\n     */\n    withRetry(fields) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableRetry({\n            bound: this,\n            kwargs: {},\n            config: {},\n            maxAttemptNumber: fields?.stopAfterAttempt,\n            ...fields,\n        });\n    }\n    /**\n     * Bind config to a Runnable, returning a new Runnable.\n     * @param config New configuration parameters to attach to the new runnable.\n     * @returns A new RunnableBinding with a config matching what's passed.\n     */\n    withConfig(config) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableBinding({\n            bound: this,\n            config,\n            kwargs: {},\n        });\n    }\n    /**\n     * Create a new runnable from the current one that will try invoking\n     * other passed fallback runnables if the initial invocation fails.\n     * @param fields.fallbacks Other runnables to call if the runnable errors.\n     * @returns A new RunnableWithFallbacks.\n     */\n    withFallbacks(fields) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableWithFallbacks({\n            runnable: this,\n            fallbacks: fields.fallbacks,\n        });\n    }\n    _getOptionsList(options, length = 0) {\n        if (Array.isArray(options)) {\n            if (options.length !== length) {\n                throw new Error(`Passed \"options\" must be an array with the same length as the inputs, but got ${options.length} options for ${length} inputs`);\n            }\n            return options.map(ensureConfig);\n        }\n        return Array.from({ length }, () => ensureConfig(options));\n    }\n    async batch(inputs, options, batchOptions) {\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const maxConcurrency = configList[0]?.maxConcurrency ?? batchOptions?.maxConcurrency;\n        const caller = new AsyncCaller({\n            maxConcurrency,\n            onFailedAttempt: (e) => {\n                throw e;\n            },\n        });\n        const batchCalls = inputs.map((input, i) => caller.call(async () => {\n            try {\n                const result = await this.invoke(input, configList[i]);\n                return result;\n            }\n            catch (e) {\n                if (batchOptions?.returnExceptions) {\n                    return e;\n                }\n                throw e;\n            }\n        }));\n        return Promise.all(batchCalls);\n    }\n    /**\n     * Default streaming implementation.\n     * Subclasses should override this method if they support streaming output.\n     * @param input\n     * @param options\n     */\n    async *_streamIterator(input, options) {\n        yield this.invoke(input, options);\n    }\n    /**\n     * Stream output in chunks.\n     * @param input\n     * @param options\n     * @returns A readable stream that is also an iterable.\n     */\n    async stream(input, options) {\n        // Buffer the first streamed chunk to allow for initial errors\n        // to surface immediately.\n        const wrappedGenerator = new AsyncGeneratorWithSetup(this._streamIterator(input, ensureConfig(options)));\n        await wrappedGenerator.setup;\n        return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n    _separateRunnableConfigFromCallOptions(options = {}) {\n        const runnableConfig = ensureConfig({\n            callbacks: options.callbacks,\n            tags: options.tags,\n            metadata: options.metadata,\n            runName: options.runName,\n            configurable: options.configurable,\n            recursionLimit: options.recursionLimit,\n            maxConcurrency: options.maxConcurrency,\n        });\n        const callOptions = { ...options };\n        delete callOptions.callbacks;\n        delete callOptions.tags;\n        delete callOptions.metadata;\n        delete callOptions.runName;\n        delete callOptions.configurable;\n        delete callOptions.recursionLimit;\n        delete callOptions.maxConcurrency;\n        return [runnableConfig, callOptions];\n    }\n    async _callWithConfig(func, input, options) {\n        const config = ensureConfig(options);\n        const callbackManager_ = await getCallbackManagerForConfig(config);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), undefined, config?.runType, undefined, undefined, config?.runName ?? this.getName());\n        let output;\n        try {\n            output = await func.call(this, input, config, runManager);\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n        return output;\n    }\n    /**\n     * Internal method that handles batching and configuration for a runnable\n     * It takes a function, input values, and optional configuration, and\n     * returns a promise that resolves to the output values.\n     * @param func The function to be executed for each input value.\n     * @param input The input values to be processed.\n     * @param config Optional configuration for the function execution.\n     * @returns A promise that resolves to the output values.\n     */\n    async _batchWithConfig(func, inputs, options, batchOptions) {\n        const optionsList = this._getOptionsList(options ?? {}, inputs.length);\n        const callbackManagers = await Promise.all(optionsList.map(getCallbackManagerForConfig));\n        const runManagers = await Promise.all(callbackManagers.map((callbackManager, i) => callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), undefined, optionsList[i].runType, undefined, undefined, optionsList[i].runName ?? this.getName())));\n        let outputs;\n        try {\n            outputs = await func.call(this, inputs, optionsList, runManagers, batchOptions);\n        }\n        catch (e) {\n            await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(e)));\n            throw e;\n        }\n        await Promise.all(runManagers.map((runManager) => runManager?.handleChainEnd(_coerceToDict(outputs, \"output\"))));\n        return outputs;\n    }\n    /**\n     * Helper method to transform an Iterator of Input values into an Iterator of\n     * Output values, with callbacks.\n     * Use this to implement `stream()` or `transform()` in Runnable subclasses.\n     */\n    async *_transformStreamWithConfig(inputGenerator, transformer, options) {\n        let finalInput;\n        let finalInputSupported = true;\n        let finalOutput;\n        let finalOutputSupported = true;\n        const config = ensureConfig(options);\n        const callbackManager_ = await getCallbackManagerForConfig(config);\n        async function* wrapInputForTracing() {\n            for await (const chunk of inputGenerator) {\n                if (finalInputSupported) {\n                    if (finalInput === undefined) {\n                        finalInput = chunk;\n                    }\n                    else {\n                        try {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            finalInput = concat(finalInput, chunk);\n                        }\n                        catch {\n                            finalInput = undefined;\n                            finalInputSupported = false;\n                        }\n                    }\n                }\n                yield chunk;\n            }\n        }\n        let runManager;\n        try {\n            const pipe = await pipeGeneratorWithSetup(transformer.bind(this), wrapInputForTracing(), async () => callbackManager_?.handleChainStart(this.toJSON(), { input: \"\" }, undefined, config?.runType, undefined, undefined, config?.runName ?? this.getName()), config);\n            runManager = pipe.setup;\n            const isLogStreamHandler = (handler) => handler.name === \"log_stream_tracer\";\n            const streamLogHandler = runManager?.handlers.find(isLogStreamHandler);\n            let iterator = pipe.output;\n            if (streamLogHandler !== undefined && runManager !== undefined) {\n                iterator = await streamLogHandler.tapOutputIterable(runManager.runId, pipe.output);\n            }\n            for await (const chunk of iterator) {\n                yield chunk;\n                if (finalOutputSupported) {\n                    if (finalOutput === undefined) {\n                        finalOutput = chunk;\n                    }\n                    else {\n                        try {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            finalOutput = concat(finalOutput, chunk);\n                        }\n                        catch {\n                            finalOutput = undefined;\n                            finalOutputSupported = false;\n                        }\n                    }\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e, undefined, undefined, undefined, {\n                inputs: _coerceToDict(finalInput, \"input\"),\n            });\n            throw e;\n        }\n        await runManager?.handleChainEnd(finalOutput ?? {}, undefined, undefined, undefined, { inputs: _coerceToDict(finalInput, \"input\") });\n    }\n    getGraph(_) {\n        const graph = new Graph();\n        // TODO: Add input schema for runnables\n        const inputNode = graph.addNode({\n            name: `${this.getName()}Input`,\n            schema: z.any(),\n        });\n        const runnableNode = graph.addNode(this);\n        // TODO: Add output schemas for runnables\n        const outputNode = graph.addNode({\n            name: `${this.getName()}Output`,\n            schema: z.any(),\n        });\n        graph.addEdge(inputNode, runnableNode);\n        graph.addEdge(runnableNode, outputNode);\n        return graph;\n    }\n    /**\n     * Create a new runnable sequence that runs each individual runnable in series,\n     * piping the output of one runnable into another runnable or runnable-like.\n     * @param coerceable A runnable, function, or object whose values are functions or runnables.\n     * @returns A new runnable sequence.\n     */\n    pipe(coerceable) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableSequence({\n            first: this,\n            last: _coerceToRunnable(coerceable),\n        });\n    }\n    /**\n     * Pick keys from the dict output of this runnable. Returns a new runnable.\n     */\n    pick(keys) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return this.pipe(new RunnablePick(keys));\n    }\n    /**\n     * Assigns new fields to the dict output of this runnable. Returns a new runnable.\n     */\n    assign(mapping) {\n        return this.pipe(\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        new RunnableAssign(\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        new RunnableMap({ steps: mapping })));\n    }\n    /**\n     * Default implementation of transform, which buffers input and then calls stream.\n     * Subclasses should override this method if they can start producing output while\n     * input is still being generated.\n     * @param generator\n     * @param options\n     */\n    async *transform(generator, options) {\n        let finalChunk;\n        for await (const chunk of generator) {\n            if (finalChunk === undefined) {\n                finalChunk = chunk;\n            }\n            else {\n                // Make a best effort to gather, for any type that supports concat.\n                // This method should throw an error if gathering fails.\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                finalChunk = concat(finalChunk, chunk);\n            }\n        }\n        yield* this._streamIterator(finalChunk, ensureConfig(options));\n    }\n    /**\n     * Stream all output from a runnable, as reported to the callback system.\n     * This includes all inner runs of LLMs, Retrievers, Tools, etc.\n     * Output is streamed as Log objects, which include a list of\n     * jsonpatch ops that describe how the state of the run has changed in each\n     * step, and the final state of the run.\n     * The jsonpatch ops can be applied in order to construct state.\n     * @param input\n     * @param options\n     * @param streamOptions\n     */\n    async *streamLog(input, options, streamOptions) {\n        const logStreamCallbackHandler = new LogStreamCallbackHandler({\n            ...streamOptions,\n            autoClose: false,\n            _schemaFormat: \"original\",\n        });\n        const config = ensureConfig(options);\n        yield* this._streamLog(input, logStreamCallbackHandler, config);\n    }\n    async *_streamLog(input, logStreamCallbackHandler, config) {\n        const { callbacks } = config;\n        if (callbacks === undefined) {\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = [logStreamCallbackHandler];\n        }\n        else if (Array.isArray(callbacks)) {\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = callbacks.concat([logStreamCallbackHandler]);\n        }\n        else {\n            const copiedCallbacks = callbacks.copy();\n            copiedCallbacks.inheritableHandlers.push(logStreamCallbackHandler);\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = copiedCallbacks;\n        }\n        const runnableStreamPromise = this.stream(input, config);\n        async function consumeRunnableStream() {\n            try {\n                const runnableStream = await runnableStreamPromise;\n                for await (const chunk of runnableStream) {\n                    const patch = new RunLogPatch({\n                        ops: [\n                            {\n                                op: \"add\",\n                                path: \"/streamed_output/-\",\n                                value: chunk,\n                            },\n                        ],\n                    });\n                    await logStreamCallbackHandler.writer.write(patch);\n                }\n            }\n            finally {\n                await logStreamCallbackHandler.writer.close();\n            }\n        }\n        const runnableStreamConsumePromise = consumeRunnableStream();\n        try {\n            for await (const log of logStreamCallbackHandler) {\n                yield log;\n            }\n        }\n        finally {\n            await runnableStreamConsumePromise;\n        }\n    }\n    /**\n     * Generate a stream of events emitted by the internal steps of the runnable.\n     *\n     * Use to create an iterator over StreamEvents that provide real-time information\n     * about the progress of the runnable, including StreamEvents from intermediate\n     * results.\n     *\n     * A StreamEvent is a dictionary with the following schema:\n     *\n     * - `event`: string - Event names are of the format: on_[runnable_type]_(start|stream|end).\n     * - `name`: string - The name of the runnable that generated the event.\n     * - `run_id`: string - Randomly generated ID associated with the given execution of\n     *   the runnable that emitted the event. A child runnable that gets invoked as part of the execution of a\n     *   parent runnable is assigned its own unique ID.\n     * - `tags`: string[] - The tags of the runnable that generated the event.\n     * - `metadata`: Record<string, any> - The metadata of the runnable that generated the event.\n     * - `data`: Record<string, any>\n     *\n     * Below is a table that illustrates some events that might be emitted by various\n     * chains. Metadata fields have been omitted from the table for brevity.\n     * Chain definitions have been included after the table.\n     *\n     * | event                | name             | chunk                              | input                                         | output                                          |\n     * |----------------------|------------------|------------------------------------|-----------------------------------------------|-------------------------------------------------|\n     * | on_llm_start         | [model name]     |                                    | {'input': 'hello'}                            |                                                 |\n     * | on_llm_stream        | [model name]     | 'Hello' OR AIMessageChunk(\"hello\") |                                               |                                                 |\n     * | on_llm_end           | [model name]     |                                    | 'Hello human!'                                |\n     * | on_chain_start       | format_docs      |                                    |                                               |                                                 |\n     * | on_chain_stream      | format_docs      | \"hello world!, goodbye world!\"     |                                               |                                                 |\n     * | on_chain_end         | format_docs      |                                    | [Document(...)]                               | \"hello world!, goodbye world!\"                  |\n     * | on_tool_start        | some_tool        |                                    | {\"x\": 1, \"y\": \"2\"}                            |                                                 |\n     * | on_tool_stream       | some_tool        |   {\"x\": 1, \"y\": \"2\"}               |                                               |                                                 |\n     * | on_tool_end          | some_tool        |                                    |                                               | {\"x\": 1, \"y\": \"2\"}                              |\n     * | on_retriever_start   | [retriever name] |                                    | {\"query\": \"hello\"}                            |                                                 |\n     * | on_retriever_chunk   | [retriever name] |  {documents: [...]}                |                                               |                                                 |\n     * | on_retriever_end     | [retriever name] |                                    | {\"query\": \"hello\"}                            | {documents: [...]}                              |\n     * | on_prompt_start      | [template_name]  |                                    | {\"question\": \"hello\"}                         |                                                 |\n     * | on_prompt_end        | [template_name]  |                                    | {\"question\": \"hello\"}                         | ChatPromptValue(messages: [SystemMessage, ...]) |\n     */\n    async *streamEvents(input, options, streamOptions) {\n        if (options.version !== \"v1\") {\n            throw new Error(`Only version \"v1\" of the events schema is currently supported.`);\n        }\n        let runLog;\n        let hasEncounteredStartEvent = false;\n        const config = ensureConfig(options);\n        const rootTags = config.tags ?? [];\n        const rootMetadata = config.metadata ?? {};\n        const rootName = config.runName ?? this.getName();\n        const logStreamCallbackHandler = new LogStreamCallbackHandler({\n            ...streamOptions,\n            autoClose: false,\n            _schemaFormat: \"streaming_events\",\n        });\n        const rootEventFilter = new _RootEventFilter({\n            ...streamOptions,\n        });\n        const logStream = this._streamLog(input, logStreamCallbackHandler, config);\n        for await (const log of logStream) {\n            if (!runLog) {\n                runLog = RunLog.fromRunLogPatch(log);\n            }\n            else {\n                runLog = runLog.concat(log);\n            }\n            if (runLog.state === undefined) {\n                throw new Error(`Internal error: \"streamEvents\" state is missing. Please open a bug report.`);\n            }\n            // Yield the start event for the root runnable if it hasn't been seen.\n            // The root run is never filtered out\n            if (!hasEncounteredStartEvent) {\n                hasEncounteredStartEvent = true;\n                const state = { ...runLog.state };\n                const event = {\n                    run_id: state.id,\n                    event: `on_${state.type}_start`,\n                    name: rootName,\n                    tags: rootTags,\n                    metadata: rootMetadata,\n                    data: {\n                        input,\n                    },\n                };\n                if (rootEventFilter.includeEvent(event, state.type)) {\n                    yield event;\n                }\n            }\n            const paths = log.ops\n                .filter((op) => op.path.startsWith(\"/logs/\"))\n                .map((op) => op.path.split(\"/\")[2]);\n            const dedupedPaths = [...new Set(paths)];\n            for (const path of dedupedPaths) {\n                let eventType;\n                let data = {};\n                const logEntry = runLog.state.logs[path];\n                if (logEntry.end_time === undefined) {\n                    if (logEntry.streamed_output.length > 0) {\n                        eventType = \"stream\";\n                    }\n                    else {\n                        eventType = \"start\";\n                    }\n                }\n                else {\n                    eventType = \"end\";\n                }\n                if (eventType === \"start\") {\n                    // Include the inputs with the start event if they are available.\n                    // Usually they will NOT be available for components that operate\n                    // on streams, since those components stream the input and\n                    // don't know its final value until the end of the stream.\n                    if (logEntry.inputs !== undefined) {\n                        data.input = logEntry.inputs;\n                    }\n                }\n                else if (eventType === \"end\") {\n                    if (logEntry.inputs !== undefined) {\n                        data.input = logEntry.inputs;\n                    }\n                    data.output = logEntry.final_output;\n                }\n                else if (eventType === \"stream\") {\n                    const chunkCount = logEntry.streamed_output.length;\n                    if (chunkCount !== 1) {\n                        throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: \"${logEntry.name}\"`);\n                    }\n                    data = { chunk: logEntry.streamed_output[0] };\n                    // Clean up the stream, we don't need it anymore.\n                    // And this avoids duplicates as well!\n                    logEntry.streamed_output = [];\n                }\n                yield {\n                    event: `on_${logEntry.type}_${eventType}`,\n                    name: logEntry.name,\n                    run_id: logEntry.id,\n                    tags: logEntry.tags,\n                    metadata: logEntry.metadata,\n                    data,\n                };\n            }\n            // Finally, we take care of the streaming output from the root chain\n            // if there is any.\n            const { state } = runLog;\n            if (state.streamed_output.length > 0) {\n                const chunkCount = state.streamed_output.length;\n                if (chunkCount !== 1) {\n                    throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: \"${state.name}\"`);\n                }\n                const data = { chunk: state.streamed_output[0] };\n                // Clean up the stream, we don't need it anymore.\n                state.streamed_output = [];\n                const event = {\n                    event: `on_${state.type}_stream`,\n                    run_id: state.id,\n                    tags: rootTags,\n                    metadata: rootMetadata,\n                    name: rootName,\n                    data,\n                };\n                if (rootEventFilter.includeEvent(event, state.type)) {\n                    yield event;\n                }\n            }\n        }\n        const state = runLog?.state;\n        if (state !== undefined) {\n            // Finally, yield the end event for the root runnable.\n            const event = {\n                event: `on_${state.type}_end`,\n                name: rootName,\n                run_id: state.id,\n                tags: rootTags,\n                metadata: rootMetadata,\n                data: {\n                    output: state.final_output,\n                },\n            };\n            if (rootEventFilter.includeEvent(event, state.type))\n                yield event;\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static isRunnable(thing) {\n        return isRunnableInterface(thing);\n    }\n    /**\n     * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n     * The Run object contains information about the run, including its id,\n     * type, input, output, error, startTime, endTime, and any tags or metadata\n     * added to the run.\n     *\n     * @param {Object} params - The object containing the callback functions.\n     * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n     * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n     * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n     */\n    withListeners({ onStart, onEnd, onError, }) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableBinding({\n            bound: this,\n            config: {},\n            configFactories: [\n                (config) => ({\n                    callbacks: [\n                        new RootListenersTracer({\n                            config,\n                            onStart,\n                            onEnd,\n                            onError,\n                        }),\n                    ],\n                }),\n            ],\n        });\n    }\n}\n/**\n * A runnable that delegates calls to another runnable with a set of kwargs.\n */\nexport class RunnableBinding extends Runnable {\n    static lc_name() {\n        return \"RunnableBinding\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"bound\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"config\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"kwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"configFactories\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.bound = fields.bound;\n        this.kwargs = fields.kwargs;\n        this.config = fields.config;\n        this.configFactories = fields.configFactories;\n    }\n    getName(suffix) {\n        return this.bound.getName(suffix);\n    }\n    async _mergeConfig(...options) {\n        const config = mergeConfigs(this.config, ...options);\n        return mergeConfigs(config, ...(this.configFactories\n            ? await Promise.all(this.configFactories.map(async (configFactory) => await configFactory(config)))\n            : []));\n    }\n    bind(kwargs) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return new this.constructor({\n            bound: this.bound,\n            kwargs: { ...this.kwargs, ...kwargs },\n            config: this.config,\n        });\n    }\n    withConfig(config) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return new this.constructor({\n            bound: this.bound,\n            kwargs: this.kwargs,\n            config: { ...this.config, ...config },\n        });\n    }\n    withRetry(fields) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return new this.constructor({\n            bound: this.bound.withRetry(fields),\n            kwargs: this.kwargs,\n            config: this.config,\n        });\n    }\n    async invoke(input, options) {\n        return this.bound.invoke(input, await this._mergeConfig(ensureConfig(options), this.kwargs));\n    }\n    async batch(inputs, options, batchOptions) {\n        const mergedOptions = Array.isArray(options)\n            ? await Promise.all(options.map(async (individualOption) => this._mergeConfig(ensureConfig(individualOption), this.kwargs)))\n            : await this._mergeConfig(ensureConfig(options), this.kwargs);\n        return this.bound.batch(inputs, mergedOptions, batchOptions);\n    }\n    async *_streamIterator(input, options) {\n        yield* this.bound._streamIterator(input, await this._mergeConfig(ensureConfig(options), this.kwargs));\n    }\n    async stream(input, options) {\n        return this.bound.stream(input, await this._mergeConfig(ensureConfig(options), this.kwargs));\n    }\n    async *transform(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    generator, options) {\n        yield* this.bound.transform(generator, await this._mergeConfig(ensureConfig(options), this.kwargs));\n    }\n    async *streamEvents(input, options, streamOptions) {\n        yield* this.bound.streamEvents(input, {\n            ...(await this._mergeConfig(ensureConfig(options), this.kwargs)),\n            version: options.version,\n        }, streamOptions);\n    }\n    static isRunnableBinding(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    thing\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) {\n        return thing.bound && Runnable.isRunnable(thing.bound);\n    }\n    /**\n     * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n     * The Run object contains information about the run, including its id,\n     * type, input, output, error, startTime, endTime, and any tags or metadata\n     * added to the run.\n     *\n     * @param {Object} params - The object containing the callback functions.\n     * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n     * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n     * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n     */\n    withListeners({ onStart, onEnd, onError, }) {\n        return new RunnableBinding({\n            bound: this.bound,\n            kwargs: this.kwargs,\n            config: this.config,\n            configFactories: [\n                (config) => ({\n                    callbacks: [\n                        new RootListenersTracer({\n                            config,\n                            onStart,\n                            onEnd,\n                            onError,\n                        }),\n                    ],\n                }),\n            ],\n        });\n    }\n}\n/**\n * A runnable that delegates calls to another runnable\n * with each element of the input sequence.\n */\nexport class RunnableEach extends Runnable {\n    static lc_name() {\n        return \"RunnableEach\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"bound\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.bound = fields.bound;\n    }\n    /**\n     * Binds the runnable with the specified arguments.\n     * @param kwargs The arguments to bind the runnable with.\n     * @returns A new instance of the `RunnableEach` class that is bound with the specified arguments.\n     */\n    bind(kwargs) {\n        return new RunnableEach({\n            bound: this.bound.bind(kwargs),\n        });\n    }\n    /**\n     * Invokes the runnable with the specified input and configuration.\n     * @param input The input to invoke the runnable with.\n     * @param config The configuration to invoke the runnable with.\n     * @returns A promise that resolves to the output of the runnable.\n     */\n    async invoke(inputs, config) {\n        return this._callWithConfig(this._invoke, inputs, config);\n    }\n    /**\n     * A helper method that is used to invoke the runnable with the specified input and configuration.\n     * @param input The input to invoke the runnable with.\n     * @param config The configuration to invoke the runnable with.\n     * @returns A promise that resolves to the output of the runnable.\n     */\n    async _invoke(inputs, config, runManager) {\n        return this.bound.batch(inputs, patchConfig(config, { callbacks: runManager?.getChild() }));\n    }\n    /**\n     * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n     * The Run object contains information about the run, including its id,\n     * type, input, output, error, startTime, endTime, and any tags or metadata\n     * added to the run.\n     *\n     * @param {Object} params - The object containing the callback functions.\n     * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n     * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n     * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n     */\n    withListeners({ onStart, onEnd, onError, }) {\n        return new RunnableEach({\n            bound: this.bound.withListeners({ onStart, onEnd, onError }),\n        });\n    }\n}\n/**\n * Base class for runnables that can be retried a\n * specified number of times.\n */\nexport class RunnableRetry extends RunnableBinding {\n    static lc_name() {\n        return \"RunnableRetry\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"maxAttemptNumber\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 3\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"onFailedAttempt\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: () => { }\n        });\n        this.maxAttemptNumber = fields.maxAttemptNumber ?? this.maxAttemptNumber;\n        this.onFailedAttempt = fields.onFailedAttempt ?? this.onFailedAttempt;\n    }\n    _patchConfigForRetry(attempt, config, runManager) {\n        const tag = attempt > 1 ? `retry:attempt:${attempt}` : undefined;\n        return patchConfig(config, { callbacks: runManager?.getChild(tag) });\n    }\n    async _invoke(input, config, runManager) {\n        return pRetry((attemptNumber) => super.invoke(input, this._patchConfigForRetry(attemptNumber, config, runManager)), {\n            onFailedAttempt: this.onFailedAttempt,\n            retries: Math.max(this.maxAttemptNumber - 1, 0),\n            randomize: true,\n        });\n    }\n    /**\n     * Method that invokes the runnable with the specified input, run manager,\n     * and config. It handles the retry logic by catching any errors and\n     * recursively invoking itself with the updated config for the next retry\n     * attempt.\n     * @param input The input for the runnable.\n     * @param runManager The run manager for the runnable.\n     * @param config The config for the runnable.\n     * @returns A promise that resolves to the output of the runnable.\n     */\n    async invoke(input, config) {\n        return this._callWithConfig(this._invoke, input, config);\n    }\n    async _batch(inputs, configs, runManagers, batchOptions) {\n        const resultsMap = {};\n        try {\n            await pRetry(async (attemptNumber) => {\n                const remainingIndexes = inputs\n                    .map((_, i) => i)\n                    .filter((i) => resultsMap[i.toString()] === undefined ||\n                    // eslint-disable-next-line no-instanceof/no-instanceof\n                    resultsMap[i.toString()] instanceof Error);\n                const remainingInputs = remainingIndexes.map((i) => inputs[i]);\n                const patchedConfigs = remainingIndexes.map((i) => this._patchConfigForRetry(attemptNumber, configs?.[i], runManagers?.[i]));\n                const results = await super.batch(remainingInputs, patchedConfigs, {\n                    ...batchOptions,\n                    returnExceptions: true,\n                });\n                let firstException;\n                for (let i = 0; i < results.length; i += 1) {\n                    const result = results[i];\n                    const resultMapIndex = remainingIndexes[i];\n                    // eslint-disable-next-line no-instanceof/no-instanceof\n                    if (result instanceof Error) {\n                        if (firstException === undefined) {\n                            firstException = result;\n                        }\n                    }\n                    resultsMap[resultMapIndex.toString()] = result;\n                }\n                if (firstException) {\n                    throw firstException;\n                }\n                return results;\n            }, {\n                onFailedAttempt: this.onFailedAttempt,\n                retries: Math.max(this.maxAttemptNumber - 1, 0),\n                randomize: true,\n            });\n        }\n        catch (e) {\n            if (batchOptions?.returnExceptions !== true) {\n                throw e;\n            }\n        }\n        return Object.keys(resultsMap)\n            .sort((a, b) => parseInt(a, 10) - parseInt(b, 10))\n            .map((key) => resultsMap[parseInt(key, 10)]);\n    }\n    async batch(inputs, options, batchOptions) {\n        return this._batchWithConfig(this._batch.bind(this), inputs, options, batchOptions);\n    }\n}\n/**\n * A sequence of runnables, where the output of each is the input of the next.\n * @example\n * ```typescript\n * const promptTemplate = PromptTemplate.fromTemplate(\n *   \"Tell me a joke about {topic}\",\n * );\n * const chain = RunnableSequence.from([promptTemplate, new ChatOpenAI({})]);\n * const result = await chain.invoke({ topic: \"bears\" });\n * ```\n */\nexport class RunnableSequence extends Runnable {\n    static lc_name() {\n        return \"RunnableSequence\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"first\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"middle\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"last\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        this.first = fields.first;\n        this.middle = fields.middle ?? this.middle;\n        this.last = fields.last;\n        this.name = fields.name;\n    }\n    get steps() {\n        return [this.first, ...this.middle, this.last];\n    }\n    async invoke(input, options) {\n        const config = ensureConfig(options);\n        const callbackManager_ = await getCallbackManagerForConfig(config);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), undefined, undefined, undefined, undefined, config?.runName);\n        let nextStepInput = input;\n        let finalOutput;\n        try {\n            const initialSteps = [this.first, ...this.middle];\n            for (let i = 0; i < initialSteps.length; i += 1) {\n                const step = initialSteps[i];\n                nextStepInput = await step.invoke(nextStepInput, patchConfig(config, {\n                    callbacks: runManager?.getChild(`seq:step:${i + 1}`),\n                }));\n            }\n            // TypeScript can't detect that the last output of the sequence returns RunOutput, so call it out of the loop here\n            finalOutput = await this.last.invoke(nextStepInput, patchConfig(config, {\n                callbacks: runManager?.getChild(`seq:step:${this.steps.length}`),\n            }));\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n        return finalOutput;\n    }\n    async batch(inputs, options, batchOptions) {\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const callbackManagers = await Promise.all(configList.map(getCallbackManagerForConfig));\n        const runManagers = await Promise.all(callbackManagers.map((callbackManager, i) => callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), undefined, undefined, undefined, undefined, configList[i].runName)));\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let nextStepInputs = inputs;\n        try {\n            for (let i = 0; i < this.steps.length; i += 1) {\n                const step = this.steps[i];\n                nextStepInputs = await step.batch(nextStepInputs, runManagers.map((runManager, j) => {\n                    const childRunManager = runManager?.getChild(`seq:step:${i + 1}`);\n                    return patchConfig(configList[j], { callbacks: childRunManager });\n                }), batchOptions);\n            }\n        }\n        catch (e) {\n            await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(e)));\n            throw e;\n        }\n        await Promise.all(runManagers.map((runManager) => runManager?.handleChainEnd(_coerceToDict(nextStepInputs, \"output\"))));\n        return nextStepInputs;\n    }\n    async *_streamIterator(input, options) {\n        const callbackManager_ = await getCallbackManagerForConfig(options);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), undefined, undefined, undefined, undefined, options?.runName);\n        const steps = [this.first, ...this.middle, this.last];\n        let concatSupported = true;\n        let finalOutput;\n        async function* inputGenerator() {\n            yield input;\n        }\n        try {\n            let finalGenerator = steps[0].transform(inputGenerator(), patchConfig(options, {\n                callbacks: runManager?.getChild(`seq:step:1`),\n            }));\n            for (let i = 1; i < steps.length; i += 1) {\n                const step = steps[i];\n                finalGenerator = await step.transform(finalGenerator, patchConfig(options, {\n                    callbacks: runManager?.getChild(`seq:step:${i + 1}`),\n                }));\n            }\n            for await (const chunk of finalGenerator) {\n                yield chunk;\n                if (concatSupported) {\n                    if (finalOutput === undefined) {\n                        finalOutput = chunk;\n                    }\n                    else {\n                        try {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            finalOutput = concat(finalOutput, chunk);\n                        }\n                        catch (e) {\n                            finalOutput = undefined;\n                            concatSupported = false;\n                        }\n                    }\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n    }\n    getGraph(config) {\n        const graph = new Graph();\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let currentLastNode = null;\n        this.steps.forEach((step, index) => {\n            const stepGraph = step.getGraph(config);\n            if (index !== 0) {\n                stepGraph.trimFirstNode();\n            }\n            if (index !== this.steps.length - 1) {\n                stepGraph.trimLastNode();\n            }\n            graph.extend(stepGraph);\n            const stepFirstNode = stepGraph.firstNode();\n            if (!stepFirstNode) {\n                throw new Error(`Runnable ${step} has no first node`);\n            }\n            if (currentLastNode) {\n                graph.addEdge(currentLastNode, stepFirstNode);\n            }\n            currentLastNode = stepGraph.lastNode();\n        });\n        return graph;\n    }\n    pipe(coerceable) {\n        if (RunnableSequence.isRunnableSequence(coerceable)) {\n            return new RunnableSequence({\n                first: this.first,\n                middle: this.middle.concat([\n                    this.last,\n                    coerceable.first,\n                    ...coerceable.middle,\n                ]),\n                last: coerceable.last,\n                name: this.name ?? coerceable.name,\n            });\n        }\n        else {\n            return new RunnableSequence({\n                first: this.first,\n                middle: [...this.middle, this.last],\n                last: _coerceToRunnable(coerceable),\n                name: this.name,\n            });\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static isRunnableSequence(thing) {\n        return Array.isArray(thing.middle) && Runnable.isRunnable(thing);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static from([first, ...runnables], name) {\n        return new RunnableSequence({\n            first: _coerceToRunnable(first),\n            middle: runnables.slice(0, -1).map(_coerceToRunnable),\n            last: _coerceToRunnable(runnables[runnables.length - 1]),\n            name,\n        });\n    }\n}\n/**\n * A runnable that runs a mapping of runnables in parallel,\n * and returns a mapping of their outputs.\n * @example\n * ```typescript\n * const mapChain = RunnableMap.from({\n *   joke: PromptTemplate.fromTemplate(\"Tell me a joke about {topic}\").pipe(\n *     new ChatAnthropic({}),\n *   ),\n *   poem: PromptTemplate.fromTemplate(\"write a 2-line poem about {topic}\").pipe(\n *     new ChatAnthropic({}),\n *   ),\n * });\n * const result = await mapChain.invoke({ topic: \"bear\" });\n * ```\n */\nexport class RunnableMap extends Runnable {\n    static lc_name() {\n        return \"RunnableMap\";\n    }\n    getStepsKeys() {\n        return Object.keys(this.steps);\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"steps\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.steps = {};\n        for (const [key, value] of Object.entries(fields.steps)) {\n            this.steps[key] = _coerceToRunnable(value);\n        }\n    }\n    static from(steps) {\n        return new RunnableMap({ steps });\n    }\n    async invoke(input, options) {\n        const config = ensureConfig(options);\n        const callbackManager_ = await getCallbackManagerForConfig(config);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), {\n            input,\n        }, undefined, undefined, undefined, undefined, config?.runName);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const output = {};\n        try {\n            await Promise.all(Object.entries(this.steps).map(async ([key, runnable]) => {\n                output[key] = await runnable.invoke(input, patchConfig(config, {\n                    callbacks: runManager?.getChild(`map:key:${key}`),\n                }));\n            }));\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(output);\n        return output;\n    }\n    async *_transform(generator, runManager, options) {\n        // shallow copy steps to ignore changes while iterating\n        const steps = { ...this.steps };\n        // each step gets a copy of the input iterator\n        const inputCopies = atee(generator, Object.keys(steps).length);\n        // start the first iteration of each output iterator\n        const tasks = new Map(Object.entries(steps).map(([key, runnable], i) => {\n            const gen = runnable.transform(inputCopies[i], patchConfig(options, {\n                callbacks: runManager?.getChild(`map:key:${key}`),\n            }));\n            return [key, gen.next().then((result) => ({ key, gen, result }))];\n        }));\n        // yield chunks as they become available,\n        // starting new iterations as needed,\n        // until all iterators are done\n        while (tasks.size) {\n            const { key, result, gen } = await Promise.race(tasks.values());\n            tasks.delete(key);\n            if (!result.done) {\n                yield { [key]: result.value };\n                tasks.set(key, gen.next().then((result) => ({ key, gen, result })));\n            }\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const wrappedGenerator = new AsyncGeneratorWithSetup(this.transform(generator(), options));\n        await wrappedGenerator.setup;\n        return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\n/**\n * A runnable that runs a callable.\n */\nexport class RunnableLambda extends Runnable {\n    static lc_name() {\n        return \"RunnableLambda\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.func = fields.func;\n    }\n    static from(func) {\n        return new RunnableLambda({\n            func,\n        });\n    }\n    async _invoke(input, config, runManager) {\n        return new Promise((resolve, reject) => {\n            const childConfig = patchConfig(config, {\n                callbacks: runManager?.getChild(),\n                recursionLimit: (config?.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1,\n            });\n            void AsyncLocalStorageProviderSingleton.getInstance().run(childConfig, async () => {\n                try {\n                    let output = await this.func(input, {\n                        ...childConfig,\n                        config: childConfig,\n                    });\n                    if (output && Runnable.isRunnable(output)) {\n                        if (config?.recursionLimit === 0) {\n                            throw new Error(\"Recursion limit reached.\");\n                        }\n                        output = await output.invoke(input, {\n                            ...childConfig,\n                            recursionLimit: (childConfig.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1,\n                        });\n                    }\n                    resolve(output);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        });\n    }\n    async invoke(input, options) {\n        return this._callWithConfig(this._invoke, input, options);\n    }\n    async *_transform(generator, runManager, config) {\n        let finalChunk;\n        for await (const chunk of generator) {\n            if (finalChunk === undefined) {\n                finalChunk = chunk;\n            }\n            else {\n                // Make a best effort to gather, for any type that supports concat.\n                try {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    finalChunk = concat(finalChunk, chunk);\n                }\n                catch (e) {\n                    finalChunk = chunk;\n                }\n            }\n        }\n        const output = await new Promise((resolve, reject) => {\n            void AsyncLocalStorageProviderSingleton.getInstance().run(config, async () => {\n                try {\n                    const res = await this.func(finalChunk, {\n                        ...config,\n                        config,\n                    });\n                    resolve(res);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        });\n        if (output && Runnable.isRunnable(output)) {\n            if (config?.recursionLimit === 0) {\n                throw new Error(\"Recursion limit reached.\");\n            }\n            const stream = await output.stream(finalChunk, patchConfig(config, {\n                callbacks: runManager?.getChild(),\n                recursionLimit: (config?.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1,\n            }));\n            for await (const chunk of stream) {\n                yield chunk;\n            }\n        }\n        else {\n            yield output;\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const wrappedGenerator = new AsyncGeneratorWithSetup(this.transform(generator(), options));\n        await wrappedGenerator.setup;\n        return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\nexport class RunnableParallel extends RunnableMap {\n}\n/**\n * A Runnable that can fallback to other Runnables if it fails.\n */\nexport class RunnableWithFallbacks extends Runnable {\n    static lc_name() {\n        return \"RunnableWithFallbacks\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"runnable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"fallbacks\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.runnable = fields.runnable;\n        this.fallbacks = fields.fallbacks;\n    }\n    *runnables() {\n        yield this.runnable;\n        for (const fallback of this.fallbacks) {\n            yield fallback;\n        }\n    }\n    async invoke(input, options) {\n        const callbackManager_ = await CallbackManager.configure(options?.callbacks, undefined, options?.tags, undefined, options?.metadata);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), undefined, undefined, undefined, undefined, options?.runName);\n        let firstError;\n        for (const runnable of this.runnables()) {\n            try {\n                const output = await runnable.invoke(input, patchConfig(options, { callbacks: runManager?.getChild() }));\n                await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n                return output;\n            }\n            catch (e) {\n                if (firstError === undefined) {\n                    firstError = e;\n                }\n            }\n        }\n        if (firstError === undefined) {\n            throw new Error(\"No error stored at end of fallback.\");\n        }\n        await runManager?.handleChainError(firstError);\n        throw firstError;\n    }\n    async batch(inputs, options, batchOptions) {\n        if (batchOptions?.returnExceptions) {\n            throw new Error(\"Not implemented.\");\n        }\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const callbackManagers = await Promise.all(configList.map((config) => CallbackManager.configure(config?.callbacks, undefined, config?.tags, undefined, config?.metadata)));\n        const runManagers = await Promise.all(callbackManagers.map((callbackManager, i) => callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), undefined, undefined, undefined, undefined, configList[i].runName)));\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let firstError;\n        for (const runnable of this.runnables()) {\n            try {\n                const outputs = await runnable.batch(inputs, runManagers.map((runManager, j) => patchConfig(configList[j], {\n                    callbacks: runManager?.getChild(),\n                })), batchOptions);\n                await Promise.all(runManagers.map((runManager, i) => runManager?.handleChainEnd(_coerceToDict(outputs[i], \"output\"))));\n                return outputs;\n            }\n            catch (e) {\n                if (firstError === undefined) {\n                    firstError = e;\n                }\n            }\n        }\n        if (!firstError) {\n            throw new Error(\"No error stored at end of fallbacks.\");\n        }\n        await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(firstError)));\n        throw firstError;\n    }\n}\n// TODO: Figure out why the compiler needs help eliminating Error as a RunOutput type\nexport function _coerceToRunnable(coerceable) {\n    if (typeof coerceable === \"function\") {\n        return new RunnableLambda({ func: coerceable });\n    }\n    else if (Runnable.isRunnable(coerceable)) {\n        return coerceable;\n    }\n    else if (!Array.isArray(coerceable) && typeof coerceable === \"object\") {\n        const runnables = {};\n        for (const [key, value] of Object.entries(coerceable)) {\n            runnables[key] = _coerceToRunnable(value);\n        }\n        return new RunnableMap({\n            steps: runnables,\n        });\n    }\n    else {\n        throw new Error(`Expected a Runnable, function or object.\\nInstead got an unsupported type.`);\n    }\n}\n/**\n * A runnable that assigns key-value pairs to inputs of type `Record<string, unknown>`.\n */\nexport class RunnableAssign extends Runnable {\n    static lc_name() {\n        return \"RunnableAssign\";\n    }\n    constructor(fields) {\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (fields instanceof RunnableMap) {\n            // eslint-disable-next-line no-param-reassign\n            fields = { mapper: fields };\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"mapper\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.mapper = fields.mapper;\n    }\n    async invoke(input, options) {\n        const mapperResult = await this.mapper.invoke(input, options);\n        return {\n            ...input,\n            ...mapperResult,\n        };\n    }\n    async *_transform(generator, runManager, options) {\n        // collect mapper keys\n        const mapperKeys = this.mapper.getStepsKeys();\n        // create two input gens, one for the mapper, one for the input\n        const [forPassthrough, forMapper] = atee(generator);\n        // create mapper output gen\n        const mapperOutput = this.mapper.transform(forMapper, patchConfig(options, { callbacks: runManager?.getChild() }));\n        // start the mapper\n        const firstMapperChunkPromise = mapperOutput.next();\n        // yield the passthrough\n        for await (const chunk of forPassthrough) {\n            if (typeof chunk !== \"object\" || Array.isArray(chunk)) {\n                throw new Error(`RunnableAssign can only be used with objects as input, got ${typeof chunk}`);\n            }\n            const filtered = Object.fromEntries(Object.entries(chunk).filter(([key]) => !mapperKeys.includes(key)));\n            if (Object.keys(filtered).length > 0) {\n                yield filtered;\n            }\n        }\n        // yield the mapper output\n        yield (await firstMapperChunkPromise).value;\n        for await (const chunk of mapperOutput) {\n            yield chunk;\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const wrappedGenerator = new AsyncGeneratorWithSetup(this.transform(generator(), options));\n        await wrappedGenerator.setup;\n        return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\n/**\n * A runnable that assigns key-value pairs to inputs of type `Record<string, unknown>`.\n */\nexport class RunnablePick extends Runnable {\n    static lc_name() {\n        return \"RunnablePick\";\n    }\n    constructor(fields) {\n        if (typeof fields === \"string\" || Array.isArray(fields)) {\n            // eslint-disable-next-line no-param-reassign\n            fields = { keys: fields };\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"keys\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.keys = fields.keys;\n    }\n    async _pick(input) {\n        if (typeof this.keys === \"string\") {\n            return input[this.keys];\n        }\n        else {\n            const picked = this.keys\n                .map((key) => [key, input[key]])\n                .filter((v) => v[1] !== undefined);\n            return picked.length === 0 ? undefined : Object.fromEntries(picked);\n        }\n    }\n    async invoke(input, options) {\n        return this._callWithConfig(this._pick.bind(this), input, options);\n    }\n    async *_transform(generator) {\n        for await (const chunk of generator) {\n            const picked = await this._pick(chunk);\n            if (picked !== undefined) {\n                yield picked;\n            }\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const wrappedGenerator = new AsyncGeneratorWithSetup(this.transform(generator(), options));\n        await wrappedGenerator.setup;\n        return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}