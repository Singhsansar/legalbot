{"ast":null,"code":"import { AIMessage, HumanMessage, coerceMessageLikeToMessage } from \"../messages/index.js\";\nimport { RUN_KEY } from \"../outputs.js\";\nimport { BaseLanguageModel } from \"./base.js\";\nimport { CallbackManager } from \"../callbacks/manager.js\";\n/**\n * Creates a transform stream for encoding chat message chunks.\n * @deprecated Use {@link BytesOutputParser} instead\n * @returns A TransformStream instance that encodes chat message chunks.\n */\nexport function createChatMessageChunkEncoderStream() {\n  const textEncoder = new TextEncoder();\n  return new TransformStream({\n    transform(chunk, controller) {\n      controller.enqueue(textEncoder.encode(typeof chunk.content === \"string\" ? chunk.content : JSON.stringify(chunk.content)));\n    }\n  });\n}\n/**\n * Base class for chat models. It extends the BaseLanguageModel class and\n * provides methods for generating chat based on input messages.\n */\nexport class BaseChatModel extends BaseLanguageModel {\n  constructor(fields) {\n    super(fields);\n    // Only ever instantiated in main LangChain\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain\", \"chat_models\", this._llmType()]\n    });\n  }\n  _separateRunnableConfigFromCallOptions(options) {\n    const [runnableConfig, callOptions] = super._separateRunnableConfigFromCallOptions(options);\n    if (callOptions?.timeout && !callOptions.signal) {\n      callOptions.signal = AbortSignal.timeout(callOptions.timeout);\n    }\n    return [runnableConfig, callOptions];\n  }\n  /**\n   * Invokes the chat model with a single input.\n   * @param input The input for the language model.\n   * @param options The call options.\n   * @returns A Promise that resolves to a BaseMessageChunk.\n   */\n  async invoke(input, options) {\n    const promptValue = BaseChatModel._convertInputToPromptValue(input);\n    const result = await this.generatePrompt([promptValue], options, options?.callbacks);\n    const chatGeneration = result.generations[0][0];\n    // TODO: Remove cast after figuring out inheritance\n    return chatGeneration.message;\n  }\n  // eslint-disable-next-line require-yield\n  async *_streamResponseChunks(_messages, _options, _runManager) {\n    throw new Error(\"Not implemented.\");\n  }\n  async *_streamIterator(input, options) {\n    // Subclass check required to avoid double callbacks with default implementation\n    if (this._streamResponseChunks === BaseChatModel.prototype._streamResponseChunks) {\n      yield this.invoke(input, options);\n    } else {\n      const prompt = BaseChatModel._convertInputToPromptValue(input);\n      const messages = prompt.toChatMessages();\n      const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptions(options);\n      const callbackManager_ = await CallbackManager.configure(runnableConfig.callbacks, this.callbacks, runnableConfig.tags, this.tags, runnableConfig.metadata, this.metadata, {\n        verbose: this.verbose\n      });\n      const extra = {\n        options: callOptions,\n        invocation_params: this?.invocationParams(callOptions),\n        batch_size: 1\n      };\n      const runManagers = await callbackManager_?.handleChatModelStart(this.toJSON(), [messages], undefined, undefined, extra, undefined, undefined, runnableConfig.runName);\n      let generationChunk;\n      try {\n        for await (const chunk of this._streamResponseChunks(messages, callOptions, runManagers?.[0])) {\n          chunk.message.response_metadata = {\n            ...chunk.generationInfo,\n            ...chunk.message.response_metadata\n          };\n          yield chunk.message;\n          if (!generationChunk) {\n            generationChunk = chunk;\n          } else {\n            generationChunk = generationChunk.concat(chunk);\n          }\n        }\n      } catch (err) {\n        await Promise.all((runManagers ?? []).map(runManager => runManager?.handleLLMError(err)));\n        throw err;\n      }\n      await Promise.all((runManagers ?? []).map(runManager => runManager?.handleLLMEnd({\n        // TODO: Remove cast after figuring out inheritance\n        generations: [[generationChunk]]\n      })));\n    }\n  }\n  /** @ignore */\n  async _generateUncached(messages, parsedOptions, handledOptions) {\n    const baseMessages = messages.map(messageList => messageList.map(coerceMessageLikeToMessage));\n    // create callback manager and start run\n    const callbackManager_ = await CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, handledOptions.metadata, this.metadata, {\n      verbose: this.verbose\n    });\n    const extra = {\n      options: parsedOptions,\n      invocation_params: this?.invocationParams(parsedOptions),\n      batch_size: 1\n    };\n    const runManagers = await callbackManager_?.handleChatModelStart(this.toJSON(), baseMessages, undefined, undefined, extra, undefined, undefined, handledOptions.runName);\n    // generate results\n    const results = await Promise.allSettled(baseMessages.map((messageList, i) => this._generate(messageList, {\n      ...parsedOptions,\n      promptIndex: i\n    }, runManagers?.[i])));\n    // handle results\n    const generations = [];\n    const llmOutputs = [];\n    await Promise.all(results.map(async (pResult, i) => {\n      if (pResult.status === \"fulfilled\") {\n        const result = pResult.value;\n        for (const generation of result.generations) {\n          generation.message.response_metadata = {\n            ...generation.generationInfo,\n            ...generation.message.response_metadata\n          };\n        }\n        if (result.generations.length === 1) {\n          result.generations[0].message.response_metadata = {\n            ...result.llmOutput,\n            ...result.generations[0].message.response_metadata\n          };\n        }\n        generations[i] = result.generations;\n        llmOutputs[i] = result.llmOutput;\n        return runManagers?.[i]?.handleLLMEnd({\n          generations: [result.generations],\n          llmOutput: result.llmOutput\n        });\n      } else {\n        // status === \"rejected\"\n        await runManagers?.[i]?.handleLLMError(pResult.reason);\n        return Promise.reject(pResult.reason);\n      }\n    }));\n    // create combined output\n    const output = {\n      generations,\n      llmOutput: llmOutputs.length ? this._combineLLMOutput?.(...llmOutputs) : undefined\n    };\n    Object.defineProperty(output, RUN_KEY, {\n      value: runManagers ? {\n        runIds: runManagers?.map(manager => manager.runId)\n      } : undefined,\n      configurable: true\n    });\n    return output;\n  }\n  async _generateCached({\n    messages,\n    cache,\n    llmStringKey,\n    parsedOptions,\n    handledOptions\n  }) {\n    const baseMessages = messages.map(messageList => messageList.map(coerceMessageLikeToMessage));\n    // create callback manager and start run\n    const callbackManager_ = await CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, handledOptions.metadata, this.metadata, {\n      verbose: this.verbose\n    });\n    const extra = {\n      options: parsedOptions,\n      invocation_params: this?.invocationParams(parsedOptions),\n      batch_size: 1,\n      cached: true\n    };\n    const runManagers = await callbackManager_?.handleChatModelStart(this.toJSON(), baseMessages, undefined, undefined, extra, undefined, undefined, handledOptions.runName);\n    // generate results\n    const missingPromptIndices = [];\n    const results = await Promise.allSettled(baseMessages.map(async (baseMessage, index) => {\n      // Join all content into one string for the prompt index\n      const prompt = BaseChatModel._convertInputToPromptValue(baseMessage).toString();\n      const result = await cache.lookup(prompt, llmStringKey);\n      if (result == null) {\n        missingPromptIndices.push(index);\n      }\n      return result;\n    }));\n    // Map run managers to the results before filtering out null results\n    // Null results are just absent from the cache.\n    const cachedResults = results.map((result, index) => ({\n      result,\n      runManager: runManagers?.[index]\n    })).filter(({\n      result\n    }) => result.status === \"fulfilled\" && result.value != null || result.status === \"rejected\");\n    // Handle results and call run managers\n    const generations = [];\n    await Promise.all(cachedResults.map(async ({\n      result: promiseResult,\n      runManager\n    }, i) => {\n      if (promiseResult.status === \"fulfilled\") {\n        const result = promiseResult.value;\n        generations[i] = result;\n        if (result.length) {\n          await runManager?.handleLLMNewToken(result[0].text);\n        }\n        return runManager?.handleLLMEnd({\n          generations: [result]\n        });\n      } else {\n        // status === \"rejected\"\n        await runManager?.handleLLMError(promiseResult.reason);\n        return Promise.reject(promiseResult.reason);\n      }\n    }));\n    const output = {\n      generations,\n      missingPromptIndices\n    };\n    // This defines RUN_KEY as a non-enumerable property on the output object\n    // so that it is not serialized when the output is stringified, and so that\n    // it isnt included when listing the keys of the output object.\n    Object.defineProperty(output, RUN_KEY, {\n      value: runManagers ? {\n        runIds: runManagers?.map(manager => manager.runId)\n      } : undefined,\n      configurable: true\n    });\n    return output;\n  }\n  /**\n   * Generates chat based on the input messages.\n   * @param messages An array of arrays of BaseMessage instances.\n   * @param options The call options or an array of stop sequences.\n   * @param callbacks The callbacks for the language model.\n   * @returns A Promise that resolves to an LLMResult.\n   */\n  async generate(messages, options, callbacks) {\n    // parse call options\n    let parsedOptions;\n    if (Array.isArray(options)) {\n      parsedOptions = {\n        stop: options\n      };\n    } else {\n      parsedOptions = options;\n    }\n    const baseMessages = messages.map(messageList => messageList.map(coerceMessageLikeToMessage));\n    const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptions(parsedOptions);\n    runnableConfig.callbacks = runnableConfig.callbacks ?? callbacks;\n    if (!this.cache) {\n      return this._generateUncached(baseMessages, callOptions, runnableConfig);\n    }\n    const {\n      cache\n    } = this;\n    const llmStringKey = this._getSerializedCacheKeyParametersForCall(callOptions);\n    const {\n      generations,\n      missingPromptIndices\n    } = await this._generateCached({\n      messages: baseMessages,\n      cache,\n      llmStringKey,\n      parsedOptions: callOptions,\n      handledOptions: runnableConfig\n    });\n    let llmOutput = {};\n    if (missingPromptIndices.length > 0) {\n      const results = await this._generateUncached(missingPromptIndices.map(i => baseMessages[i]), callOptions, runnableConfig);\n      await Promise.all(results.generations.map(async (generation, index) => {\n        const promptIndex = missingPromptIndices[index];\n        generations[promptIndex] = generation;\n        // Join all content into one string for the prompt index\n        const prompt = BaseChatModel._convertInputToPromptValue(baseMessages[promptIndex]).toString();\n        return cache.update(prompt, llmStringKey, generation);\n      }));\n      llmOutput = results.llmOutput ?? {};\n    }\n    return {\n      generations,\n      llmOutput\n    };\n  }\n  /**\n   * Get the parameters used to invoke the model\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  invocationParams(_options) {\n    return {};\n  }\n  _modelType() {\n    return \"base_chat_model\";\n  }\n  /**\n   * @deprecated\n   * Return a json-like object representing this LLM.\n   */\n  serialize() {\n    return {\n      ...this.invocationParams(),\n      _type: this._llmType(),\n      _model: this._modelType()\n    };\n  }\n  /**\n   * Generates a prompt based on the input prompt values.\n   * @param promptValues An array of BasePromptValue instances.\n   * @param options The call options or an array of stop sequences.\n   * @param callbacks The callbacks for the language model.\n   * @returns A Promise that resolves to an LLMResult.\n   */\n  async generatePrompt(promptValues, options, callbacks) {\n    const promptMessages = promptValues.map(promptValue => promptValue.toChatMessages());\n    return this.generate(promptMessages, options, callbacks);\n  }\n  /**\n   * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n   *\n   * Makes a single call to the chat model.\n   * @param messages An array of BaseMessage instances.\n   * @param options The call options or an array of stop sequences.\n   * @param callbacks The callbacks for the language model.\n   * @returns A Promise that resolves to a BaseMessage.\n   */\n  async call(messages, options, callbacks) {\n    const result = await this.generate([messages.map(coerceMessageLikeToMessage)], options, callbacks);\n    const generations = result.generations;\n    return generations[0][0].message;\n  }\n  /**\n   * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n   *\n   * Makes a single call to the chat model with a prompt value.\n   * @param promptValue The value of the prompt.\n   * @param options The call options or an array of stop sequences.\n   * @param callbacks The callbacks for the language model.\n   * @returns A Promise that resolves to a BaseMessage.\n   */\n  async callPrompt(promptValue, options, callbacks) {\n    const promptMessages = promptValue.toChatMessages();\n    return this.call(promptMessages, options, callbacks);\n  }\n  /**\n   * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n   *\n   * Predicts the next message based on the input messages.\n   * @param messages An array of BaseMessage instances.\n   * @param options The call options or an array of stop sequences.\n   * @param callbacks The callbacks for the language model.\n   * @returns A Promise that resolves to a BaseMessage.\n   */\n  async predictMessages(messages, options, callbacks) {\n    return this.call(messages, options, callbacks);\n  }\n  /**\n   * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n   *\n   * Predicts the next message based on a text input.\n   * @param text The text input.\n   * @param options The call options or an array of stop sequences.\n   * @param callbacks The callbacks for the language model.\n   * @returns A Promise that resolves to a string.\n   */\n  async predict(text, options, callbacks) {\n    const message = new HumanMessage(text);\n    const result = await this.call([message], options, callbacks);\n    if (typeof result.content !== \"string\") {\n      throw new Error(\"Cannot use predict when output is not a string.\");\n    }\n    return result.content;\n  }\n}\n/**\n * An abstract class that extends BaseChatModel and provides a simple\n * implementation of _generate.\n */\nexport class SimpleChatModel extends BaseChatModel {\n  async _generate(messages, options, runManager) {\n    const text = await this._call(messages, options, runManager);\n    const message = new AIMessage(text);\n    if (typeof message.content !== \"string\") {\n      throw new Error(\"Cannot generate with a simple chat model when output is not a string.\");\n    }\n    return {\n      generations: [{\n        text: message.content,\n        message\n      }]\n    };\n  }\n}","map":{"version":3,"names":["AIMessage","HumanMessage","coerceMessageLikeToMessage","RUN_KEY","BaseLanguageModel","CallbackManager","createChatMessageChunkEncoderStream","textEncoder","TextEncoder","TransformStream","transform","chunk","controller","enqueue","encode","content","JSON","stringify","BaseChatModel","constructor","fields","Object","defineProperty","enumerable","configurable","writable","value","_llmType","_separateRunnableConfigFromCallOptions","options","runnableConfig","callOptions","timeout","signal","AbortSignal","invoke","input","promptValue","_convertInputToPromptValue","result","generatePrompt","callbacks","chatGeneration","generations","message","_streamResponseChunks","_messages","_options","_runManager","Error","_streamIterator","prototype","prompt","messages","toChatMessages","callbackManager_","configure","tags","metadata","verbose","extra","invocation_params","invocationParams","batch_size","runManagers","handleChatModelStart","toJSON","undefined","runName","generationChunk","response_metadata","generationInfo","concat","err","Promise","all","map","runManager","handleLLMError","handleLLMEnd","_generateUncached","parsedOptions","handledOptions","baseMessages","messageList","results","allSettled","i","_generate","promptIndex","llmOutputs","pResult","status","generation","length","llmOutput","reason","reject","output","_combineLLMOutput","runIds","manager","runId","_generateCached","cache","llmStringKey","cached","missingPromptIndices","baseMessage","index","toString","lookup","push","cachedResults","filter","promiseResult","handleLLMNewToken","text","generate","Array","isArray","stop","_getSerializedCacheKeyParametersForCall","update","_modelType","serialize","_type","_model","promptValues","promptMessages","call","callPrompt","predictMessages","predict","SimpleChatModel","_call"],"sources":["/home/nikhil/legalbot/legalbot/node_modules/@langchain/core/dist/language_models/chat_models.js"],"sourcesContent":["import { AIMessage, HumanMessage, coerceMessageLikeToMessage, } from \"../messages/index.js\";\nimport { RUN_KEY, } from \"../outputs.js\";\nimport { BaseLanguageModel, } from \"./base.js\";\nimport { CallbackManager, } from \"../callbacks/manager.js\";\n/**\n * Creates a transform stream for encoding chat message chunks.\n * @deprecated Use {@link BytesOutputParser} instead\n * @returns A TransformStream instance that encodes chat message chunks.\n */\nexport function createChatMessageChunkEncoderStream() {\n    const textEncoder = new TextEncoder();\n    return new TransformStream({\n        transform(chunk, controller) {\n            controller.enqueue(textEncoder.encode(typeof chunk.content === \"string\"\n                ? chunk.content\n                : JSON.stringify(chunk.content)));\n        },\n    });\n}\n/**\n * Base class for chat models. It extends the BaseLanguageModel class and\n * provides methods for generating chat based on input messages.\n */\nexport class BaseChatModel extends BaseLanguageModel {\n    constructor(fields) {\n        super(fields);\n        // Only ever instantiated in main LangChain\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"chat_models\", this._llmType()]\n        });\n    }\n    _separateRunnableConfigFromCallOptions(options) {\n        const [runnableConfig, callOptions] = super._separateRunnableConfigFromCallOptions(options);\n        if (callOptions?.timeout && !callOptions.signal) {\n            callOptions.signal = AbortSignal.timeout(callOptions.timeout);\n        }\n        return [runnableConfig, callOptions];\n    }\n    /**\n     * Invokes the chat model with a single input.\n     * @param input The input for the language model.\n     * @param options The call options.\n     * @returns A Promise that resolves to a BaseMessageChunk.\n     */\n    async invoke(input, options) {\n        const promptValue = BaseChatModel._convertInputToPromptValue(input);\n        const result = await this.generatePrompt([promptValue], options, options?.callbacks);\n        const chatGeneration = result.generations[0][0];\n        // TODO: Remove cast after figuring out inheritance\n        return chatGeneration.message;\n    }\n    // eslint-disable-next-line require-yield\n    async *_streamResponseChunks(_messages, _options, _runManager) {\n        throw new Error(\"Not implemented.\");\n    }\n    async *_streamIterator(input, options) {\n        // Subclass check required to avoid double callbacks with default implementation\n        if (this._streamResponseChunks ===\n            BaseChatModel.prototype._streamResponseChunks) {\n            yield this.invoke(input, options);\n        }\n        else {\n            const prompt = BaseChatModel._convertInputToPromptValue(input);\n            const messages = prompt.toChatMessages();\n            const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptions(options);\n            const callbackManager_ = await CallbackManager.configure(runnableConfig.callbacks, this.callbacks, runnableConfig.tags, this.tags, runnableConfig.metadata, this.metadata, { verbose: this.verbose });\n            const extra = {\n                options: callOptions,\n                invocation_params: this?.invocationParams(callOptions),\n                batch_size: 1,\n            };\n            const runManagers = await callbackManager_?.handleChatModelStart(this.toJSON(), [messages], undefined, undefined, extra, undefined, undefined, runnableConfig.runName);\n            let generationChunk;\n            try {\n                for await (const chunk of this._streamResponseChunks(messages, callOptions, runManagers?.[0])) {\n                    chunk.message.response_metadata = {\n                        ...chunk.generationInfo,\n                        ...chunk.message.response_metadata,\n                    };\n                    yield chunk.message;\n                    if (!generationChunk) {\n                        generationChunk = chunk;\n                    }\n                    else {\n                        generationChunk = generationChunk.concat(chunk);\n                    }\n                }\n            }\n            catch (err) {\n                await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMError(err)));\n                throw err;\n            }\n            await Promise.all((runManagers ?? []).map((runManager) => runManager?.handleLLMEnd({\n                // TODO: Remove cast after figuring out inheritance\n                generations: [[generationChunk]],\n            })));\n        }\n    }\n    /** @ignore */\n    async _generateUncached(messages, parsedOptions, handledOptions) {\n        const baseMessages = messages.map((messageList) => messageList.map(coerceMessageLikeToMessage));\n        // create callback manager and start run\n        const callbackManager_ = await CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, handledOptions.metadata, this.metadata, { verbose: this.verbose });\n        const extra = {\n            options: parsedOptions,\n            invocation_params: this?.invocationParams(parsedOptions),\n            batch_size: 1,\n        };\n        const runManagers = await callbackManager_?.handleChatModelStart(this.toJSON(), baseMessages, undefined, undefined, extra, undefined, undefined, handledOptions.runName);\n        // generate results\n        const results = await Promise.allSettled(baseMessages.map((messageList, i) => this._generate(messageList, { ...parsedOptions, promptIndex: i }, runManagers?.[i])));\n        // handle results\n        const generations = [];\n        const llmOutputs = [];\n        await Promise.all(results.map(async (pResult, i) => {\n            if (pResult.status === \"fulfilled\") {\n                const result = pResult.value;\n                for (const generation of result.generations) {\n                    generation.message.response_metadata = {\n                        ...generation.generationInfo,\n                        ...generation.message.response_metadata,\n                    };\n                }\n                if (result.generations.length === 1) {\n                    result.generations[0].message.response_metadata = {\n                        ...result.llmOutput,\n                        ...result.generations[0].message.response_metadata,\n                    };\n                }\n                generations[i] = result.generations;\n                llmOutputs[i] = result.llmOutput;\n                return runManagers?.[i]?.handleLLMEnd({\n                    generations: [result.generations],\n                    llmOutput: result.llmOutput,\n                });\n            }\n            else {\n                // status === \"rejected\"\n                await runManagers?.[i]?.handleLLMError(pResult.reason);\n                return Promise.reject(pResult.reason);\n            }\n        }));\n        // create combined output\n        const output = {\n            generations,\n            llmOutput: llmOutputs.length\n                ? this._combineLLMOutput?.(...llmOutputs)\n                : undefined,\n        };\n        Object.defineProperty(output, RUN_KEY, {\n            value: runManagers\n                ? { runIds: runManagers?.map((manager) => manager.runId) }\n                : undefined,\n            configurable: true,\n        });\n        return output;\n    }\n    async _generateCached({ messages, cache, llmStringKey, parsedOptions, handledOptions, }) {\n        const baseMessages = messages.map((messageList) => messageList.map(coerceMessageLikeToMessage));\n        // create callback manager and start run\n        const callbackManager_ = await CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, handledOptions.metadata, this.metadata, { verbose: this.verbose });\n        const extra = {\n            options: parsedOptions,\n            invocation_params: this?.invocationParams(parsedOptions),\n            batch_size: 1,\n            cached: true,\n        };\n        const runManagers = await callbackManager_?.handleChatModelStart(this.toJSON(), baseMessages, undefined, undefined, extra, undefined, undefined, handledOptions.runName);\n        // generate results\n        const missingPromptIndices = [];\n        const results = await Promise.allSettled(baseMessages.map(async (baseMessage, index) => {\n            // Join all content into one string for the prompt index\n            const prompt = BaseChatModel._convertInputToPromptValue(baseMessage).toString();\n            const result = await cache.lookup(prompt, llmStringKey);\n            if (result == null) {\n                missingPromptIndices.push(index);\n            }\n            return result;\n        }));\n        // Map run managers to the results before filtering out null results\n        // Null results are just absent from the cache.\n        const cachedResults = results\n            .map((result, index) => ({ result, runManager: runManagers?.[index] }))\n            .filter(({ result }) => (result.status === \"fulfilled\" && result.value != null) ||\n            result.status === \"rejected\");\n        // Handle results and call run managers\n        const generations = [];\n        await Promise.all(cachedResults.map(async ({ result: promiseResult, runManager }, i) => {\n            if (promiseResult.status === \"fulfilled\") {\n                const result = promiseResult.value;\n                generations[i] = result;\n                if (result.length) {\n                    await runManager?.handleLLMNewToken(result[0].text);\n                }\n                return runManager?.handleLLMEnd({\n                    generations: [result],\n                });\n            }\n            else {\n                // status === \"rejected\"\n                await runManager?.handleLLMError(promiseResult.reason);\n                return Promise.reject(promiseResult.reason);\n            }\n        }));\n        const output = {\n            generations,\n            missingPromptIndices,\n        };\n        // This defines RUN_KEY as a non-enumerable property on the output object\n        // so that it is not serialized when the output is stringified, and so that\n        // it isnt included when listing the keys of the output object.\n        Object.defineProperty(output, RUN_KEY, {\n            value: runManagers\n                ? { runIds: runManagers?.map((manager) => manager.runId) }\n                : undefined,\n            configurable: true,\n        });\n        return output;\n    }\n    /**\n     * Generates chat based on the input messages.\n     * @param messages An array of arrays of BaseMessage instances.\n     * @param options The call options or an array of stop sequences.\n     * @param callbacks The callbacks for the language model.\n     * @returns A Promise that resolves to an LLMResult.\n     */\n    async generate(messages, options, callbacks) {\n        // parse call options\n        let parsedOptions;\n        if (Array.isArray(options)) {\n            parsedOptions = { stop: options };\n        }\n        else {\n            parsedOptions = options;\n        }\n        const baseMessages = messages.map((messageList) => messageList.map(coerceMessageLikeToMessage));\n        const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptions(parsedOptions);\n        runnableConfig.callbacks = runnableConfig.callbacks ?? callbacks;\n        if (!this.cache) {\n            return this._generateUncached(baseMessages, callOptions, runnableConfig);\n        }\n        const { cache } = this;\n        const llmStringKey = this._getSerializedCacheKeyParametersForCall(callOptions);\n        const { generations, missingPromptIndices } = await this._generateCached({\n            messages: baseMessages,\n            cache,\n            llmStringKey,\n            parsedOptions: callOptions,\n            handledOptions: runnableConfig,\n        });\n        let llmOutput = {};\n        if (missingPromptIndices.length > 0) {\n            const results = await this._generateUncached(missingPromptIndices.map((i) => baseMessages[i]), callOptions, runnableConfig);\n            await Promise.all(results.generations.map(async (generation, index) => {\n                const promptIndex = missingPromptIndices[index];\n                generations[promptIndex] = generation;\n                // Join all content into one string for the prompt index\n                const prompt = BaseChatModel._convertInputToPromptValue(baseMessages[promptIndex]).toString();\n                return cache.update(prompt, llmStringKey, generation);\n            }));\n            llmOutput = results.llmOutput ?? {};\n        }\n        return { generations, llmOutput };\n    }\n    /**\n     * Get the parameters used to invoke the model\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    invocationParams(_options) {\n        return {};\n    }\n    _modelType() {\n        return \"base_chat_model\";\n    }\n    /**\n     * @deprecated\n     * Return a json-like object representing this LLM.\n     */\n    serialize() {\n        return {\n            ...this.invocationParams(),\n            _type: this._llmType(),\n            _model: this._modelType(),\n        };\n    }\n    /**\n     * Generates a prompt based on the input prompt values.\n     * @param promptValues An array of BasePromptValue instances.\n     * @param options The call options or an array of stop sequences.\n     * @param callbacks The callbacks for the language model.\n     * @returns A Promise that resolves to an LLMResult.\n     */\n    async generatePrompt(promptValues, options, callbacks) {\n        const promptMessages = promptValues.map((promptValue) => promptValue.toChatMessages());\n        return this.generate(promptMessages, options, callbacks);\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n     *\n     * Makes a single call to the chat model.\n     * @param messages An array of BaseMessage instances.\n     * @param options The call options or an array of stop sequences.\n     * @param callbacks The callbacks for the language model.\n     * @returns A Promise that resolves to a BaseMessage.\n     */\n    async call(messages, options, callbacks) {\n        const result = await this.generate([messages.map(coerceMessageLikeToMessage)], options, callbacks);\n        const generations = result.generations;\n        return generations[0][0].message;\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n     *\n     * Makes a single call to the chat model with a prompt value.\n     * @param promptValue The value of the prompt.\n     * @param options The call options or an array of stop sequences.\n     * @param callbacks The callbacks for the language model.\n     * @returns A Promise that resolves to a BaseMessage.\n     */\n    async callPrompt(promptValue, options, callbacks) {\n        const promptMessages = promptValue.toChatMessages();\n        return this.call(promptMessages, options, callbacks);\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n     *\n     * Predicts the next message based on the input messages.\n     * @param messages An array of BaseMessage instances.\n     * @param options The call options or an array of stop sequences.\n     * @param callbacks The callbacks for the language model.\n     * @returns A Promise that resolves to a BaseMessage.\n     */\n    async predictMessages(messages, options, callbacks) {\n        return this.call(messages, options, callbacks);\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.2.0.\n     *\n     * Predicts the next message based on a text input.\n     * @param text The text input.\n     * @param options The call options or an array of stop sequences.\n     * @param callbacks The callbacks for the language model.\n     * @returns A Promise that resolves to a string.\n     */\n    async predict(text, options, callbacks) {\n        const message = new HumanMessage(text);\n        const result = await this.call([message], options, callbacks);\n        if (typeof result.content !== \"string\") {\n            throw new Error(\"Cannot use predict when output is not a string.\");\n        }\n        return result.content;\n    }\n}\n/**\n * An abstract class that extends BaseChatModel and provides a simple\n * implementation of _generate.\n */\nexport class SimpleChatModel extends BaseChatModel {\n    async _generate(messages, options, runManager) {\n        const text = await this._call(messages, options, runManager);\n        const message = new AIMessage(text);\n        if (typeof message.content !== \"string\") {\n            throw new Error(\"Cannot generate with a simple chat model when output is not a string.\");\n        }\n        return {\n            generations: [\n                {\n                    text: message.content,\n                    message,\n                },\n            ],\n        };\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}