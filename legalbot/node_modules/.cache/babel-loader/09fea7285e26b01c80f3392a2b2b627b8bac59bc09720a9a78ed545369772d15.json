{"ast":null,"code":"import { BaseLLMOutputParser, OutputParserException } from \"../base.js\";\n/**\n * Class for parsing the output of a tool-calling LLM into a JSON object.\n */\nexport class JsonOutputToolsParser extends BaseLLMOutputParser {\n  static lc_name() {\n    return \"JsonOutputToolsParser\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"returnId\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain\", \"output_parsers\", \"openai_tools\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    this.returnId = fields?.returnId ?? this.returnId;\n  }\n  /**\n   * Parses the output and returns a JSON object. If `argsOnly` is true,\n   * only the arguments of the function call are returned.\n   * @param generations The output of the LLM to parse.\n   * @returns A JSON object representation of the function call or its arguments.\n   */\n  async parseResult(generations) {\n    const toolCalls = generations[0].message.additional_kwargs.tool_calls;\n    if (!toolCalls) {\n      throw new Error(`No tools_call in message ${JSON.stringify(generations)}`);\n    }\n    const clonedToolCalls = JSON.parse(JSON.stringify(toolCalls));\n    const parsedToolCalls = [];\n    for (const toolCall of clonedToolCalls) {\n      if (toolCall.function !== undefined) {\n        // @ts-expect-error name and arguemnts are defined by Object.defineProperty\n        const parsedToolCall = {\n          type: toolCall.function.name,\n          args: JSON.parse(toolCall.function.arguments)\n        };\n        if (this.returnId) {\n          parsedToolCall.id = toolCall.id;\n        }\n        // backward-compatibility with previous\n        // versions of Langchain JS, which uses `name` and `arguments`\n        Object.defineProperty(parsedToolCall, \"name\", {\n          get() {\n            return this.type;\n          }\n        });\n        Object.defineProperty(parsedToolCall, \"arguments\", {\n          get() {\n            return this.args;\n          }\n        });\n        parsedToolCalls.push(parsedToolCall);\n      }\n    }\n    return parsedToolCalls;\n  }\n}\n/**\n * Class for parsing the output of a tool-calling LLM into a JSON object if you are\n * expecting only a single tool to be called.\n */\nexport class JsonOutputKeyToolsParser extends BaseLLMOutputParser {\n  static lc_name() {\n    return \"JsonOutputKeyToolsParser\";\n  }\n  constructor(params) {\n    super(params);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain\", \"output_parsers\", \"openai_tools\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"returnId\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    /** The type of tool calls to return. */\n    Object.defineProperty(this, \"keyName\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /** Whether to return only the first tool call. */\n    Object.defineProperty(this, \"returnSingle\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"initialParser\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"zodSchema\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.keyName = params.keyName;\n    this.returnSingle = params.returnSingle ?? this.returnSingle;\n    this.initialParser = new JsonOutputToolsParser(params);\n    this.zodSchema = params.zodSchema;\n  }\n  async _validateResult(result) {\n    if (this.zodSchema === undefined) {\n      return result;\n    }\n    const zodParsedResult = await this.zodSchema.safeParseAsync(result);\n    if (zodParsedResult.success) {\n      return zodParsedResult.data;\n    } else {\n      throw new OutputParserException(`Failed to parse. Text: \"${JSON.stringify(result, null, 2)}\". Error: ${JSON.stringify(zodParsedResult.error.errors)}`, JSON.stringify(result, null, 2));\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async parseResult(generations) {\n    const results = await this.initialParser.parseResult(generations);\n    const matchingResults = results.filter(result => result.type === this.keyName);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let returnedValues = matchingResults;\n    if (!this.returnId) {\n      returnedValues = matchingResults.map(result => result.args);\n    }\n    if (this.returnSingle) {\n      return this._validateResult(returnedValues[0]);\n    }\n    const toolCallResults = await Promise.all(returnedValues.map(value => this._validateResult(value)));\n    return toolCallResults;\n  }\n}","map":{"version":3,"names":["BaseLLMOutputParser","OutputParserException","JsonOutputToolsParser","lc_name","constructor","fields","Object","defineProperty","enumerable","configurable","writable","value","returnId","parseResult","generations","toolCalls","message","additional_kwargs","tool_calls","Error","JSON","stringify","clonedToolCalls","parse","parsedToolCalls","toolCall","function","undefined","parsedToolCall","type","name","args","arguments","id","get","push","JsonOutputKeyToolsParser","params","keyName","returnSingle","initialParser","zodSchema","_validateResult","result","zodParsedResult","safeParseAsync","success","data","error","errors","results","matchingResults","filter","returnedValues","map","toolCallResults","Promise","all"],"sources":["/home/nikhil/legalbot/legalbot/node_modules/@langchain/core/dist/output_parsers/openai_tools/json_output_tools_parsers.js"],"sourcesContent":["import { BaseLLMOutputParser, OutputParserException } from \"../base.js\";\n/**\n * Class for parsing the output of a tool-calling LLM into a JSON object.\n */\nexport class JsonOutputToolsParser extends BaseLLMOutputParser {\n    static lc_name() {\n        return \"JsonOutputToolsParser\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"returnId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"output_parsers\", \"openai_tools\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        this.returnId = fields?.returnId ?? this.returnId;\n    }\n    /**\n     * Parses the output and returns a JSON object. If `argsOnly` is true,\n     * only the arguments of the function call are returned.\n     * @param generations The output of the LLM to parse.\n     * @returns A JSON object representation of the function call or its arguments.\n     */\n    async parseResult(generations) {\n        const toolCalls = generations[0].message.additional_kwargs.tool_calls;\n        if (!toolCalls) {\n            throw new Error(`No tools_call in message ${JSON.stringify(generations)}`);\n        }\n        const clonedToolCalls = JSON.parse(JSON.stringify(toolCalls));\n        const parsedToolCalls = [];\n        for (const toolCall of clonedToolCalls) {\n            if (toolCall.function !== undefined) {\n                // @ts-expect-error name and arguemnts are defined by Object.defineProperty\n                const parsedToolCall = {\n                    type: toolCall.function.name,\n                    args: JSON.parse(toolCall.function.arguments),\n                };\n                if (this.returnId) {\n                    parsedToolCall.id = toolCall.id;\n                }\n                // backward-compatibility with previous\n                // versions of Langchain JS, which uses `name` and `arguments`\n                Object.defineProperty(parsedToolCall, \"name\", {\n                    get() {\n                        return this.type;\n                    },\n                });\n                Object.defineProperty(parsedToolCall, \"arguments\", {\n                    get() {\n                        return this.args;\n                    },\n                });\n                parsedToolCalls.push(parsedToolCall);\n            }\n        }\n        return parsedToolCalls;\n    }\n}\n/**\n * Class for parsing the output of a tool-calling LLM into a JSON object if you are\n * expecting only a single tool to be called.\n */\nexport class JsonOutputKeyToolsParser extends BaseLLMOutputParser {\n    static lc_name() {\n        return \"JsonOutputKeyToolsParser\";\n    }\n    constructor(params) {\n        super(params);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"output_parsers\", \"openai_tools\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"returnId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        /** The type of tool calls to return. */\n        Object.defineProperty(this, \"keyName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** Whether to return only the first tool call. */\n        Object.defineProperty(this, \"returnSingle\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"initialParser\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"zodSchema\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.keyName = params.keyName;\n        this.returnSingle = params.returnSingle ?? this.returnSingle;\n        this.initialParser = new JsonOutputToolsParser(params);\n        this.zodSchema = params.zodSchema;\n    }\n    async _validateResult(result) {\n        if (this.zodSchema === undefined) {\n            return result;\n        }\n        const zodParsedResult = await this.zodSchema.safeParseAsync(result);\n        if (zodParsedResult.success) {\n            return zodParsedResult.data;\n        }\n        else {\n            throw new OutputParserException(`Failed to parse. Text: \"${JSON.stringify(result, null, 2)}\". Error: ${JSON.stringify(zodParsedResult.error.errors)}`, JSON.stringify(result, null, 2));\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async parseResult(generations) {\n        const results = await this.initialParser.parseResult(generations);\n        const matchingResults = results.filter((result) => result.type === this.keyName);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let returnedValues = matchingResults;\n        if (!this.returnId) {\n            returnedValues = matchingResults.map((result) => result.args);\n        }\n        if (this.returnSingle) {\n            return this._validateResult(returnedValues[0]);\n        }\n        const toolCallResults = await Promise.all(returnedValues.map((value) => this._validateResult(value)));\n        return toolCallResults;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}